<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Linux项目2 | KIKI's Blog</title><meta name="keywords" content="博客"><meta name="author" content="KIKI"><meta name="copyright" content="KIKI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录牛客项目">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux项目2">
<meta property="og:url" content="http://example.com/2022/12/16/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE2/index.html">
<meta property="og:site_name" content="KIKI&#39;s Blog">
<meta property="og:description" content="记录牛客项目">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg">
<meta property="article:published_time" content="2022-12-15T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-01T05:32:34.254Z">
<meta property="article:author" content="KIKI">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/16/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux项目2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-01 13:32:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="KIKI's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/006GMZnVgy1g4jclj8kuvj31400u0dy6.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">KIKI's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux项目2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-15T16:00:00.000Z" title="发表于 2022-12-16 00:00:00">2022-12-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-01T05:32:34.254Z" title="更新于 2023-01-01 13:32:34">2023-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux项目2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><ol>
<li>进程状态转换</li>
<li>进程创建fork，exec函数族</li>
<li>孤儿进程，僵尸进程，解决方法：wait,waitpid</li>
<li>进程间通信方式：管道，内存映射，信号</li>
<li>守护进程<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2>程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：</li>
<li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）</li>
<li>机器语言指令：对程序算法进行编码。</li>
<li>程序入口地址：标识程序开始执行时的起始指令位置。</li>
<li>数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。</li>
<li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li>
<li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。</li>
<li>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</li>
</ol>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。<strong>程序不占用系统CPU，内存等资源，进程需要占用</strong></p>
<p>可以用一个程序来创建多个进程，进程是由内核定义的<strong>抽象实体</strong>，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p>
<h2 id="单道-amp-多道程序设计"><a href="#单道-amp-多道程序设计" class="headerlink" title="单道&amp;多道程序设计"></a>单道&amp;多道程序设计</h2><p>单道程序，即在计算机内存中只允许一个的程序运行。<br>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，<strong>相互穿插运行（宏观上是同时进行的，但实际上每个时刻只能有一个程序在执行）</strong>，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</p>
<p>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。<br>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p>
<h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态反映执行过的变化。 这些随着和外界条件而转换进程状态反映执行过的变化。<br>三态模型：就绪态，运行态，阻塞态。<br>五态模型：新建态、就绪态，运行态，阻塞态，终止态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20221216162857.png" alt=""></p>
<p>阻塞态不能直接转换到就绪态，和其他进程抢夺资源再进入运行态</p>
<p>图中没有画出，但就绪态和阻塞态可以直接到达终止态，进入终止态之后就不能再执行了，会释放用户区的数据</p>
<p>查看进程信息命令：</p>
<blockquote>
<p>ps ajx/aux<br>PID进程ID,PPID父进程ID，PGID组ID，SID会话ID</p>
</blockquote>
<h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>进程可以创建新进程，形成进程树<br>打开的终端自身也是一个进程，父进程和子进程是交替运行的<br>子进程会复制父进程的虚拟地址空间，实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。<br>写时拷贝是一种可以推迟甚至避免拷贝数据的技术。<br>内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。<br><strong>只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</strong><br>也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。<br>注意：fork之后父子进程共享文件，<br>fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pid_t fork(void);</span></span><br><span class="line"><span class="comment">作用：创建一个子进程</span></span><br><span class="line"><span class="comment">返回值：返回两次，一次在父进程，一次在子进程</span></span><br><span class="line"><span class="comment">在父进程中，成功：返回子进程的ID，失败：返回-1，设置errno为EAGAIN（进程数达到上限）或ENOME（没有内存）</span></span><br><span class="line"><span class="comment">在子进程中，成功：返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">//子进程仅执行该行代码之后的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;pid : %d\n&quot;, pid);</span></span><br><span class="line">        <span class="comment">// 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num += 10 : %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num += 100 : %d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="父子进程之间的关系"><a href="#父子进程之间的关系" class="headerlink" title="父子进程之间的关系"></a>父子进程之间的关系</h3><p>区别：<br>    1.fork()函数的返回值不同<br>        父进程中: &gt;0 返回的子进程的ID<br>        子进程中: =0<br>    2.pcb中的一些数据<br>        当前的进程的id pid<br>        当前的进程的父进程的id ppid<br>        信号集</p>
<p>共同点：<br>    某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</p>
<pre><code>    - 用户区的数据
    - 文件描述符表
</code></pre><p>父子进程对变量是不是共享的？</p>
<pre><code>- 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。
- 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。
</code></pre><h2 id="有名管道（FIFO）"><a href="#有名管道（FIFO）" class="headerlink" title="有名管道（FIFO）"></a>有名管道（FIFO）</h2><p>匿名管道由于没有名字，因此只能用于亲缘关系的进程间通信</p>
<h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>将硬件中的物理位置映射到内存中，实现通信<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line">mmap,munmap</span><br></pre></td></tr></table></figure><br>void <em>mmap(void </em>addr, size_t length, int prot, int flags,int fd, off_t offset);<br>功能：将一个文件或者设备的数据映射到内存中<br>参数：</p>
<blockquote>
<p>void *addr: NULL, 由内核指定，指映射到内核中的地址<br>length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。（获取文件的长度：stat lseek）<br>prot : 对申请的内存映射区的操作权限</p>
<ol>
<li>PROT_EXEC ：可执行的权限</li>
<li>PROT_READ ：读权限</li>
<li>PROT_WRITE ：写权限</li>
<li>PROT_NONE ：没有权限<br>要操作映射内存，<strong>必须要有读的权限。</strong>PROT_READ（读）、PROT_READ|PROT_WRITE（读写）</li>
</ol>
<p>flags :</p>
<ol>
<li>MAP_SHARED : <strong>映射区的数据会自动和磁盘文件进行同步</strong>，进程间通信，必须要设置这个选项</li>
<li>MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建</li>
</ol>
<p>fd: 需要映射的那个文件的文件描述符，通过open得到，open的是一个磁盘文件<br>注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。<strong>prot的权限必须小于open的权限，且必须有read权限</strong><br>prot: PROT_READ, open:只读/读写<br>prot: PROT_READ | PROT_WRITE, open:读写</p>
<p>offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移。</p>
</blockquote>
<p>返回值：</p>
<blockquote>
<p>返回创建的内存的首地址<br>失败返回MAP_FAILED，(void *) -1</p>
</blockquote>
<p>int munmap(void *addr, size_t length);<br>功能：释放内存映射<br>参数：</p>
<blockquote>
<p>addr : 要释放的内存的首地址<br>length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</p>
</blockquote>
<p>使用内存映射实现进程间通信：</p>
<ol>
<li><p>有关系的进程（父子进程）<br>还没有子进程的时候：通过唯一的父进程，先创建内存映射区<br>有了内存映射区以后，创建子进程：父子进程共享创建的内存映射区</p>
</li>
<li><p>没有关系的进程间通信<br>准备一个大小不是0的磁盘文件<br>进程1 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针<br>进程2 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针，使用内存映射区通信</p>
</li>
</ol>
<p>注意：内存映射区通信，是非阻塞。</p>
<h2 id="设置定时器setitimer"><a href="#设置定时器setitimer" class="headerlink" title="设置定时器setitimer"></a>设置定时器setitimer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &lt;sys/time.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_value,struct itimerval *old_value)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：</p>
<blockquote>
<p>设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时<br>参数：<br>which : 定时器以什么时间计时</p>
<ol>
<li>ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</li>
<li>ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</li>
<li>ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</li>
</ol>
<p>new_value: 设置定时器的属性<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span>      <span class="comment">// 定时器的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span>  <span class="comment">// 每个阶段的时间，间隔时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>     <span class="comment">// 延迟多长时间执行定时器</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span>        <span class="comment">// 时间的结构体</span></span><br><span class="line">    <span class="keyword">time_t</span>      tv_sec;     <span class="comment">//  秒数     </span></span><br><span class="line">    <span class="keyword">suseconds_t</span> tv_usec;    <span class="comment">//  微秒    </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>过10秒后，每个2秒定时一次<br>old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</p>
</blockquote>
<p>返回值：</p>
<blockquote>
<p>成功 0<br>失败 -1 并设置错误号</p>
</blockquote>
<h2 id="捕捉信号"><a href="#捕捉信号" class="headerlink" title="捕捉信号"></a>捕捉信号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能：设置某个信号的捕捉行为，<strong>SIGKILL SIGSTOP不能被捕捉，不能被忽略。</strong><br>参数：</p>
<blockquote>
<p>signum: 要捕捉的信号,一般使用宏值<br>handler: 捕捉到信号要如何处理</p>
<ol>
<li>SIG_IGN ： 忽略信号</li>
<li>SIG_DFL ： 使用信号默认的行为</li>
<li>回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。<ol>
<li>需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</li>
<li>不是程序员调用，而是当信号产生，由内核调用</li>
<li>函数指针是实现回调的手段，函数实现之后，<strong>将函数名放到函数指针的位置就可以了。</strong></li>
</ol>
</li>
</ol>
</blockquote>
<p>返回值：</p>
<blockquote>
<p>成功，返回上一次注册的信号处理函数的地址。（sighandler_t）类型第一次调用返回NULL<br>失败，返回SIG_ERR，设置错误号</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myalarm</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="comment">// signal(SIGALRM, SIG_IGN);</span></span><br><span class="line">    <span class="comment">// signal(SIGALRM, SIG_DFL);</span></span><br><span class="line">    <span class="comment">// void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。</span></span><br><span class="line">    signal(SIGALRM, myalarm);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="信号集和相关函数"><a href="#信号集和相关函数" class="headerlink" title="信号集和相关函数"></a>信号集和相关函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol>
<li><p>用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</p>
</li>
<li><p>信号产生但是没有被处理 （未决）<br>在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）<br>SIGINT信号状态被存储在第二个标志位上<br>这个标志位的值为0， 说明信号不是未决状态<br>这个<strong>标志位的值为1， 说明信号处于未决状态</strong></p>
</li>
<li><p>这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较<br>阻塞信号集默认不阻塞任何的信号，如果想要阻塞某些信号需要用户调用系统的API</p>
</li>
<li><p>在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了<br>如果没有阻塞，这个信号就被处理<br><strong>如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</strong></p>
</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>以下信号集相关的函数<strong>都是对自定义的信号集进行操作</strong>。</p>
<p>int sigemptyset(sigset_t <em>set);<br>int sigfillset(sigset_t </em>set);</p>
<blockquote>
<p>功能：<br>将信号集中的所有的标志位置为0(sigemptyset)<br>将信号集中的所有的标志位置为1(sigfillset)<br>参数：set, 传出参数，需要操作的信号集<br>返回值：成功返回0， 失败返回-1</p>
</blockquote>
<p>int sigaddset(sigset_t <em>set, int signum);<br>int sigdelset(sigset_t </em>set, int signum);</p>
<blockquote>
<p>功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号<br>参数：<br>set：传出参数，需要操作的信号集<br>signum：<br>需要设置阻塞的那个信号(sigaddset)<br>需要设置不阻塞的那个信号(sigdelset)<br>返回值：成功返回0， 失败返回-1</p>
</blockquote>
<p>int sigismember(const sigset_t *set, int signum);</p>
<blockquote>
<p>功能：判断某个信号是否阻塞<br>参数：<br>set：需要操作的信号集<br>signum：需要判断的那个信号<br>返回值：<br>    1 ： signum被阻塞<br>    0 ： signum不阻塞<br>    -1 ： 失败</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个信号集</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空信号集的内容</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 SIGINT 是否在信号集 set 里</span></span><br><span class="line">    <span class="keyword">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加几个信号到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGINT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从信号集中删除一个信号</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>int sigprocmask(int how, const sigset_t <em>set, sigset_t </em>oldset);</p>
<blockquote>
<p>功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）<br>参数：<br>how : 如何对内核阻塞信号集进行处理</p>
<ol>
<li>SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变 假设内核中默认的阻塞信号集是mask， 这个操作相当于 <strong>mask = mask | set</strong>(set中需要设置<strong>阻塞的信号位设置为1</strong>)</li>
<li>SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞，相当于<strong>mask = mask &amp;= ~set</strong>(set中需要设置<strong>解除阻塞的信号位设置为1</strong>) </li>
<li>SIG_SETMASK:覆盖内核中原来的值</li>
</ol>
<p>set ：已经初始化好的用户自定义的信号集<br>oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL<br>返回值：成功：0,失败：-1,设置错误号：EFAULT、EINVAL</p>
</blockquote>
<p>int sigpending(sigset_t *set);</p>
<blockquote>
<p>功能：获取内核中的未决信号集<br>参数：set,传出参数，保存的是内核中的未决信号集中的信息。</p>
</blockquote>
<h2 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);</span><br></pre></td></tr></table></figure>
<p>功能：检查或者改变信号的处理。信号捕捉<br>参数：</p>
<blockquote>
<p>signum : 需要捕捉的信号的编号或者宏值（信号的名称）<br>act ：捕捉到信号之后的处理动作<br>oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</p>
</blockquote>
<p>返回值：成功 0, 失败 -1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">// 不常用</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span></span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line">    <span class="comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags;</span><br><span class="line">    <span class="comment">// 被废弃掉了</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><p>SIGCHLD信号产生的3个条件：</p>
<ol>
<li>子进程结束</li>
<li>子进程暂停了</li>
<li>子进程继续运行<br>都会给父进程发送该信号，父进程默认忽略该信号。<br>使用SIGCHLD信号解决<strong>僵尸进程</strong>的问题</li>
</ol>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>允许两个或多个进程共享物理内存中同一块区域，<strong>只需内核介入，效率更高</strong>，和管道，内存映射比更快。因为管道和内存映射都需要用户和内核之间的切换和数据拷贝。</p>
<h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><ol>
<li>调用shmget()创建一个新的共享内存段或取得一个现有的共享内存段的标识符。这个调用返回需要用到的共享内存标识符。</li>
<li>使用shmat()来附上共享内存段，使该段成为调用进程的虚拟内存的一部分。即，将上述共享内存段与进程绑定，可以通过进程的虚拟内存访问该共享内存段。</li>
<li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，<br>程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间<br>中该共享内存段的起点的指针。</li>
<li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在<strong>进程终止时会自动完成这一步</strong>。</li>
<li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。<strong>只有一个进程需要执行这一步。</strong></li>
</ol>
<h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><h4 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h4><p>shmget(key_t key, size_t size, int shmflg);<br>功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。新创建的内存段中的数据都会被初始化为0<br>参数：</p>
<blockquote>
<p>key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。一般使用16进制表示，非0值<br>size: 共享内存的大小<br>shmflg: 属性</p>
<ol>
<li>访问权限</li>
<li>附加属性：创建/判断共享内存是不是存在<ol>
<li>创建：IPC_CREAT</li>
<li>判断共享内存是否存在：IPC_EXCL , 需要和IPC_CREAT一起使用(IPC_CREAT | IPC_EXCL | 0664）即先判断，不存在的时候创建</li>
</ol>
</li>
</ol>
</blockquote>
<p>返回值：失败：-1 并设置错误号, 成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</p>
<h4 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h4><p>void <em>shmat(int shmid, const void </em>shmaddr, int shmflg);<br>功能：和当前的进程进行关联<br>参数：</p>
<blockquote>
<p>shmid : 共享内存的标识（ID）,由shmget返回值获取<br>shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定<br>shmflg : 对共享内存的操作</p>
<ol>
<li>读 ： SHM_RDONLY, <strong>必须要有读权限</strong></li>
<li>读写： 0，即默认有读写权限</li>
</ol>
</blockquote>
<p>返回值：成功：返回共享内存的首（起始）地址。  失败(void *) -1</p>
<h4 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h4><p>int shmdt(const void *shmaddr);</p>
<blockquote>
<p>功能：解除当前进程和共享内存的关联<br>参数：shmaddr：共享内存的首地址<br>返回值：成功 0， 失败 -1</p>
</blockquote>
<h4 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h4><p>int shmctl(int shmid, int cmd, struct shmid_ds *buf);<br>功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。<br>参数：</p>
<blockquote>
<p>shmid: 共享内存的ID<br>cmd : 要做的操作</p>
<ol>
<li>IPC_STAT : 获取共享内存的当前的状态</li>
<li>IPC_SET : 设置共享内存的状态</li>
<li>IPC_RMID: 标记共享内存被销毁</li>
</ol>
<p>buf：需要设置或者获取的共享内存的属性信息</p>
<ol>
<li>IPC_STAT : buf存储数据</li>
<li>IPC_SET : buf中需要初始化数据，设置到内核中</li>
<li>IPC_RMID : 没有用，NULL</li>
</ol>
</blockquote>
<h4 id="key-t-ftok"><a href="#key-t-ftok" class="headerlink" title="key_t ftok"></a>key_t ftok</h4><p>key_t ftok(const char *pathname, int proj_id);<br>功能：根据指定的路径名，和int值，生成一个共享内存的key<br>参数：</p>
<blockquote>
<p>pathname:指定一个存在的路径:/home/nowcoder/Linux/a.txt/<br>proj_id: int类型的值，但是这系统调用只会使用其中的1个字节<br>范围 ： 0-255  一般指定一个字符 ‘a’</p>
</blockquote>
<p>read.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取一个共享内存,第二个参数可以写0，表示是获取而不是创建一个</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="keyword">char</span> *)ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>write.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写数据,+1是拷贝字符串结束符</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>问题1：操作系统如何知道一块共享内存被多少个进程关联？</p>
<blockquote>
<p>共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch<br>shm_nattach 记录了关联的进程个数</p>
</blockquote>
<p>问题2：可不可以对共享内存进行多次删除 shmctl</p>
<blockquote>
<p>可以的<br>因为shmctl 标记删除共享内存，不是直接删除<br>什么时候真正删除呢?<br>当和共享内存关联的进程数为0的时候，就真正被删除<br>当共享内存的key为0的时候，表示共享内存被标记删除了<br>如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</p>
</blockquote>
<p>共享内存和内存映射的区别</p>
<blockquote>
<ol>
<li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li>
<li>共享内存效果更高</li>
<li>内存<br>所有的进程操作的是同一块共享内存。<br>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</li>
<li>数据安全<br>进程突然退出:共享内存还存在,内存映射区消失<br>运行进程的电脑死机，宕机了:数据存在在共享内存中，没有了,内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</li>
<li>生命周期<br>内存映射区：进程退出，内存映射区销毁<br>共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机<br>如果一个进程退出，会自动和共享内存进行取消关联。</li>
</ol>
</blockquote>
<h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">KIKI</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/12/16/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE2/">http://example.com/2022/12/16/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">KIKI's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/29/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE3/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux项目3</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/14/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux项目</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/006GMZnVgy1g4jclj8kuvj31400u0dy6.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">KIKI</div><div class="author-info__description">一只努力减脂的KI</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:2498333273@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E7%82%B9"><span class="toc-number">1.</span> <span class="toc-text">重点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">进程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%81%93-amp-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.</span> <span class="toc-text">单道&amp;多道程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">创建进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.3.</span> <span class="toc-text">父子进程之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">有名管道（FIFO）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">2.4.</span> <span class="toc-text">内存映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AE%9A%E6%97%B6%E5%99%A8setitimer"><span class="toc-number">2.5.</span> <span class="toc-text">设置定时器setitimer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E6%8D%89%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.6.</span> <span class="toc-text">捕捉信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%92%8C%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.</span> <span class="toc-text">信号集和相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.7.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">2.7.2.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sigaction"><span class="toc-number">2.8.</span> <span class="toc-text">sigaction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIGCHLD%E4%BF%A1%E5%8F%B7"><span class="toc-number">2.9.</span> <span class="toc-text">SIGCHLD信号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">2.10.</span> <span class="toc-text">共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">2.10.1.</span> <span class="toc-text">使用步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">2.10.2.</span> <span class="toc-text">操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#shmget"><span class="toc-number">2.10.2.1.</span> <span class="toc-text">shmget</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shmat"><span class="toc-number">2.10.2.2.</span> <span class="toc-text">shmat</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shmdt"><span class="toc-number">2.10.2.3.</span> <span class="toc-text">shmdt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shmctl"><span class="toc-number">2.10.2.4.</span> <span class="toc-text">shmctl</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#key-t-ftok"><span class="toc-number">2.10.2.5.</span> <span class="toc-text">key_t ftok</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.2.6.</span> <span class="toc-text">相关问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.11.</span> <span class="toc-text">守护进程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-07-11T16:00:00.000Z" title="发表于 2023-07-12 00:00:00">2023-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/11/C++/" title="C++学习笔记"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/C.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++学习笔记"/></a><div class="content"><a class="title" href="/2023/07/11/C++/" title="C++学习笔记">C++学习笔记</a><time datetime="2023-07-10T16:00:00.000Z" title="发表于 2023-07-11 00:00:00">2023-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/offer.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码随想录"/></a><div class="content"><a class="title" href="/2023/05/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录">代码随想录</a><time datetime="2023-05-07T16:00:00.000Z" title="发表于 2023-05-08 00:00:00">2023-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/OS/" title="操作系统"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2023/02/27/OS/" title="操作系统">操作系统</a><time datetime="2023-02-26T16:00:00.000Z" title="发表于 2023-02-27 00:00:00">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/" title="Linux项目补充和扩展"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux项目补充和扩展"/></a><div class="content"><a class="title" href="/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/" title="Linux项目补充和扩展">Linux项目补充和扩展</a><time datetime="2023-01-26T16:00:00.000Z" title="发表于 2023-01-27 00:00:00">2023-01-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By KIKI</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>