<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++学习笔记 | KIKI's Blog</title><meta name="keywords" content="博客"><meta name="author" content="KIKI"><meta name="copyright" content="KIKI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="主要总结C++的一些小的概念">
<meta property="og:type" content="article">
<meta property="og:title" content="C++学习笔记">
<meta property="og:url" content="http://example.com/2023/07/11/C++/index.html">
<meta property="og:site_name" content="KIKI&#39;s Blog">
<meta property="og:description" content="主要总结C++的一些小的概念">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/C.jpeg">
<meta property="article:published_time" content="2023-07-10T16:00:00.000Z">
<meta property="article:modified_time" content="2023-08-01T15:04:26.524Z">
<meta property="article:author" content="KIKI">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/C.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/11/C++/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-01 23:04:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="KIKI's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/006GMZnVgy1g4jclj8kuvj31400u0dy6.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/KIKI9731/image@main/C.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">KIKI's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-10T16:00:00.000Z" title="发表于 2023-07-11 00:00:00">2023-07-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-01T15:04:26.524Z" title="更新于 2023-08-01 23:04:26">2023-08-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h1><h2 id="快手CPP后端"><a href="#快手CPP后端" class="headerlink" title="快手CPP后端"></a>快手CPP后端</h2><p>【时间】1h<br>【公司】快手<br>【岗位】Cpp后端<br>【面经】</p>
<ol>
<li><p>讲讲C++11新特性，追问智能指针，再追问makeshare的优点（make shared为什么比直接一个指针传入更好）</p>
</li>
<li><p>问了常用的设计模式，几种设计模式都谈谈。追问，代理模式和适配器模式有什么区别，发布订阅和观察者有什么区别</p>
</li>
<li><p>http1.0/1.1 2.0 3.0区别，追问了quik协议</p>
</li>
<li><p>算法题1道简单dp，1道n皇后</p>
</li>
</ol>
<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><div class="note green icon simple"><i class="note-icon fab fa-internet-explorer"></i><p>8月1日</p>
</div>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><blockquote>
<p>怕你忘记释放，内存泄露，都是用来管理堆内存的<br><a target="_blank" rel="noopener" href="https://cppguide.cn/pages/23080e/">小方的讲解</a><br>智能指针其作⽤是管理⼀个指针，避免咋们程序员申请的空间在函数结束时忘记释放(<strong>也就是说主要是管理堆内存的</strong>)，造成内存泄漏这种情况滴发⽣。然后使⽤智能指针可以很⼤程度上的避免这个问题，因为智能指针就是⼀个类，当超出了类的作⽤域是，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。</p>
</blockquote>
<p>auto_ptr（C++98，C++11已抛弃）<br>auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr<Type>类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；<br>主要问题在于<strong>采用拷贝构造或者赋值时，原指针的所有权被剥夺，这样就存在内存泄露的问题</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;std::string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line"><span class="comment">//std::shared_ptr&lt;int&gt; p4 = new int(1);的写法是错误的</span></span><br><span class="line">auto_ptr&lt;std::string&gt; p2;</span><br><span class="line">p2 = p1; <span class="comment">//auto_ptr不会报错，但是此时p1已经不指向hello了，</span></span><br><span class="line"><span class="function">auto_ptr&lt;std::string&gt; <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line"><span class="comment">//拷贝构造和赋值类似，都会剥夺原指针的所有权</span></span><br></pre></td></tr></table></figure><br>get()是std::shared_ptr和std::unique_ptr这两个智能指针类的成员函数，它返回指针所持有的对象的原始指针，被剥夺所有权的指针，调用get返回NULL</p>
<p>unique_ptr<br>unique_ptr<strong>对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是1</strong>，std::unique_ptr对象销毁时会释放其持有的堆内存。可以使用以下方式初始化一个std::unique_ptr对象<br><strong>将赋值和拷贝构造均设为=delete，来解决auto_ptr的问题</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化方式1</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">123</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式2</span></span><br><span class="line">std::unique_ptr&lt;<span class="keyword">int</span>&gt; sp2;</span><br><span class="line">sp2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">123</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化方式3,推荐使用，更安全</span></span><br><span class="line">std::unique_ptr&lt;<span class="keyword">int</span>&gt; sp3 = std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><br>前述代码在编译时会报错，从而避免了内存泄漏，如需赋值需要用move操作,移动后sp1,sp2为空的智能指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp1</span><span class="params">(std::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">123</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">sp2</span><span class="params">(std::move(sp1))</span></span>;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;<span class="keyword">int</span>&gt; sp3;</span><br><span class="line">    sp3 = std::<span class="built_in">move</span>(sp2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>shraed_ptr<br>unique_ptr对其持有的资源具有独占性，而std::shared_ptr持有的资源可以在多个std::shared_ptr之间共享，每多一个std::shared_ptr对资源的引用，资源引用计数将增加1，每一个指向该资源的std::shared_ptr对象析构时，资源引用计数减1，最后一个std::shared_ptr对象析构时，发现资源计数为0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作std::shared_ptr引用的对象是安全的）。std::shared_ptr提供了一个use_count()方法来获取当前持有资源的引用计数。除了上面描述的，std::shared_ptr用法和std::unique_ptr基本相同。</p>
<blockquote>
<p>设置引用计数，利用.use_count()查看有几个指针指向该资源，计数为0时会析构<br>利用reset，放弃对该资源的引用，引用计数-1</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;B&gt; bPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;A&gt; aPtr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    a-&gt;bPtr = b;</span><br><span class="line">    b-&gt;aPtr = a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁a,要销毁a的成员变量，也就是b,但是b的引用计数不为0，因为如果要让b的引用计数为0，就要销毁b的成员变量a，形成死循环</p>
<p><strong>智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源）</strong>，主要是看原链接中关于栈变量的设置</p>
<p>weak_ptr<br>weak_ptr是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助std::shared_ptr工作。<br>std::weak_ptr可以从一个std::shared_ptr或另一个std::weak_ptr对象构造，std::shared_ptr可以直接赋值给std::weak_ptr,也可以通过std::weak_ptr的lock()函数来获得std::shared_ptr。它的构造和析构不会引起引用计数的增加或减少。<br><strong>std::weak_ptr可用来解决std::shared_ptr相互引用时的死锁问题，即两个std::shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0， 资源永远不会释放。</strong><br>不修改引用计数，两个shared_ptr相互引用，会使各自引用计数为2，在离开作用域析构时，降为1，不会调用析构，所以需要weak_ptr，但是由于/weak_ptr没有重载<em>和-&gt;，<em>*所以不能直接操作资源</em></em></p>
<blockquote>
<p>weak_ptr提供了一个expired()方法来做这一项检测，返回true，说明其引用的资源已经不存在了；返回false，说明该资源仍然存在;<br>这个时候可以使用std::weak_ptr 的lock()方法得到一个std::shared_ptr对象然后继续操作资源，weak_ptr类没有重写operator-&gt;和operator方法，因此不能像std::shared_ptr或std::unique_ptr一样直接操作对象，同时std::weak_ptr类也没有重写operator bool()操作，因此也不能通过std::weak_ptr*对象直接判断其引用的资源是否存在</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tmpConn_是一个std::weak_ptr&lt;TcpConnection&gt;对象</span></span><br><span class="line"><span class="comment">//tmpConn_引用的TcpConnection已经销毁，直接返回</span></span><br><span class="line"><span class="keyword">if</span> (tmpConn_.<span class="built_in">expired</span>())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.<span class="built_in">lock</span>();</span><br><span class="line"><span class="keyword">if</span> (conn)<span class="comment">//只能用shared_ptr操作，因为weak_ptr没有重载*和-&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对conn进行操作，省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>补充：</strong><br>Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组，但智能指针可以<br>一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；<br>除了std::weak_ptr，std::unique_ptr和std::shared_ptr都提供了获取原始指针的方法——<strong>get()</strong>函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">    Subscriber* pSubscriber = <span class="keyword">new</span> <span class="built_in">Subscriber</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::unique_ptr&lt;Subscriber&gt; <span class="title">spSubscriber</span><span class="params">(pSubscriber)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//pTheSameSubscriber和pSubscriber指向同一个对象</span></span><br><span class="line">    Subscriber* pTheSameSubscriber= spSubscriber.<span class="built_in">get</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>unique_ptr的指针大小和原始指针一样，64位机占8个字节，但是shared/weak都是16字节<br>通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用std::unique_ptr，反之使用std::shared_ptr，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用std::weak_ptr</p>
<h2 id="C-中内存分配情况"><a href="#C-中内存分配情况" class="headerlink" title="C++中内存分配情况"></a>C++中内存分配情况</h2><p><img src="http://oss.interviewguide.cn/img/202205220021689.png" alt=""><br>堆往上堆，高地址堆，栈往下打，两个中间是未使用区<br>栈：由编译器管理分配和回收，存放局部变⾥和函数参数。<br>堆：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲<br>碎⽚的情况。<br>全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0<br>常量存储区：存储常量，⼀般不允许修改。如const修饰的全局变量、字符串常量等<br>代码区：存放程序的⼆进制代码</p>
<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>static 作⽤：控制变⾨的存储⽅式和可⻅性。<br>作⽤⼀：修饰局部变量：⽤ static 关键字修饰的话，该变⾥便会存放在静态数据区，其⽣命周期会⼀直延续到整个程序执⾏结束，但其作⽤域并没有改变，作⽤域还是限制在其语句块。<br>作⽤⼆：修饰全部变量：对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被访问(添加 extern进⾏声明即可)。⽤ static 对全局变⾥进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成了本⽂件可⻅。<br>作⽤三：修饰函数：⽤ static 修饰函数，情况和修饰全局变⾥类似，也是改变了函数的作⽤域。仅在本文件可用<br>作⽤四：修饰类：如果 C++ 中对类中的某个函数⽤ static 修饰，则表示该函数属于⼀个类⽽不是属于此类的任何特定对象；如果对类中的某个变⾥进⾏ static 修饰，则表示该变⾥以及所有的对象所有，存储空间中只存在⼀个副本，可以通过；类和对象去调⽤。<br>静态⾮常⾥数据成员，其<strong>只能在类外定义和初始化，在类内仅是声明⽽已。</strong>且不能被virtual修饰，因为virtual依赖实例调用来实现，也就是this指针，但静态函数没有<br><strong>const 关键字和 static 关键字对于成员函数来说是不能同时使⽤的，因为 static 关键字修饰静态成员函数不含有 this 指针，即不能实例化，const 成员函数⼜必须具体到某⼀个函数。</strong></p>
<h2 id="全局变量和静态变量"><a href="#全局变量和静态变量" class="headerlink" title="全局变量和静态变量"></a>全局变量和静态变量</h2><p>C++中的全局变量和静态变量有以下区别：</p>
<ol>
<li><p>作用域：</p>
<ul>
<li>全局变量：全局变量在整个程序中都是可见的，可以在任何函数内部访问和使用。</li>
<li>静态变量：静态变量的作用域限制在其定义所在的函数或文件内，只能在其定义所在的函数或文件内部访问和使用。</li>
</ul>
</li>
<li><p>存储位置和生命周期：</p>
<ul>
<li>全局变量：全局变量在程序运行期间一直存在，存储在静态存储区（全局数据区），在程序启动时进行初始化，直到程序结束时才被销毁。</li>
<li>静态变量：静态变量在程序执行流程中也一直存在，存储在静态存储区，但其生命周期仅限于其定义所在的函数或文件的生命周期。静态变量在首次使用时初始化，并在程序结束时销毁。</li>
</ul>
</li>
<li><p>初始化：</p>
<ul>
<li>全局变量：全局变量可以在定义时进行初始化，如果没有显式初始化，则会被默认初始化为对应类型的零值。</li>
<li>静态变量：静态变量可以在定义时进行初始化，如果没有显式初始化，则会被默认初始化为对应类型的零值。静态变量只会被初始化一次，在其定义所在的函数或文件第一次执行时进行初始化。</li>
</ul>
</li>
<li><p>可见性：</p>
<ul>
<li>全局变量：全局变量在整个程序中都是可见的，可以被其他文件中的函数访问，需要使用<code>extern</code>关键字进行声明。</li>
<li>静态变量：静态变量的可见性仅限于其定义所在的函数或文件内部，无法被其他文件中的函数直接访问，只能在其定义所在的函数或文件内部使用。</li>
</ul>
</li>
<li><p>多次定义：</p>
<ul>
<li>全局变量：全局变量可以在不同的文件中定义多次，但是这会导致多个定义之间的链接错误。</li>
<li>静态变量：静态变量在其定义所在的函数或文件内部是唯一的，不会出现多次定义的情况。</li>
</ul>
</li>
</ol>
<p>总之，全局变量具有整个程序可见的特性，而静态变量具有更小的作用域和可见性，并且仅在其定义所在的函数或文件内部可见。全局变量的生命周期和作用域更长，而静态变量的生命周期仅限于其定义所在的函数或文件。</p>
<h2 id="常量的存储"><a href="#常量的存储" class="headerlink" title="常量的存储"></a>常量的存储</h2><p>在C++中，常量有两种形式：编译时常量（Compile-time constants）和运行时常量（Run-time constants）。</p>
<ol>
<li><p>编译时常量：</p>
<ul>
<li>整型常量、浮点型常量、字符常量等编译时可以确定并被替换的常量，被视为编译时常量。</li>
<li>编译时常量通常直接嵌入到生成的机器代码中，不占用运行时内存。</li>
</ul>
</li>
<li><p>运行时常量：</p>
<ul>
<li>运行时常量是在程序运行时确定的常量，例如使用<code>const</code>关键字定义的常量变量。</li>
<li>运行时常量存储在程序运行时的内存中，其具体存储位置取决于其作用域和声明方式。</li>
</ul>
</li>
</ol>
<p>在内存中，运行时常量可能存储在以下几个区域：</p>
<ol>
<li><p>栈（Stack）：</p>
<ul>
<li>函数内的局部常量变量通常存储在栈上。</li>
<li>栈上的常量在函数调用结束后自动销毁。</li>
</ul>
</li>
<li><p>静态存储区（Static storage area）：</p>
<ul>
<li>全局常量和静态常量（通过<code>static</code>关键字修饰的静态变量）存储在静态存储区。</li>
<li>静态存储区的常量在整个程序的生命周期内都存在，直到程序结束才会被销毁。</li>
</ul>
</li>
<li><p>文字常量区（Text/Code segment）：</p>
<ul>
<li>字符串常量（例如<code>&quot;Hello, world!&quot;</code>）通常存储在文字常量区。</li>
<li>文字常量区存储了程序中的只读数据，其内容在程序运行时是不能修改的。</li>
</ul>
</li>
</ol>
<p>需要注意的是，具体的内存区域和常量存储方式可能受到编译器和操作系统的影响，不同的平台可能有不同的实现细节。因此，对于常量的具体存储区域，可以参考编译器和操作系统的文档或规范进行了解。</p>
<h2 id="8-重载，重写，重定义（隐藏）"><a href="#8-重载，重写，重定义（隐藏）" class="headerlink" title="8. 重载，重写，重定义（隐藏）"></a>8. 重载，重写，重定义（隐藏）</h2><p>重写是指子类重写父类的虚函数，虚函数不能是静态的，重写函数的修饰符可以从private改为public，要求参数和返回值的类型都一致<br>重定义是指派生类重新定义父类中的非virtual函数， 参数列表或返回值与基类不同，导致基类方法不能使用，或者说被隐藏</p>
<p>重写必须是虚函数，父类中的虚函数可以没有实现<br>子类在继承父类的时候会完全拷贝一份父类的，在访问同名变量的时候会优先访问，<strong>重定义没有必须要求参数列表一样，只要函数名一样就行</strong></p>
<h2 id="10-C-的强制类型转换"><a href="#10-C-的强制类型转换" class="headerlink" title="10.C++的强制类型转换"></a>10.C++的强制类型转换</h2><p>感觉不是很常用，static_cast\dynamic_cast\const_cast\reinterpret_cast<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunjianzhao/p/17445814.html">参考链接</a><br>static_cast：明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换（派⽣类-&gt;基类）安全，下⾏转换（基类-&gt;派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；<br>dynamic_cast：专⻔<strong>⽤于派⽣类之间的转换,不用于基本数据类型</strong>，type-id 必须是类指针，类引⽤或 void<em>，对于下⾏转换是安全的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题。<strong>解决了下行转换的安全问题</strong><br>const_cast：&lt;&gt;里的类型也只能是指针或引用，专⻔⽤于 const 属性的转换，<em>*去除 const 性质，或增加 const 性质</em></em>， 是四个转换符中唯⼀⼀个可以操作常量的转换符。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; num1 = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>&amp;&gt;(num);</span><br></pre></td></tr></table></figure><br>reinterpret_cast：不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏⾦新解释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤之间进⾏肆⽆忌惮的转换</p>
<h2 id="11-引用和指针"><a href="#11-引用和指针" class="headerlink" title="11.引用和指针"></a>11.引用和指针</h2><p>引用只是个别名，指针是一个实体<br><strong>引用只能在定义的时候进行绑定且不能更改，引用必须初始化</strong>，sizeof对于引用，得到绑定变量的大小，而对于指针得到的是指针的大小，64位机指针变量是8字节</p>
<p>指针和引⽤都是⼀种内存地址的概念，区别呢，指针是⼀个实体，引⽤只是⼀个别名。<br>在程序编译的时候，将指针和引⽤添加到符号表中。<br>指针它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将<strong>指针变⾥名-指针变量的地址</strong>添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有 const 和⾮ const 区别，甚⾄可以为空，sizeof 指针得到的是指针类型的⼤⼩。<br>⽽对于引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将<strong>引⽤变⾥名-引⽤对象的地址</strong>添加到符号表中，<strong>符号表⼀经完成不能改变</strong>，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和⾮ const 区别。<br>sizeof 引⽤得到代表对象的⼤⼩。⽽ sizeof 指针得到的是指针本身的⼤⼩。另外在参数传递中，指针需要被解引⽤后才可以对对象进⾏操作，⽽直接对引⽤进⾏的修改会直接作⽤到引⽤对象上。作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引⽤的实质是传地址，传递的是变⾥的地址</p>
<h2 id="12-野指针和悬空指针"><a href="#12-野指针和悬空指针" class="headerlink" title="12.野指针和悬空指针"></a>12.野指针和悬空指针</h2><p>野指针是指没有初始化的指针，悬空指针是指指向内存被释放了的指针，两者都不安全，避免野指针，就记得初始化</p>
<h2 id="13-const修饰指针-常量指针和指针常量，顶层const"><a href="#13-const修饰指针-常量指针和指针常量，顶层const" class="headerlink" title="13. const修饰指针 常量指针和指针常量，顶层const"></a>13. const修饰指针 常量指针和指针常量，顶层const</h2><p>顶层 const 是可以来表示任意的常量对象，包括算术类型、类、指针等。<br>底层 const 则与指针和引用等复合类型的基本类型部分有关，但对于指针来说，<strong>顶层 const（top-level const）用来描述指针常量本身，底层（low-level）用来描述指针所指向的对象。</strong><br>即简单类型都是顶层，只有指针和引用的时候区分，指向常量的指针这个是底层，描述指针指向的内容，而指针本身是常量（也就是指针常量）这里是顶层<br>即顶层是本身，底层是指向的那个东西<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;  <span class="comment">//这是一个顶层const，基于顶层const定义+“顶层 const 可以表示任意的对象是常量”</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci; <span class="comment">//这是一个底层const,指向的东西是常量，底层</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2; <span class="comment">//靠右的是顶层，靠右的是说指针本身是常量，本身所以是顶层，靠左的是底层</span></span><br><span class="line"></span><br><span class="line">i = ci; <span class="comment">//正确，ci是一个顶层，只需要考虑它本身和i类型是否对的上</span></span><br><span class="line">p2 = p3; <span class="comment">//正确，对于底层部分，考虑它们所指的对象，p2指向常量，p3指向常量。对于顶层部分，p3是顶层，所以不影响。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = p3; <span class="comment">//错误，底层部分，p3有底层而p没有，p3指向常量，p指向非常量，那么程序可以试图通过p去改变一个常量，所以是错误的。</span></span><br><span class="line"><span class="comment">//不能把常量赋给非常量</span></span><br><span class="line">p2 = p3； <span class="comment">//正确, 两个都是底层，即指向的都是常量。</span></span><br><span class="line">p2 = &amp;i; <span class="comment">//正确，底层部分：p2指向常量，但是int i是可以转换成常量的。</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = ci; <span class="comment">//错误，因为非常量的引用r会试图改变常量ci的值。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 =i; <span class="comment">//正确，用于声明引用的都是底层const，int i可以转换成常量。</span></span><br></pre></td></tr></table></figure></p>
<p>常量指针，指针指向常量，不可以通过指针修改，但是这个变量可以修改，只是说不能通过指针修改<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* ptr = &amp;x;  <span class="comment">// ptr是一个常量指针，指向一个整型常量</span></span><br><span class="line">*ptr = <span class="number">7</span>;  <span class="comment">// 错误，不能通过常量指针修改所指向的内容</span></span><br><span class="line">ptr = &amp;y;  <span class="comment">// 正确，可以修改常量指针的值，使其指向另一个变量</span></span><br></pre></td></tr></table></figure></p>
<p>指针常量的指向不可修改，但是指向的内容可以通过该指针修改<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> ptr = &amp;x;  <span class="comment">// ptr是一个指针常量，指向一个整型变量</span></span><br><span class="line">*ptr = <span class="number">7</span>;  <span class="comment">// 可以通过指针常量修改所指向的内容</span></span><br><span class="line">ptr = &amp;y;  <span class="comment">// 错误，不能修改指针常量的值，即不能使其指向其他内存位置</span></span><br></pre></td></tr></table></figure></p>
<h2 id="14-函数指针"><a href="#14-函数指针" class="headerlink" title="14. 函数指针"></a>14. 函数指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>  <span class="title">fun</span>   <span class="params">(<span class="keyword">char</span> *p)</span><span class="comment">//函数fun的返回值是char 类型</span></span></span><br><span class="line"><span class="function"><span class="title">char</span>  <span class="params">(*pf)</span> <span class="params">(<span class="keyword">char</span> *p)</span><span class="comment">//用(*pf)代替函数名fun,pf就是一个函数指针，一定记得带括号</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>  *<span class="title">pf1</span>   <span class="params">(<span class="keyword">char</span> *p)</span><span class="comment">//不带括号的话，就会认为pf1是一个函数，返回值是char*类型</span></span></span><br><span class="line"><span class="function">pf </span>= fun;<span class="comment">//函数指针pf指向函数fun,第二行只是一个定义，此时函数指针并没有指向一个具体的函数，这一行才是定义</span></span><br><span class="line"><span class="built_in">pf</span>(p);<span class="comment">//可以用pf调用函数fun</span></span><br></pre></td></tr></table></figure>
<h2 id="15-堆和栈"><a href="#15-堆和栈" class="headerlink" title="15.堆和栈"></a>15.堆和栈</h2><p>栈存放局部变量，由编译器管理，注意栈是从高地址向低地址扩展，堆由程序员自己申请，堆是不连续的，实际上系统中有⼀个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存⼤⼩，⽅便 delete 回收空间⼤⼩。<br>补充：栈是连续的内存空间，堆是不连续的，函数调用的时候默认是从右到左如栈的，这样最左边的参数位于栈顶，可以最早出来，也就是和函数定义是一样的</p>
<p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/1853618-a0bbe79ab4a86345.webp" alt=""></p>
<blockquote>
<p>补充：malloc是如何分配内存的</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/os/3_memory/malloc.html#linux-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7">malloc的小林回答</a><br>malloc() 源码里默认定义了一个阈值：<br>如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；直接在堆底申请<br>如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；在文件映射区拿一块内存<br>malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；<br>malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。</p>
<p>由于malloc需要执行系统调用，所以一般只有在申请内存较大的时候调用，不然很慢，brk调用不需要系统调用，但是如果都用brk的话，上述说过在delete后不会立马归还操作系统，所以如果大的空间也用brk的话，会很浪费，因为用完不还。</p>
<h2 id="16-函数传递参数"><a href="#16-函数传递参数" class="headerlink" title="16.函数传递参数"></a>16.函数传递参数</h2><p>值传递：形参是实参的拷⻉，函数内部对形参的操作并不会影响到外部的实参。<br>指针传递：<strong>也是值传递的⼀种⽅式</strong>，形参是指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进⾏操作。<br>引⽤传递：实际上就是把引⽤对象的地址放在了开辟的栈空间中，函数内部对形参的任何操作可以直接映射到外部的实参上⾯。</p>
<h2 id="17-new-delete"><a href="#17-new-delete" class="headerlink" title="17.new/delete"></a>17.new/delete</h2><p>new /delete 是操作符，malloc/free 是库函数。</p>
<ol>
<li>new自动计算要分配的空间大小，malloc需要手工计算，malloc和free返回的是void类型指针（必须进行类型转换）</li>
<li>new是类型安全的，malloc不是。比如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">2</span>]; <span class="comment">//编译错误,因为前后的类型不一样</span></span><br><span class="line"><span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">2</span> * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">double</span>));<span class="comment">//编译无错误</span></span><br></pre></td></tr></table></figure></li>
<li>new调用名为operator new的标准库函数分配足够空间并<strong>调用相关对象的构造函数</strong>，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用</li>
<li>后者需要库文件支持，前者不用，new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象</li>
</ol>
<p>执⾏ new 实际上执⾏两个过程：</p>
<ol>
<li>分配未初始化的内存空间（malloc）；</li>
<li>使⽤对象的构造函数对空间进⾏初始化；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处理函数捕获处理；如果在第⼆步构造对象时出现异常，则⾃动调⽤ delete 释放内存。<br>执⾏ delete 实际上也有两个过程：</li>
<li>使⽤析构函数对对象进⾏析构；</li>
<li>回收内存空间（free）。</li>
</ol>
<p>为什么有了 malloc／free 还需要 new／delete？<br>因为对于⾮内部数据类型⽽⾔，光⽤ malloc／free ⽆法满⾜动态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。由于 mallo／free 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务强加于malloc／free，所以有了 new／delete 操作符。</p>
<h2 id="18-extern-volatile"><a href="#18-extern-volatile" class="headerlink" title="18. extern/volatile"></a>18. extern/volatile</h2><p>在 C 语⾔中，修饰符 extern ⽤在变量或者函数的声明前，⽤来说明 “此变量/函数是在别处定义的，要在此处引⽤”。<br>注意 extern 声明的位置对其作⽤域也有关系，如果是在 <strong>main 函数中进⾏声明的，则只能在 main 函数中调⽤</strong>，在其它函数中不能调⽤。所以如果main函数中想用全局变量，需要把变量定义在main(){}外，这样就是全局变量<br>其实要调⽤其它⽂件中的函数和变量，只需把该⽂件⽤ #include 包含进来即可，为啥要⽤extern？因为⽤ extern 会加速程序的编译过程，这样能节省时间。</p>
<p>volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。<strong>如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值</strong>，如果这个变量由别的程序更新了的话，将出现不一致的现象</p>
<h2 id="19-define-const"><a href="#19-define-const" class="headerlink" title="19.define/const"></a>19.define/const</h2><p>对于 define 来说，宏定义实际上是在<strong>预编译阶段进⾏处理，没有类型，也就没有类型检查</strong>，仅仅做的是遇到宏定义进⾏字符串的展开，遇到多少次就展开多少次，⽽且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。<br>对于 const 来说，const 是在<strong>编译期间进⾏处理的，const 有类型，也有类型检查</strong>，程序运⾏时系统会为 const 常量分配内存，⽽且从汇编的⻆度讲，const 常量在出现的地⽅保留的是真正数据的内存地址，只保留了⼀份数据的拷⻉，省去了不必要的内存空间。⽽且，有时编译器不会为普通的 const 常量分配内存，⽽是直接将 const 常量添加到符号表中，省去了读取和写⼊内存的操作，效率更⾼。</p>
<h2 id="20-类的大小"><a href="#20-类的大小" class="headerlink" title="20.类的大小"></a>20.类的大小</h2><p>计算下⾯⼏个类的⼤⼩<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;; <span class="built_in"><span class="keyword">sizeof</span></span>(A) = <span class="number">1</span>; <span class="comment">//空类在实例化时得到⼀个独⼀⽆⼆的地址，所以为 1. </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="function"><span class="keyword">virtual</span> <span class="title">Fun</span><span class="params">()</span></span>&#123;&#125; &#125;; <span class="built_in"><span class="keyword">sizeof</span></span>(A) = <span class="number">4</span>(<span class="number">32b</span>it)/<span class="number">8</span>(<span class="number">64b</span>it) <span class="comment">//当 C++ 类中有虚函数的时候，会有⼀个指向虚函数表的指针（vptr）</span></span><br><span class="line">class A&#123;<span class="keyword">static</span> <span class="keyword">int</span> a; &#125;; <span class="built_in"><span class="keyword">sizeof</span></span>(A) = <span class="number">1</span>; <span class="comment">//静态变量不占大小</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">int</span> a; &#125;; <span class="built_in"><span class="keyword">sizeof</span></span>(A) = <span class="number">4</span>; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span><span class="keyword">static</span> <span class="keyword">int</span> a; <span class="keyword">int</span> b; &#125;; <span class="built_in"><span class="keyword">sizeof</span></span>(A) = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="21-封装继承和多态"><a href="#21-封装继承和多态" class="headerlink" title="21.封装继承和多态"></a>21.封装继承和多态</h2><p>继承的实现方式有两种：实现继承和接口继承，实现继承直接使用基类的属性和方法，接口继承仅使用属性和方法的名称，子类需要提供具体实现<br>多态：多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。<br>如果函数的调⽤，在编译器编译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。<br>⽽如果函数调⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。</p>
<h2 id="22-多态的实现"><a href="#22-多态的实现" class="headerlink" title="22.多态的实现"></a>22.多态的实现</h2><p>多态可以分为静态多态（函数重载，编译时就确定了调用哪个函数）和动态多态（继承+虚函数）<br>⼦类继承⽗类时， ⽗类的纯虚函数<strong>必须重写，否则⼦类也是⼀个虚类不可实例化。</strong> 定义纯虚函数是为了实现⼀个接⼝，起到⼀个规范的作⽤，规范继承这个类的程序员必须实现这个函数。<br><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/sqpwQpPYBFkPWCmccruvNw">虚函数大小问题</a><br>如果只是继承自一个类，那么大小就是一个指针的大小，32位就是4字节，如果继承自两个类，大小就是两个指针的大小，而且派生类自己的虚函数，会跟在第一个基类的虚函数后面</p>
<h2 id="23-26-虚函数相关"><a href="#23-26-虚函数相关" class="headerlink" title="23-26.虚函数相关"></a>23-26.虚函数相关</h2><blockquote>
<p>为什么构造函数不能是虚函数以及为什么析构函数要是虚函数</p>
</blockquote>
<p>虚函数表是在实例化完对象才有的，所以如果构造函数是虚函数，首先就需要有个虚函数表，但是还没有实例化，所以不能是虚函数，<strong>先实例化后调用准则</strong><br>构造对象时需要知道对象的实际类型，而虚函数行为是在运行期间才能确定实际类型的，由于对象还未构造成功，编译器无法知道对象的实际类型，俨然是个鸡和蛋的问题。<br>如果构造函数是虚函数，那么构造函数的执行将依赖虚函数表，而虚函数表又是在构造函数中初始化的，而在构造对象期间，虚函数表又还没有被初始化，又是个死循环问题。<br>总结：这块有点绕，从编译器的角度去看，构造函数就是为了在编译阶段确定对象类型、分配空间等工作，虚函数为了实现动态多态需要在运行期间才能确定具体的行为，显然构造函数不可能同时具备静态特性和动态特性。</p>
<blockquote>
<p>为什么析构函数要定义为虚函数，每个派生类有自己的数据呗，不定义为虚的，都调基类，会内存泄露</p>
</blockquote>
<p>是为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，⽤基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的⾃身内容将⽆法被析构，造成内存泄漏。如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函数，再执⾏基类的析构函数，成功释放内存</p>
<blockquote>
<p>补充：虚继承解决菱形继承问题</p>
</blockquote>
<p>菱形继承的二义性，BC继承自A，D继承自BC，那么D会有两份A的拷贝，分别来自BC<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_61857742/article/details/127344922">虚继承</a></p>
<h2 id="27-构造函数或析构函数中调⽤虚函数会怎样"><a href="#27-构造函数或析构函数中调⽤虚函数会怎样" class="headerlink" title="27.构造函数或析构函数中调⽤虚函数会怎样"></a>27.构造函数或析构函数中调⽤虚函数会怎样</h2><p>举例来说就是，有⼀个动物的基类，基类中定义了⼀个动物本身⾏为的虚函数 action_type()，在<strong>基类的构造函数中调⽤了这个虚函数</strong>。派⽣类中重写了这个虚函数，我们期望着根据对象的真实类型不同，⽽调⽤各⾃实现的虚函数，但<strong>实际上当我们创建⼀个派⽣类对象时，⾸先会创建派⽣类的基类部分，执⾏基类的构造函数，此时，派⽣类的⾃身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当它们还不存在作为⼀种安全的⽅法。</strong><br>也就是说构造派⽣类的基类部分是，编译器会认为这就是⼀个基类类型的对象，然后调⽤基类类型中的虚函数实现，并没有按照我们想要的⽅式进⾏。即对象在派⽣类构造函数执⾏前并不会成为⼀个派⽣类对象。<br>也就是说，<strong>在构造函数中调用虚函数，还是会执行基类的虚函数，并没有达到多态的目的</strong>同理，派⽣类执⾏了析构函数后，派⽣类的⾃身成员呈现未定义的状态，那么在执⾏基类的析构函数中是不可能调⽤到派⽣类⾦写的⽅法的</p>
<h2 id="28-析构函数"><a href="#28-析构函数" class="headerlink" title="28. 析构函数"></a>28. 析构函数</h2><p>撤销对象的一些特殊任务处理，释放对象分配的内存等<br>析构函数没有参数和返回值，不能重载，每个类必须有</p>
<h2 id="29-构造顺序"><a href="#29-构造顺序" class="headerlink" title="29.构造顺序"></a>29.构造顺序</h2><p>优先调用基类构造函数，成员类构造函数，再调用派生类构造函数<br><strong>如果有多个基类等，都是按照定义的顺序调用</strong><br>析构相反</p>
<h2 id="补充：继承的实现"><a href="#补充：继承的实现" class="headerlink" title="补充：继承的实现"></a>补充：继承的实现</h2><p>class A : 继承方式 B;</p>
<ol>
<li>private的都不能访问</li>
<li>public继承的话，public/protected权限不变</li>
<li>其他继承方式，所有权限都变成继承方式的权限<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/clip_image002.png" alt=""></li>
</ol>
<p>但是还是会被继承下来，只是访问不到，所以B类的大小不管怎么继承都是12</p>
<ul>
<li>当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</li>
</ul>
<p>访问子类同名成员 直接访问即可<br>访问父类同名成员 需要加作用域<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;</span><br></pre></td></tr></table></figure><br>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数<br>系统并不会判断，比如两个同名函数的参数类型不一样，系统不会帮你选，而是默认调用子类，不匹配就报错，除非加作用域指明用父类的</p>
<h2 id="30-纯虚函数"><a href="#30-纯虚函数" class="headerlink" title="30. 纯虚函数"></a>30. 纯虚函数</h2><p>也就是基类中只定义，并没有实现<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回值类型 函数名（参数表）= <span class="number">0</span></span><br></pre></td></tr></table></figure><br>⽬的就是为了让派⽣类只继承函数的接⼝，⽽且派⽣类中必需提供⼀个这个纯虚函数的实现，否则<strong>含有纯虚函数的类将是抽象类，不能进⾏实例化。</strong></p>
<h2 id="31-静态绑定和动态绑定"><a href="#31-静态绑定和动态绑定" class="headerlink" title="31.静态绑定和动态绑定"></a>31.静态绑定和动态绑定</h2><p>静态绑定是指在编译期间完成绑定，所对应的函数或属性依赖于对象的静态类型<br>动态绑定，发生在运行期间，多指虚函数<br>需要注意的是，缺省值，即fun(a,b=2),类似这种某些变量有默认指，可以通过fun(2),只传一个参数就好，这种叫做缺省参数是静态绑定的，派生类如果修改了基类虚函数的缺省参数会失效，因为缺省参数在编译时就已经绑定了，默认绑定基类，所以要避免</p>
<h2 id="32-深拷贝和浅拷贝"><a href="#32-深拷贝和浅拷贝" class="headerlink" title="32.深拷贝和浅拷贝"></a>32.深拷贝和浅拷贝</h2><p>在没有定义拷贝函数的时候，默认系统会复制每个成员，没有指针的情况下是可行的<br>但是拷贝的时候，有指针，两个指针会指向同一地址，这样会出现野指针，即一个对象析构后，复制的这份对象该指针指向的内容会变为失效地址（野指针），同时，复制后的对象析构时，是对野指针析构会出现内存泄漏或系统崩溃<br>深拷贝会在堆区中另外申请一份空间，解决野指针问题，即复制后的指针指向一个新的地址空间，这个空间的值和原来的一样，只是地址不一样</p>
<h2 id="33-拷贝构造函数调用时机"><a href="#33-拷贝构造函数调用时机" class="headerlink" title="33.拷贝构造函数调用时机"></a>33.拷贝构造函数调用时机</h2><p>对象以值传递的方式传入函数的时候<strong>这也是为什么，力扣刷题写成引用可以缩短时间，因为避免了一次拷贝</strong>拷贝构造一个临时变量压入栈中<br>同样，值传递方式的返回值也会是一个拷贝构造的临时对象<br>一个对象通过另一个对象进行初始化</p>
<h2 id="34-拷贝构造必须是引用传递，不然会递归调用，无限递归，值传递会自己调自己"><a href="#34-拷贝构造必须是引用传递，不然会递归调用，无限递归，值传递会自己调自己" class="headerlink" title="34.拷贝构造必须是引用传递，不然会递归调用，无限递归，值传递会自己调自己"></a>34.拷贝构造必须是引用传递，不然会递归调用，无限递归，值传递会自己调自己</h2><h2 id="35-结构体内存对齐"><a href="#35-结构体内存对齐" class="headerlink" title="35.结构体内存对齐"></a>35.结构体内存对齐</h2><p>主要是为了提升访问速度，因为CPU都是一块一块读取的，如果先有一个char占0索引，int占1-4索引<br>CPU要先读0-3，再读4-7，然后删除0，5-7，效率很低</p>
<h2 id="36-内存泄漏：申请的内存没有释放"><a href="#36-内存泄漏：申请的内存没有释放" class="headerlink" title="36.内存泄漏：申请的内存没有释放"></a>36.内存泄漏：申请的内存没有释放</h2><p>LINUX：swap命令</p>
<h2 id="37-平衡二叉树。高度平衡二叉树"><a href="#37-平衡二叉树。高度平衡二叉树" class="headerlink" title="37.平衡二叉树。高度平衡二叉树"></a>37.平衡二叉树。高度平衡二叉树</h2><p>红黑树：（C++中的</p>
<ol>
<li>每个节点是红/黑</li>
<li>底层的叶子节点，也就是NULL都是黑的</li>
<li>根节点是黑的</li>
<li>每个红色节点的两个子节点一定是黑的</li>
<li>任意一个节点到每个叶子节点的路径都包含相同数量的黑色节点</li>
</ol>
<p><strong>map,multimap是红黑树，unordered_map是哈希表，set同理</strong><br>红黑树额增删查时间复杂度都是lonN,哈希表是1，但是哈希表一旦需要扩容，将耗费很长时间<br>两者只是底层的实现不一样，但是对外的接口都是类似的</p>
<p>hashmap有unordered_map，map其实就是很明确的红黑树。map比起unordered_map的优势主要有：</p>
<ol>
<li><p>map始终保证遍历的时候是按key的大小顺序的，这是一个主要的功能上的差异。（有序无序）</p>
</li>
<li><p>时间复杂度上，红黑树的插入删除查找性能都是O(logN)而哈希表的插入删除查找性能理论上都是O(1)，他是相对于稳定的，最差情况下都是高效的。哈希表的插入删除操作的理论上时间复杂度是常数时间的，<strong>这有个前提就是哈希表不发生数据碰撞。在发生碰撞的最坏的情况下，哈希表的插入和删除时间复杂度最坏能达到O(n)。</strong></p>
</li>
<li><p>map可以做范围查找，而unordered_map不可以。</p>
</li>
<li><p>扩容导致迭代器失效。 map的iterator除非指向元素被删除，否则永远不会失效。unordered_map的iterator在对unordered_map修改时有时会失效。</p>
</li>
</ol>
<h2 id="39-说⼀下-define、const、typedef、inline-使⽤⽅法？"><a href="#39-说⼀下-define、const、typedef、inline-使⽤⽅法？" class="headerlink" title="39.说⼀下 define、const、typedef、inline 使⽤⽅法？"></a>39.说⼀下 define、const、typedef、inline 使⽤⽅法？</h2><ol>
<li>const 与 #define 的区别</li>
</ol>
<ul>
<li>const 定义的变量带类型，⽽ #define 定义的只是个常数不带类型；</li>
<li>define 只在预处理阶段起作⽤，简单的⽂本替换，⽽ const 在编译、链接过程中起作⽤；</li>
<li>define 没有类型检查。⽽const是有数据类型的，是要进⾏判断的，可以避免⼀些低级错误；</li>
<li>define 预处理后，占⽤代码段空间，const 占⽤数据段空间；</li>
<li>const 不能取消定义，⽽ define 可以通过 #undef 取消某个符号的定义，进⾏⾦定义；</li>
<li>define 独特功能，⽐如可以⽤来防⽌⽂件重复引⽤。</li>
</ul>
<ol>
<li><h1 id="define-和别名-typedef-的区别"><a href="#define-和别名-typedef-的区别" class="headerlink" title="define 和别名 typedef 的区别"></a>define 和别名 typedef 的区别</h1></li>
</ol>
<ul>
<li>执⾏时间不同，typedef 在编译阶段有效，typedef 有类型检查的功能；#define 是宏定义，发⽣在预处理阶段，不进⾏类型检查；</li>
<li>功能差异，typedef ⽤来定义类型的别名，定义与平台⽆关的数据类型，与 struct 的结合使⽤等。</li>
<li>作⽤域不同，#define 没有作⽤域的限制，只要是之前预定义过的宏，在以后的程序中都可以使⽤。⽽ typedef 有⾃⼰的作⽤域。</li>
</ul>
<ol>
<li>define 与 inline 的区别</li>
</ol>
<ul>
<li><h1 id="define是关键字，inline是函数；"><a href="#define是关键字，inline是函数；" class="headerlink" title="define是关键字，inline是函数；"></a>define是关键字，inline是函数；</h1></li>
<li>宏定义在预处理阶段进⾏⽂本替换，inline 函数在编译阶段进⾏替换；</li>
<li>inline 函数有类型检查，相⽐宏定义⽐较安全；inline必须和函数定义体放在一起<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">add</span>(a,b)&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="40-C程序从代码到可执行文件的过程："><a href="#40-C程序从代码到可执行文件的过程：" class="headerlink" title="40. C程序从代码到可执行文件的过程："></a>40. C程序从代码到可执行文件的过程：</h2><ol>
<li>预处理，#include文件导入，以及其他的预处理命令—》.i文件</li>
<li>编译，检查语言错误—》.s文件</li>
<li>汇编，生成机器指令—》.o文件</li>
<li>链接，几个不同的相互调用的文件组合在一起—》可执行文件</li>
</ol>
<h2 id="可变参数宏"><a href="#可变参数宏" class="headerlink" title="可变参数宏"></a>可变参数宏</h2><p>va_list类型的args变量来迭代访问可变参数列表。<br>使用va_start宏初始化args，<br>并使用va_arg宏在循环中提取参数的值。<br>va_arg宏的第二个参数是要提取的参数的类型。最后，使用va_end宏结束参数列表的访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printValues</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, format);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*format != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*format == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> value = <span class="built_in">va_arg</span>(args, <span class="keyword">int</span>);</span><br><span class="line">            std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;d&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> value = <span class="built_in">va_arg</span>(args, <span class="keyword">double</span>);</span><br><span class="line">            std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> value = <span class="built_in">va_arg</span>(args, <span class="keyword">int</span>); <span class="comment">// char is promoted to int</span></span><br><span class="line">            std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*format == <span class="string">&#x27;s&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>* value = <span class="built_in">va_arg</span>(args, <span class="keyword">char</span>*);</span><br><span class="line">            std::cout &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ++format;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printValues</span>(<span class="string">&quot;i&quot;</span>, <span class="number">42</span>);               <span class="comment">// 输出: 42</span></span><br><span class="line">    <span class="built_in">printValues</span>(<span class="string">&quot;ids&quot;</span>, <span class="number">1</span>, <span class="number">3.14</span>, <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出: 1, 3.14, Hello</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在示例中，格式字符串”i”表示只有一个整数参数。在函数调用中，我们提供了一个整数参数42，它将被打印出来。<br>另一个示例中的格式字符串”ids”表示整数、双精度浮点数和字符串参数的组合。在函数调用中，我们依次提供了整数1、双精度浮点数3.14和字符串”Hello”，它们将被按顺序打印出来。</p>
<h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><h2 id="空指针nullptr"><a href="#空指针nullptr" class="headerlink" title="空指针nullptr"></a>空指针nullptr</h2><p>nullptr用来代替NULL，其类型为nullptr_t,能够隐式转换为任何指针或成员指针，而在此之前空指针常用0或NULL表示，而0是整形，会导致一些问题<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br></pre></td></tr></table></figure><br>如果被定义为0，会导致调用第一个函数，如果之前声明了char<em> ch = NULL,却被赋值0，总之就是有歧义，有的编译器会定义NULL为（void</em>)0,有的则是int 0;</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; return_type &#123; body &#125;</span><br><span class="line">[capture](parameters)<span class="keyword">mutable</span> -&gt; return_type &#123; body &#125;<span class="comment">//以值传递的方式捕获的变量默认是不可以修改的，加上mutable后就可以修改了，只是说capture的变量</span></span><br><span class="line">[capture](parameters) &#123; body &#125;<span class="comment">//可以通过函数体推导出来返回值类型，所以可以不写</span></span><br><span class="line">capture：指定在Lambda表达式中访问的外部变量。可以通过值捕获、引用捕获或混合捕获方式来捕获变量。[=]表示按值的方式捕获，[=,&amp;a]表示a用引用捕获，其他变量用值捕获，[<span class="keyword">this</span>]成员函数中捕获<span class="keyword">this</span>指针</span><br><span class="line">parameters：Lambda函数的参数列表。</span><br><span class="line">return_type：指定返回值类型，可以省略，根据表达式自动推断。</span><br><span class="line">body：Lambda函数的函数体，可以包含多条语句。</span><br><span class="line"><span class="comment">//实例</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 按值来捕获</span></span><br><span class="line">    <span class="keyword">auto</span> func1 = [a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按值来捕获</span></span><br><span class="line">    <span class="keyword">auto</span> func2 = [=] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按引用来捕获</span></span><br><span class="line">    <span class="keyword">auto</span> func3 = [&amp;a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;;</span><br><span class="line">    <span class="built_in">func3</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按引用来捕获</span></span><br><span class="line">    <span class="keyword">auto</span> func4 = [&amp;] &#123; std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; std::endl; &#125;;</span><br><span class="line">    <span class="built_in">func4</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化列表：</span><br><span class="line"><span class="built_in">Constructor</span>() : <span class="built_in">member1</span>(value1), <span class="built_in">member2</span>(value2), ... &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Lambda表达式相对于传统的函数对象或函数指针有以下几个方面的简洁之处：</p>
<ol>
<li>语法简洁：Lambda表达式的语法相对简短和紧凑，使得代码更易读、更易编写。Lambda表达式的定义直接内联在需要的地方，不需要单独定义函数或函数对象。</li>
<li>捕获上下文变量：Lambda表达式可以通过捕获上下文变量的方式，访问包围它的作用域内的变量。捕获可以通过值捕获或引用捕获实现，使得Lambda表达式更加灵活和方便。</li>
<li>自动类型推断：Lambda表达式可以省略返回值类型的指定，编译器可以根据表达式的返回值自动推断返回类型，减少了代码的冗余。</li>
<li>内联函数：Lambda表达式通常被编译器内联展开，避免了函数调用的开销，提高了执行效率。</li>
<li>便于在算法函数中使用：由于Lambda表达式的简洁性和内联特性，它在使用STL算法函数（如std::for_each、std::sort等）时更加方便，可以直接将Lambda表达式作为算法函数的参数，避免了编写独立的函数对象或函数指针。实例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">Item</span>(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb) : <span class="built_in">a</span>(aa), <span class="built_in">b</span>(bb) &#123;&#125; </span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;Item&gt; vec;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(<span class="number">1</span>, <span class="number">19</span>));</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(<span class="number">10</span>, <span class="number">3</span>));</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(<span class="number">3</span>, <span class="number">7</span>));</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(<span class="number">8</span>, <span class="number">12</span>));</span><br><span class="line">    vec.<span class="built_in">push_back</span>(<span class="built_in">Item</span>(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据Item中成员a升序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">        [] (<span class="keyword">const</span> Item&amp; v1, <span class="keyword">const</span> Item&amp; v2) &#123; <span class="keyword">return</span> v1.a &lt; v2.a; &#125;); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印vec中的item成员</span></span><br><span class="line">    std::for_each(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(),</span><br><span class="line">        [] (<span class="keyword">const</span> Item&amp; item) &#123; std::cout &lt;&lt; item.a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.b &lt;&lt; std::endl; &#125;);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
内联函数：<br>当编译器遇到函数调用语句时，它通常会将当前执行位置保存到堆栈中，跳转到函数的代码位置执行，执行完后再返回到调用点继续执行。这个过程涉及保存和恢复执行现场的开销，特别是在频繁调用的小型函数中，函数调用开销可能成为性能瓶颈。<br>为了避免函数调用的开销，编译器可以选择对函数进行内联展开。内联展开是将函数的代码直接插入到函数调用点处，而不是通过跳转到函数代码的位置执行。这样一来，就省去了函数调用的开销，以及保存和恢复执行现场的开销。</li>
</ol>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><ol>
<li>可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。</li>
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</li>
</ol>
<blockquote>
<p>值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误，不能引用右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = <span class="number">10</span>;<span class="comment">//允许常量左值引用右值，但是常量左值引用就不能对引用值进行修改了</span></span><br><span class="line"><span class="comment">//右值引用可以修改</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;<span class="comment">//输出100</span></span><br></pre></td></tr></table></figure>
<p>这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<h3 id="关于std-move"><a href="#关于std-move" class="headerlink" title="关于std:move"></a>关于std:move</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>; <span class="comment">// a是个左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;ref_a_left = a; <span class="comment">// 左值引用指向左值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a_right = std::<span class="built_in">move</span>(a); <span class="comment">// 通过std::move将左值转化为右值，可以被右值引用指向</span></span><br><span class="line">cout &lt;&lt; a; <span class="comment">// 打印结果：5</span></span><br><span class="line"><span class="comment">//右值引用的本质</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = <span class="number">5</span>;</span><br><span class="line">ref_a = <span class="number">6</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//等同于以下代码：</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;ref_a = std::<span class="built_in">move</span>(temp);</span><br><span class="line">ref_a = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>但事实上<strong>std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换</p>
<blockquote>
<p>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。<br>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。<br>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>右值引用和std::move被广泛用于在STL和自定义类中实现移动语义，<strong>避免拷贝，从而提升程序性能。</strong> 在没有右值引用之前，一个简单的数组类通常实现如下，有构造函数、拷贝构造函数、赋值运算符重载、析构函数等。深拷贝/浅拷贝在此不做讲解。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>(Array&amp; temp_array, <span class="keyword">bool</span> move) &#123;</span><br><span class="line">    data_ = temp_array.data_;</span><br><span class="line">    size_ = temp_array.size_;</span><br><span class="line">    <span class="comment">// 为防止temp_array析构时delete data，提前置空其data_</span></span><br><span class="line">    temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>参数类型Array&amp; temp_array是一个非常量的引用。这意味着该引用只能绑定到非常量的对象，即只能传递非常量的Array对象作为参数。然而，在实际应用中，常常需要传递一个常量的Array对象作为参数进行复制构造。<strong>例如，当你传递一个临时对象或常量对象时，这些对象不能被非常量引用所绑定，因此无法调用上述的复制构造函数。</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 优雅</span></span><br><span class="line">    <span class="built_in">Array</span>(Array&amp;&amp; temp_array) &#123;</span><br><span class="line">        data_ = temp_array.data_;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        <span class="comment">// 为防止temp_array析构时delete data，提前置空其data_      </span></span><br><span class="line">        temp_array.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> *data_;</span><br><span class="line">    <span class="keyword">int</span> size_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 例1：Array用法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array a;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 做一些操作</span></span><br><span class="line">    .....</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 左值a，用std::move转化为右值</span></span><br><span class="line">    <span class="function">Array <span class="title">b</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>例2：std::vector和std::string的实际例子<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;aacasxs&quot;</span>;</span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.<span class="built_in">push_back</span>(str1); <span class="comment">// 传统方法，copy</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(str1)); <span class="comment">// emplace_back效果相同，str1会失去原有值</span></span><br><span class="line">    vec.<span class="built_in">emplace_back</span>(<span class="string">&quot;axcsddcas&quot;</span>); <span class="comment">// 当然可以直接接右值</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// std::vector方法定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(<span class="keyword">const</span> value_type&amp; val)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span> <span class="params">(value_type&amp;&amp; val)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span> <span class="params">(Args&amp;&amp;... args)</span></span>;</span><br><span class="line"><span class="comment">//emplace_back通过右值引用，避免了拷贝</span></span><br></pre></td></tr></table></figure><br><code>emplace_back</code>和<code>push_back</code>都是向容器的末尾添加元素的方法，但它们在实现和使用上有一些区别。</p>
</blockquote>
<ol>
<li><p>参数类型：</p>
<ul>
<li><code>emplace_back</code>接受可变数量的参数作为构造函数的参数，用于在容器的末尾直接构造一个新元素。，如</li>
<li><p>people.emplace_back(“John”, 25);</p>
</li>
<li><p><code>push_back</code>接受一个已存在的对象作为参数，并将该对象的副本（或移动语义）插入到容器的末尾。</p>
</li>
</ul>
</li>
<li><p>构造方式：</p>
<ul>
<li><code>emplace_back</code>在容器的末尾直接就地构造一个新元素，避免了额外的拷贝或移动操作。</li>
<li><code>push_back</code>要求对象已经存在，因此需要通过拷贝构造函数或移动构造函数创建一个新的对象，然后将其插入到容器的末尾。</li>
</ul>
</li>
<li><p>性能：</p>
<ul>
<li><code>emplace_back</code>通常比<code>push_back</code>更高效，因为它直接在容器中就地构造新元素，减少了额外的拷贝或移动操作。</li>
<li><code>push_back</code>需要先创建一个对象，然后再插入到容器中，可能会涉及对象的拷贝构造或移动构造，因此在性能上可能略逊于<code>emplace_back</code>。</li>
</ul>
</li>
</ol>
<p>综上所述，如果你想直接在容器的末尾构造一个新元素，并且不希望进行额外的拷贝或移动操作，推荐使用<code>emplace_back</code>。如果你已经有一个已存在的对象，并希望将其插入到容器的末尾，可以使用<code>push_back</code>。</p>
<p> 因此，可移动对象<strong>需要拷贝且被拷贝者之后不再被需要</strong>的场景，建议使用std::move触发移动语义，提升性能<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">moveable_objecta = moveable_objectb; </span><br><span class="line">改为： </span><br><span class="line">moveable_objecta = std::<span class="built_in">move</span>(moveable_objectb);</span><br><span class="line"><span class="comment">//C++智能指针</span></span><br><span class="line">std::unique_ptr&lt;A&gt; ptr_a = std::make_unique&lt;A&gt;();</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;A&gt; ptr_b = std::<span class="built_in">move</span>(ptr_a); <span class="comment">// unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型</span></span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;A&gt; ptr_b = ptr_a; <span class="comment">// 编译不通过</span></span><br></pre></td></tr></table></figure><br><strong>std::move本身只做类型转换，对性能无影响。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。</strong></p>
<h2 id="关于完美转发"><a href="#关于完美转发" class="headerlink" title="关于完美转发"></a>关于完美转发</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue ref&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T &amp;&amp; t)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue ref&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testForward</span><span class="params">(T &amp;&amp; v)</span></span>&#123; </span><br><span class="line">    <span class="built_in">print</span>(v);<span class="comment">//v此时已经是个左值了,永远调用左值版本的print</span></span><br><span class="line">    <span class="built_in">print</span>(std::forward&lt;T&gt;(v)); <span class="comment">//本文的重点</span></span><br><span class="line">    <span class="built_in">print</span>(std::<span class="built_in">move</span>(v)); <span class="comment">//永远调用右值版本的print</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;======================&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">testForward</span>(x); <span class="comment">//实参为左值</span></span><br><span class="line">    <span class="built_in">testForward</span>(std::<span class="built_in">move</span>(x)); <span class="comment">//实参为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果<br>Lvalue ref<br>Lvalue ref //完美转发后为左值</p>
<h1 id="Rvalue-ref"><a href="#Rvalue-ref" class="headerlink" title="Rvalue ref"></a>Rvalue ref</h1><p>Lvalue ref<br>Rvalue ref //完美转发后为右值</p>
<h1 id="Rvalue-ref-1"><a href="#Rvalue-ref-1" class="headerlink" title="Rvalue ref"></a>Rvalue ref</h1><p>除了第二行的print(std::forward<T>(v)); 会根据左右值调用外，一三行的函数都是只能调用左或者右<br>可惜的是，在testForward中，虽然参数v是右值类型的，<strong>但此时v在内存中已经有了位置，所以v其实是个左值！</strong>（请仔细阅读这段话，保证你理解了）<br>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/335994370">https://zhuanlan.zhihu.com/p/335994370</a></p>
<p>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值。 这同样也符合第一章对左值，右值的判定方式：其实引用和普通变量是一样的，int &amp;&amp;ref = std::move(a)和 int a = 5没有什么区别，等号左边就是左值，右边就是右值。</p>
<p>完美转发，参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/369203981">https://zhuanlan.zhihu.com/p/369203981</a></p>
<p>主要是右值引用可以避免一次拷贝构造，所以在线程池添加任务的时候，通过了右值引用的方式，同时加上完美转发<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>; 			<span class="comment">// 定义一个加法函数</span></span><br><span class="line"><span class="function">ThreadPool <span class="title">pool</span><span class="params">(<span class="number">8</span>, <span class="number">200</span>)</span></span>; 			<span class="comment">// 创建线程池</span></span><br><span class="line">pool.<span class="built_in">append</span>(std::<span class="built_in">bind</span>(add, <span class="number">1</span>, <span class="number">2</span>)); 	<span class="comment">// 向线程池中添加“任务”</span></span><br><span class="line"></span><br><span class="line">threadpool_-&gt;<span class="built_in">AddTask</span>(std::<span class="built_in">bind</span>(&amp;WebServer::OnRead_, <span class="keyword">this</span>, client)); <span class="comment">//实际代码中调用</span></span><br></pre></td></tr></table></figure></p>
<h2 id="一个进程可以创建多少线程"><a href="#一个进程可以创建多少线程" class="headerlink" title="一个进程可以创建多少线程"></a>一个进程可以创建多少线程</h2><p>32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。<br>64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。</p>
<p>/proc/sys/kernel/threads-max，表示系统支持的最大线程数，默认值是 14553；<br>/proc/sys/kernel/pid_max，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 32768；<br>/proc/sys/vm/max_map_count，表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，具体什么意思我也没搞清楚，反正如果它的值很小，也会导致创建线程失败，默认值是 65530。</p>
<p>echo 99999 &gt; /proc/sys/kernel/threads-max<br>echo “Hello, world!” &gt; output.txt ，表示输出或追加到文件</p>
<p>ulimit -a可以查看进程创建线程时默认分配的栈空间大小，可以通过，如ulimit -s 512将数值调整为512k</p>
<h2 id="上下文切换，内核态和用户态切换的时候也要发生"><a href="#上下文切换，内核态和用户态切换的时候也要发生" class="headerlink" title="上下文切换，内核态和用户态切换的时候也要发生"></a>上下文切换，内核态和用户态切换的时候也要发生</h2><p>CPU 上下文切换就是先把前一个任务的<strong>CPU 上下文（CPU 寄存器和程序计数器</strong>保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p>
<p>系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p>
<p>上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。</p>
<p><strong>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源</strong><br>当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；<br>当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据；</p>
<h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及CPU拷贝的次数。零拷贝实现有多种方式，分别是</p>
<ol>
<li>mmap+write，两个不同的虚拟内存地址可以指向同一物理地址空间，所以将内核空间和用户空间指向同一物理地址</li>
<li>sendfile，内核态完成拷贝，不走用户态，从内核缓冲区直接拷贝至socket缓冲区，然后走网卡发送</li>
<li>带有DMA收集拷贝功能的sendfile，sendfile的升级，跳过socket缓冲区，直接发网卡<br>DMA，英文全称是Direct Memory Access，即直接内存访问。DMA本质上是一块主板上独立的芯片，允许外设设备和内存存储器之间直接进行IO数据传输，其过程不需要CPU的参与。<h1 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h1><h2 id="前置-和后置-的区别："><a href="#前置-和后置-的区别：" class="headerlink" title="前置++和后置++的区别："></a>前置++和后置++的区别：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>,m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line">a = n++;<span class="comment">//后置++</span></span><br><span class="line">b = m--;</span><br><span class="line">c = ++n;<span class="comment">//前置++</span></span><br><span class="line">d = --m;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;<span class="comment">/*输出结果为5，10，7，8。首先对于后置++，可以看到对于a和b是先进行了赋值操作，再进行后置++。执行后a=15,b=10,n=6,m=9。对于前置++，首先进行前置++，再进行赋值操作*/</span></span><br></pre></td></tr></table></figure>
后置++的优先级&gt;前置++的优先级&gt;乘和除的优先级&gt;…&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，！=&gt;赋值运算，优先级和上述性质无关。用优先性解释上述现象有矛盾，所以，可以按照这个记吧</li>
</ol>
<h2 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (a)</span><br><span class="line">(int) a    //两种方式均可</span><br></pre></td></tr></table></figure>
<p>其优先级高于乘数法，和逻辑非，按位取反同级。<br>因此  double(n)/2  是先将n转换为double再做除法</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><blockquote>
<p>双目运算：&amp;&amp; ||<br>单目运算：!</p>
</blockquote>
<p>逻辑！负号-&gt;乘除运算等&gt;&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，!=&gt;逻辑&amp;&amp;&gt;逻辑||。<br>为了避免优先级的混乱，多使用圆括号</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote>
<p>&amp;，|，^(异或)，&lt;&lt;左移,&gt;&gt;右移,~(按位取反)</p>
</blockquote>
<p><strong>按位取反的时候要考虑到数据的字节数，对于一个正数，前面所有的0都要变成1</strong>,左移一位相当于<em>2，右移相当于除2。复合位运算(&amp;=，|=等)的结合顺序是<em>*从右向左</em></em>，除此之外还有(!,~,+,-,前置++/—)也是从右向左结合，比较特殊。</p>
<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><ol>
<li>“=”赋值运算，其结合顺序是从右向左且其左侧(lvalue)不能是表达式，只能是变量，数组等</li>
<li>?:,比如y=(x&gt;=1?1:0)即可表达一个分段函数:y=1(x&gt;=1),y=0(x&lt;1)</li>
<li>逗号表达式，依次计算每个表达式的值，整体等于最后一个逗号后式子的值，如y=(1,2,3+5),则y=8</li>
</ol>
<hr>
<h2 id="算法优先级顺序"><a href="#算法优先级顺序" class="headerlink" title="算法优先级顺序"></a>算法优先级顺序</h2><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220113205502.png" alt=""></p>
<h2 id="数据类型转换原则"><a href="#数据类型转换原则" class="headerlink" title="数据类型转换原则"></a>数据类型转换原则</h2><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220113210115.png" alt=""></p>
<h2 id="整型变量和字符变量"><a href="#整型变量和字符变量" class="headerlink" title="整型变量和字符变量"></a>整型变量和字符变量</h2><p>其在内存中存放的都是整数，整数，存放的是二进制格式，字符，存放的是ASCII码值(<128)，因此可以出现以下形式：
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">a = c+<span class="number">2</span>;<span class="comment">//将字符变量赋给整型变量</span></span><br><span class="line">c = <span class="number">98</span>; <span class="comment">//将整数常量赋给字符变量</span></span><br></pre></td></tr></table></figure><br>上述输出a=67,因为’A’的ASCII码的值为65<br>c = ‘b’,因为’b’的ASCII码的值为98</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>char name[40] = ‘zhang’;<br>转义字符：\r回车，回到本行开头，\n换行，到下一行开头<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;xjtu\nhello&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;xjtu123\rhello&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>执行得：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xjtu</span><br><span class="line">hello</span><br><span class="line">hello23//第二次cout的xjtu1被\r后的hello覆盖</span><br></pre></td></tr></table></figure></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>字符数组和字符串的区别在于，用字符串定义数组时，末尾是’\0’，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220115164804.png" alt=""><br>实例，将单词中的小写字母转换为大写字母：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i]=str[i]<span class="number">-32</span>;<span class="comment">//大小写字母的ASCII码差值为32</span></span><br><span class="line">        i = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>enum &lt;枚举类型名&gt;{枚举常量表}</p>
<h2 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">5</span>];<span class="comment">// 指针数组：数组中的元素是int*类型，p是包含5个int*元素的指针</span></span><br><span class="line"><span class="built_in"><span class="keyword">int</span></span> (*p)[<span class="number">5</span>];<span class="comment">//数组指针：p是一个指针，指向一个int[5]的数组，数组元素为int</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]<span class="comment">//一维数组名的值是数组首元素的地址，仅此而已，其类型还是数组并不是指针，只不过能够自动类型转换成为指针，而对数组取地址 &amp;a的本质则</span></span><br><span class="line">模板类的使用规范</span><br><span class="line">list操作，可以pop_front?</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符和指针"><a href="#字符和指针" class="headerlink" title="字符和指针"></a>字符和指针</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Kallou/article/details/123239999"></a></p>
<p>数组方式：char a[] = “Hello World”;<br>指针方式：const char* s = “HelloWorld”;  const可以忽略<br>接下来详细讲解一下字符串指针</p>
<p>首先，为什么字符串可以直接赋值给指针，即char* s = “HelloWorld”不会报错，不应该是把字符串的地址赋值给指针吗？</p>
<p>原因：这里的双引号做了3件事：</p>
<ol>
<li>申请了空间(在常量区)，存放了字符串 </li>
<li>在字符串尾加上了’/0’    </li>
<li>返回地址</li>
</ol>
<p>字符串指针指向的地址可以修改，但<strong>所指向的字符串内容不能修改</strong>因为字符串常量是不能改变的</p>
<p>注意就是第一种数组定义的方式返回的和第二种不一样，第二种返回的其实是一个常量，即const char,所以在获取HTTP请求的时候改不了里面的值，只有定义成第一种数组类型才可以修改（可恶）<br>然后修改的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> m_url=<span class="built_in">strpbrk</span>(text,<span class="string">&quot; \t&quot;</span>);</span><br><span class="line">*m_url++=<span class="string">&#x27;\0&#x27;</span>;<span class="comment">//这里m_url就是指向空格，这段代码会先执行*m_url=&#x27;\0&#x27;,然后再++</span></span><br></pre></td></tr></table></figure>
<h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><h2 id="剑指Offer01：实现赋值操作"><a href="#剑指Offer01：实现赋值操作" class="headerlink" title="剑指Offer01：实现赋值操作"></a>剑指Offer01：实现赋值操作</h2><p>类对象重载赋值运算符“=”</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="keyword">char</span>* pData = <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">CMyString</span>(<span class="keyword">const</span> CMyString&amp; str);</span><br><span class="line">    ~<span class="built_in">CMyString</span>(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CMyString &amp; CMyString::<span class="keyword">operator</span>=(<span class="keyword">const</span> CmyString &amp;str)<span class="comment">//表示引用</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str) <span class="comment">//表示取址</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">nullptr</span>;</span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData)+<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData,str.m_pData);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="第3章-字符串，向量和数组"><a href="#第3章-字符串，向量和数组" class="headerlink" title="第3章 字符串，向量和数组"></a>第3章 字符串，向量和数组</h1><p>C++11开始用{}来初始化得到了全面的应用<br>使用指定的命名空间 using namespace::name;</p>
<h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><h1 id="include"><a href="#include" class="headerlink" title="include "></a>include <string></h1><p>using std::string<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangjai/article/details/118640873"></a><br><strong>string</strong>类型是不以’\0’结尾的，所以空字符串的 s.size()=0<br>直接初始化：<br>string s1(10,’c’);//连续10个字符c<br>string s2(“hello”);<br>拷贝初始化：<br>string s3 = “hello”;<br>string s4 = string(10,’c’);//通过创建临时对象用于拷贝</p>
<h3 id="string的操作"><a href="#string的操作" class="headerlink" title="string的操作"></a>string的操作</h3><p>+，=，==，！=，大于小于等，但是对大小写敏感<br>s[n].s.size(),s.empty()等<br>getline(is,s)//从is中读取一行赋给s<br>s.size()返回的不是整形，而是string::size_type类型，是无符号类型的值，足够存下任何string对象的大小，所以避免使用==s.size()&lt; n==这种用法，当n为负数时，会被当做一个很大的无符号整数</p>
<p>string相加时，需要保证加号两侧至少有一个string类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1</span><br><span class="line">string s2 = <span class="string">&quot;hello&quot;</span>+<span class="string">&quot;,&quot;</span><span class="comment">//不合法</span></span><br><span class="line">string s3 = s1 + <span class="string">&quot;,&quot;</span> +<span class="string">&quot;world&quot;</span>;<span class="comment">//合法，前面的+号执行后，第二个加号左边是string</span></span><br><span class="line">string s4 =  <span class="string">&quot;,&quot;</span> +<span class="string">&quot;world&quot;</span>+s1;<span class="comment">//不合法,第一个加号左右都不是string</span></span><br></pre></td></tr></table></figure><br><strong>如果要修改string的字符值，需要用引用</strong><br>关于sizeof(string)的说明：<a target="_blank" rel="noopener" href="https://blog.csdn.net/JackZhang_123/article/details/79133571?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-79133571-blog-128205074.pc_relevant_3mothn_strategy_recovery&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-79133571-blog-128205074.pc_relevant_3mothn_strategy_recovery&amp;utm_relevant_index=1"></a><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string s1;</span><br><span class="line">cout&lt;&lt;<span class="built_in"><span class="keyword">sizeof</span></span>(s1)&lt;&lt;endl;<span class="comment">//32,这个好像和编译器有关，不会根据s1的内容改变而改变，所以不能用来确定字符串长度</span></span><br><span class="line"><span class="comment">//char是8位，也就是1字节，所以sizeof(s),s是char返回1</span></span><br><span class="line">cout&lt;&lt;s1.<span class="built_in">size</span>()&lt;&lt;endl;<span class="comment">//0</span></span><br><span class="line">s1 = <span class="string">&quot;12536&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i:s1)&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl; <span class="comment">//12536</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:s1)&#123;</span><br><span class="line">    c++;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;s1&lt;&lt;endl;<span class="comment">//23647,只有引用才会改变原string</span></span><br></pre></td></tr></table></figure></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">KIKI</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/11/C++/">http://example.com/2023/07/11/C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">KIKI's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/C.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="prev-cover" src="https://raw.githubusercontent.com/KIKI9731/image/main/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/offer.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">代码随想录</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/006GMZnVgy1g4jclj8kuvj31400u0dy6.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">KIKI</div><div class="author-info__description">一只努力减脂的KI</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:2498333273@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E7%BB%8F"><span class="toc-number">1.</span> <span class="toc-text">面经</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%89%8BCPP%E5%90%8E%E7%AB%AF"><span class="toc-number">1.1.</span> <span class="toc-text">快手CPP后端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">语言基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">2.1.</span> <span class="toc-text">智能指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5"><span class="toc-number">2.2.</span> <span class="toc-text">C++中内存分配情况</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.3.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">2.4.</span> <span class="toc-text">全局变量和静态变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">2.5.</span> <span class="toc-text">常量的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%87%8D%E8%BD%BD%EF%BC%8C%E9%87%8D%E5%86%99%EF%BC%8C%E9%87%8D%E5%AE%9A%E4%B9%89%EF%BC%88%E9%9A%90%E8%97%8F%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">8. 重载，重写，重定义（隐藏）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-C-%E7%9A%84%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.7.</span> <span class="toc-text">10.C++的强制类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">2.8.</span> <span class="toc-text">11.引用和指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">2.9.</span> <span class="toc-text">12.野指针和悬空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-const%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88-%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%EF%BC%8C%E9%A1%B6%E5%B1%82const"><span class="toc-number">2.10.</span> <span class="toc-text">13. const修饰指针 常量指针和指针常量，顶层const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">2.11.</span> <span class="toc-text">14. 函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%A0%86%E5%92%8C%E6%A0%88"><span class="toc-number">2.12.</span> <span class="toc-text">15.堆和栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">2.13.</span> <span class="toc-text">16.函数传递参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-new-delete"><span class="toc-number">2.14.</span> <span class="toc-text">17.new&#x2F;delete</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-extern-volatile"><span class="toc-number">2.15.</span> <span class="toc-text">18. extern&#x2F;volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-define-const"><span class="toc-number">2.16.</span> <span class="toc-text">19.define&#x2F;const</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E7%B1%BB%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.17.</span> <span class="toc-text">20.类的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%B0%81%E8%A3%85%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">2.18.</span> <span class="toc-text">21.封装继承和多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.19.</span> <span class="toc-text">22.多态的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-26-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="toc-number">2.20.</span> <span class="toc-text">23-26.虚函数相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E2%BD%A4%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-number">2.21.</span> <span class="toc-text">27.构造函数或析构函数中调⽤虚函数会怎样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.22.</span> <span class="toc-text">28. 析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.23.</span> <span class="toc-text">29.构造顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.24.</span> <span class="toc-text">补充：继承的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.25.</span> <span class="toc-text">30. 纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">2.26.</span> <span class="toc-text">31.静态绑定和动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.27.</span> <span class="toc-text">32.深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">2.28.</span> <span class="toc-text">33.拷贝构造函数调用时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%BF%85%E9%A1%BB%E6%98%AF%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%EF%BC%8C%E4%B8%8D%E7%84%B6%E4%BC%9A%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%EF%BC%8C%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92%EF%BC%8C%E5%80%BC%E4%BC%A0%E9%80%92%E4%BC%9A%E8%87%AA%E5%B7%B1%E8%B0%83%E8%87%AA%E5%B7%B1"><span class="toc-number">2.29.</span> <span class="toc-text">34.拷贝构造必须是引用传递，不然会递归调用，无限递归，值传递会自己调自己</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-number">2.30.</span> <span class="toc-text">35.结构体内存对齐</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%EF%BC%9A%E7%94%B3%E8%AF%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B2%A1%E6%9C%89%E9%87%8A%E6%94%BE"><span class="toc-number">2.31.</span> <span class="toc-text">36.内存泄漏：申请的内存没有释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%82%E9%AB%98%E5%BA%A6%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.32.</span> <span class="toc-text">37.平衡二叉树。高度平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-%E8%AF%B4%E2%BC%80%E4%B8%8B-define%E3%80%81const%E3%80%81typedef%E3%80%81inline-%E4%BD%BF%E2%BD%A4%E2%BD%85%E6%B3%95%EF%BC%9F"><span class="toc-number">2.33.</span> <span class="toc-text">39.说⼀下 define、const、typedef、inline 使⽤⽅法？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-%E5%92%8C%E5%88%AB%E5%90%8D-typedef-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">define 和别名 typedef 的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define%E6%98%AF%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8Cinline%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%9B"><span class="toc-number">4.</span> <span class="toc-text">define是关键字，inline是函数；</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#40-C%E7%A8%8B%E5%BA%8F%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%88%B0%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">40. C程序从代码到可执行文件的过程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%AE%8F"><span class="toc-number">4.2.</span> <span class="toc-text">可变参数宏</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">C++11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88nullptr"><span class="toc-number">5.1.</span> <span class="toc-text">空指针nullptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Estd-move"><span class="toc-number">5.3.1.</span> <span class="toc-text">关于std:move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.3.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">5.4.</span> <span class="toc-text">关于完美转发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rvalue-ref"><span class="toc-number">6.</span> <span class="toc-text">Rvalue ref</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Rvalue-ref-1"><span class="toc-number">7.</span> <span class="toc-text">Rvalue ref</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%88%9B%E5%BB%BA%E5%A4%9A%E5%B0%91%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">一个进程可以创建多少线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%8C%E5%86%85%E6%A0%B8%E6%80%81%E5%92%8C%E7%94%A8%E6%88%B7%E6%80%81%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E5%80%99%E4%B9%9F%E8%A6%81%E5%8F%91%E7%94%9F"><span class="toc-number">7.2.</span> <span class="toc-text">上下文切换，内核态和用户态切换的时候也要发生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">7.3.</span> <span class="toc-text">零拷贝</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">8.</span> <span class="toc-text">算术运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE-%E5%92%8C%E5%90%8E%E7%BD%AE-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">前置++和后置++的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">强制类型转换：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">8.3.</span> <span class="toc-text">逻辑运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">8.4.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%AC%A6%E5%8F%B7"><span class="toc-number">8.5.</span> <span class="toc-text">特殊符号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E5%85%88%E7%BA%A7%E9%A1%BA%E5%BA%8F"><span class="toc-number">8.6.</span> <span class="toc-text">算法优先级顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">8.7.</span> <span class="toc-text">数据类型转换原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E5%92%8C%E5%AD%97%E7%AC%A6%E5%8F%98%E9%87%8F"><span class="toc-number">8.8.</span> <span class="toc-text">整型变量和字符变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.9.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">8.10.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.11.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-number">8.12.</span> <span class="toc-text">数组与指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-number">8.13.</span> <span class="toc-text">字符和指针</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">9.</span> <span class="toc-text">重载</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%91%E6%8C%87Offer01%EF%BC%9A%E5%AE%9E%E7%8E%B0%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">9.1.</span> <span class="toc-text">剑指Offer01：实现赋值操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">10.</span> <span class="toc-text">第3章 字符串，向量和数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring"><span class="toc-number">10.1.</span> <span class="toc-text">标准库类型string</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#include"><span class="toc-number">11.</span> <span class="toc-text">include </span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">11.0.1.</span> <span class="toc-text">string的操作</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-07-11T16:00:00.000Z" title="发表于 2023-07-12 00:00:00">2023-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/11/C++/" title="C++学习笔记"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/C.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++学习笔记"/></a><div class="content"><a class="title" href="/2023/07/11/C++/" title="C++学习笔记">C++学习笔记</a><time datetime="2023-07-10T16:00:00.000Z" title="发表于 2023-07-11 00:00:00">2023-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/offer.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码随想录"/></a><div class="content"><a class="title" href="/2023/05/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录">代码随想录</a><time datetime="2023-05-07T16:00:00.000Z" title="发表于 2023-05-08 00:00:00">2023-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/OS/" title="操作系统"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2023/02/27/OS/" title="操作系统">操作系统</a><time datetime="2023-02-26T16:00:00.000Z" title="发表于 2023-02-27 00:00:00">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/" title="Linux项目补充和扩展"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux项目补充和扩展"/></a><div class="content"><a class="title" href="/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/" title="Linux项目补充和扩展">Linux项目补充和扩展</a><time datetime="2023-01-26T16:00:00.000Z" title="发表于 2023-01-27 00:00:00">2023-01-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By KIKI</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>