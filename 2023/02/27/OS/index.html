<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统 | KIKI's Blog</title><meta name="keywords" content="博客"><meta name="author" content="KIKI"><meta name="copyright" content="KIKI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="八股文问题的补充">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2023/02/27/OS/index.html">
<meta property="og:site_name" content="KIKI&#39;s Blog">
<meta property="og:description" content="八股文问题的补充">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg">
<meta property="article:published_time" content="2023-02-26T16:00:00.000Z">
<meta property="article:modified_time" content="2023-10-05T12:23:19.425Z">
<meta property="article:author" content="KIKI">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/27/OS/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-05 20:23:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="KIKI's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/006GMZnVgy1g4jclj8kuvj31400u0dy6.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">KIKI's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-26T16:00:00.000Z" title="发表于 2023-02-27 00:00:00">2023-02-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-05T12:23:19.425Z" title="更新于 2023-10-05 20:23:19">2023-10-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法和数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h1><blockquote>
<p>1、Linux用过吗，常用哪些操作？<br>答：chmod chown useradd groupadd netstat等等</p>
</blockquote>
<p>文件相关(mv mkdir cd ls)</p>
<p>docker相关(docker container ls docker ps -a )</p>
<p>测试相关(测试连通性:ping 测试端口连通性:telnet)</p>
<blockquote>
<ol>
<li>如何查看进程用到的端口？</li>
</ol>
</blockquote>
<p>可以使用以下命令查看进程使用的端口：<br>netstat -tunlp | grep &lt;进程ID&gt;<br>其中，-t 表示 TCP 连接，-u 表示 UDP 连接，-n 表示不进行 DNS 解析，-l 表示只显示监听状态的端口，-p 表示显示进程 ID 和名称。</p>
<blockquote>
<ol>
<li>如何查看当前cpu状态 ？</li>
</ol>
</blockquote>
<p>top命令</p>
<h1 id="问题1：进程线程"><a href="#问题1：进程线程" class="headerlink" title="问题1：进程线程"></a>问题1：进程线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个<strong>运行中的程序，就被称为「进程」（Process）</strong>，代码是静态的。</p>
<p><strong>并行与并发</strong>：但在 1 秒钟期间，它可能会运行多个进程，这样就产生并行的错觉，实际上这是<strong>并发</strong>。并行依赖多CPU<br><strong>进程的状态</strong>：一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/联想截图_20230303111924.png" alt=""><br>为了防止阻塞进程太多，占用内存,在虚拟内存管理的操作系统中，通常<strong>会把阻塞状态的进程的物理内存空间换出到硬盘</strong>，等需要再次运行的时候，再从硬盘换入到物理内存。这个<strong>没有占用实际的物理内存空间的状态就是挂起状态</strong>。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/联想截图_20230303112220.png" alt=""></p>
<p><strong>PCB</strong>是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。<br>通常是通过链表的方式进行组织，把<strong>具有相同状态的进程链在一起，组成各种队列。</strong><br><strong>上下文切换</strong>:CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。<br>所以说，<strong>CPU寄存器和程序计数</strong>是CPU在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。<br>进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。</p>
<blockquote>
<p>发生进程上下文切换有哪些场景？</p>
</blockquote>
<ol>
<li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li>
<li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；</li>
<li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；</li>
</ol>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><blockquote>
<p>为什么需要线程？</p>
</blockquote>
<p>对于播放视频的进程，需要读取文件，解压文件，播放文件等多个工作</p>
<ol>
<li>如果采用单进程的方式，各个函数之间不是并发执行，影响资源的使用效率；</li>
<li>如果采用多进程的方式，维护进程的系统开销较大，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息；</li>
</ol>
<p>为此，引入<strong>线程</strong>( Thread )，线程之间可以<strong>并发运行且共享相同的地址空间。</strong></p>
<h2 id="常见面试题："><a href="#常见面试题：" class="headerlink" title="常见面试题："></a>常见面试题：</h2><blockquote>
<p>进程和线程共享的资源</p>
</blockquote>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。<br>栈是因为不同的线程会有自己的局部变量，寄存器是因为不同的线程在进行上下文切换的时候，需要程序计数器记住执行到哪条指令了，所以线程独享了<strong>寄存器和栈</strong><br>寄存器其中寄存器主要包括SP PC EAX等寄存器，其主要功能如下：<br>SP:堆栈指针，指向当前栈的栈顶地址<br>PC:程序计数器，存储下一条将要执行的指令<br>EAX:累加寄存器，用于加法乘法的缺省寄存器</p>
<blockquote>
<p>进程和线程的区别</p>
</blockquote>
<ol>
<li><p>调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。</p>
</li>
<li><p>并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。</p>
</li>
<li><p>拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。</p>
</li>
<li><p>系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。</p>
</li>
</ol>
<p><strong>线程是调度的基本单位，而进程则是资源拥有的基本单位。</strong> 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃</p>
<blockquote>
<p>一个进程可以创建多少个线程？</p>
</blockquote>
<p>这个问题跟两个东西有关系：</p>
<ol>
<li>进程的虚拟内存空间上限，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。</li>
<li>系统参数限制，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。</li>
</ol>
<p>32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。<br>64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制，比如：</p>
<ol>
<li>表示系统支持的最大线程数，默认值是 14553；</li>
<li>表示系统全局的 PID 号数值的限制，每个进程或线程都有PID号的</li>
</ol>
<blockquote>
<p>进程调度算法<br>这个问题跟两个东西有关系：</p>
<ol>
<li>进程的虚拟内存空间上限，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。</li>
<li>系统参数限制，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。</li>
</ol>
</blockquote>
<p>32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。<br>64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制，比如：</p>
<ol>
<li>表示系统支持的最大线程数，默认值是 14553；</li>
<li>表示系统全局的 PID 号数值的限制，每个进程或线程都有PID号的<br>先来先服务调度算法，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统，短作业等半天<br>最短作业优先调度算法，长作业被饿死<br>高响应比优先调度算法，无法实现，应为需要服务时间未知，计算响应比是（等待时间+要求服务时间）/要求服务时间：所以等的久或者要求服务时间短，都会提高优先级<br>时间片轮转调度算法，最公平，时间设置要合理，太短上下文切换浪费资源，太长退化为先来先服务<br>最高优先级调度算法，低优先级被饿死<br>多级反馈队列调度算法，最合适</li>
</ol>
<p>其中最高优先级：<br>进程的优先级可以分为，静态优先级或动态优先级：</p>
<ul>
<li>静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；</li>
<li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。<br>该算法也有两种处理优先级高的方法，非抢占式和抢占式：</li>
<li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。</li>
<li>抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。</li>
</ul>
<blockquote>
<p>进程间通信方式</p>
</blockquote>
<p>由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。</p>
<ol>
<li>管道：<br><strong>所谓的管道，就是内核里面的一串缓存。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。</strong></li>
</ol>
<p>无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。</p>
<p>有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。</p>
<ol>
<li><p>共享内存：（<strong>两个虚拟地址映射的其实是同一块物理内存</strong>）共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。</p>
</li>
<li><p>消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li><p>套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。</p>
</li>
<li><p>信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。</p>
</li>
<li><p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。</p>
</li>
</ol>
<p>补充：内存映射，mmap函数和unmap函数，将物理位置映射到内存中,有两种方式，一种是匿名映射，即直接在内存中开辟一块区域，用于通信，但只能用于父子进程，另一种是有名映射，将一个磁盘文件映射到内存中，然后多个进程对同一磁盘文件进行修改实现通信，所以需要内存和磁盘文件进行读写，即有IO和数据拷贝等工作，所以效率不如共享内存高，每个进程在自己的虚拟地址空间中有一个独立的内存。</p>
<blockquote>
<p>共享内存和内存映射的区别</p>
</blockquote>
<ol>
<li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li>
<li>共享内存效率更高：共享内存所有的进程操作的是同一块共享内存。<br>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</li>
<li>数据安全：进程突然退出:共享内存还存在,内存映射区消失<br>运行进程的电脑死机，宕机了:数据存在在共享内存中，没有了,内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</li>
<li>生命周期 内存映射区：进程退出，内存映射区销毁<br>共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机<br>如果一个进程退出，会自动和共享内存进行取消关联。</li>
</ol>
<blockquote>
<p>线程通信间的方式呢？</p>
</blockquote>
<p>同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步：</p>
<p>互斥的方式，可保证任意时刻只有一个线程访问共享资源；<br>同步的方式，可保证线程 A 应在线程 B 之前执行；</p>
<h1 id="问题2-内存相关"><a href="#问题2-内存相关" class="headerlink" title="问题2 内存相关"></a>问题2 内存相关</h1><blockquote>
<p>动态分区方法</p>
</blockquote>
<p>就是当有一个新进程到来的时候，决定在内存中的空闲分区中哪一块分给该进程，内存中的空闲块是按链表形式存储的（也有的是表的形式）</p>
<ul>
<li>首次适应算法，从低地址开始查找，第一个大小满足的空闲分区就分出去，（最优也最简单）</li>
<li>最佳适应算法，遍历所有空闲分区，找到满足要求且最小的分区，这样的好处很明显就是为了保留大的分区供大程序用，但是会产生很多特别小且没有办法利用的内部碎片，而且算法开销大</li>
<li>最坏适应算法，与最佳相反，是遍历后取最大的分区给进程，这样避免了特别小的碎片，但是同样就没大空闲区了，而且算法开销也大，因为要遍历，要排序</li>
<li>邻近适应算法，和第一种比，是每次遍历是从上一次的分区开始，而首次适应是从低地址开始，首次适应的话高地址的大片区域会得到保留，但是临近适应的话，高地址的大片分区也可能被分给小进程，就很废</li>
</ul>
<blockquote>
<p>虚拟内存作用</p>
</blockquote>
<p>第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。<strong>这个其实就是体现了虚拟技术的空间虚拟，时间虚拟指的是多个进程的并发，轮流用时间片，宏观上就好像都在同时运行</strong><br>第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。<br>第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</p>
<blockquote>
<p>分段和分页两种方式对比</p>
</blockquote>
<p>分段的两个问题：<br>第一个就是内存碎片的问题。分段的话，每个程序的段其实很大的，有可能会空出来两个128MB,但是由于分段是需要连续的空间，导致256MB的程序装不进来，也就是产生了外部碎片，分段只会有外部碎片，内部没有，但是分页因为固定了每次只分一个页的大小，所以可能有内部碎片<br>第二个就是内存交换的效率低的问题，解决办法就是交换内存，但是段很大的时候效率就很低</p>
<p>分页的话，缺点可能就是页表比较占位置，可以通过多级页表解决</p>
<p>所以现在好多都是两者结合，段页式内存管理实现的方式：<br>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；<br>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；<br>这样，地址结构就由段号、段内页号和页内位移三部分组成。</p>
<blockquote>
<p>虚拟地址和物理地址如何转换</p>
</blockquote>
<p>在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，具体步骤如下：</p>
<ol>
<li>把虚拟内存地址，切分成页号和偏移量；</li>
<li>根据页号，从页表里面，查询对应的物理页号；</li>
<li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li>
</ol>
<p>在分段机制下，依靠段选择因子和段内偏移量：</p>
<p>段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。<br>虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。<br>知道了虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址</p>
<h1 id="问题3-中断和异常"><a href="#问题3-中断和异常" class="headerlink" title="问题3 中断和异常"></a>问题3 中断和异常</h1><blockquote>
<p>外中断和异常有什么区别？</p>
</blockquote>
<p>外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等</p>
<h1 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h1><h2 id="CPU是如何执行程序的"><a href="#CPU是如何执行程序的" class="headerlink" title="CPU是如何执行程序的"></a>CPU是如何执行程序的</h2><p>定义计算机基本结构为 5 个部分，分别是运算器、控制器、存储器、输入设备、输出设备这 5 个部分也被称为冯诺依曼模型。</p>
<p>存储数据的基本单位是字节（byte），1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。</p>
<p>CPU 想要操作「内存地址」就需要「地址总线」：如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，表示地址有32位，因为 2 ^ 32 = 4G</p>
<blockquote>
<p>程序的执行过程</p>
</blockquote>
<p>第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。<br>第二步，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；<br>第三步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；</p>
<p><strong>CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令</strong></p>
<blockquote>
<p>指令执行过程</p>
</blockquote>
<p>CPU 通过程序计数器读取对应内存地址的指令，这个部分称为 Fetch（取得指令）；<br>CPU 对指令进行解码，这个部分称为 Decode（指令译码）；<br>CPU 执行指令，这个部分称为 Execution（执行指令）；<br>CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 Store（数据回写）；<br>上面这 4 个阶段，我们称为指令周期（Instrution Cycle），CPU 的工作就是一个周期接着一个周期，周而复始。</p>
<blockquote>
<p>你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？</p>
</blockquote>
<p>64 位和 32 位软件，实际上代表<strong>指令是 64 位还是 32 位</strong>的：<br>(指令中的每位也都表示了特殊的含义，比如指令类型，操作码等)<br>如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令；<br>操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。</p>
<p><strong>总之，硬件的 64 位和 32 位指的是 CPU 的位宽（指每次可以读多少位的数据，32位机处理64位数字相加，就要分低32位和高32位计算，但是没有这么大的数的运算的时候，64位机也不比32位机快），软件的 64 位和 32 位指的是指令的位宽。</strong></p>
<blockquote>
<p>64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？</p>
</blockquote>
<p>64 位相比 32 位 CPU 的优势主要体现在两个方面：</p>
<p>64 位 CPU 可以一次计算超过 32 位的数字，而 32 位 CPU 如果要计算超过 32 位的数字，要分多步骤进行计算，效率就没那么高，但是大部分应用程序很少会计算那么大的数字，所以<strong>只有运算大数字的时候，64 位 CPU 的优势才能体现出来，否则和 32 位 CPU 的计算性能相差不大。</strong><br>通常来说 64 位 CPU 的地址总线是 48 位，而 32 位 CPU 的地址总线是 32 位，所以 64 位 CPU 可以寻址更大的物理内存空间。如果一个 32 位 CPU 的地址总线是 32 位，那么该 CPU 最大寻址能力是 4G，即使你加了 8G 大小的物理内存，也还是只能寻址到 4G 大小的地址，而如果一个 64 位 CPU 的地址总线是 48 位，那么该 CPU 最大寻址能力是 2^48，远超于 32 位 CPU 最大寻址能力。</p>
<h2 id="2-2存储器"><a href="#2-2存储器" class="headerlink" title="2.2存储器"></a>2.2存储器</h2><ul>
<li>CPU（寄存器，L1/L2/L3Cache）<ol>
<li>CPU 比喻成我们的大脑，大脑正在思考的东西，就好比 CPU 中的寄存器，处理速度是最快的，我们大脑中的记忆，就好比 CPU Cache，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。</li>
<li>CPU Cache 用的是一种叫 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片。SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。，一个 bit 的数据，通常需要 6 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。</li>
</ol>
</li>
<li>内存<br> 内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 DRAM （Dynamic Random Access Memory，动态随机存取存储器） 的芯片。只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。</li>
<li><p>SSD/HDD硬盘<br>SSD（Solid-state disk） 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 10~1000 倍。</p>
<p>机械硬盘（Hard Disk Drive, HDD），它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢 10W 倍左右。</p>
</li>
</ul>
<h2 id="2-3-CPU跑的更快"><a href="#2-3-CPU跑的更快" class="headerlink" title="2.3 CPU跑的更快"></a>2.3 CPU跑的更快</h2><p>写出让 CPU 跑得更快的代码，就需要写出缓存命中率高的代码，CPU L1 Cache 分为数据缓存和指令缓存，因而需要分别提高它们的缓存命中率：</p>
<ul>
<li>对于数据缓存，我们在遍历数据的时候，应该按照内存布局的顺序操作，这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升；</li>
<li>对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率；</li>
<li>对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高线程的缓存命中率，可以考虑把线程绑定 CPU 到某一个 CPU 核心。</li>
</ul>
<h2 id="2-4-何时把cache写会内存"><a href="#2-4-何时把cache写会内存" class="headerlink" title="2.4 何时把cache写会内存"></a>2.4 何时把cache写会内存</h2><ul>
<li>写直达<br>保持内存与 Cache 一致性最简单的方式是，把数据同时写入内存和 Cache 中，这种方法称为写直达（Write Through）。<br>每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。</li>
<li>写回<br>写回机制中，当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中，</li>
</ul>
<p>在把数据写入到 Cache 的时候，只有在缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。</p>
<blockquote>
<p>缓存一致性问题，多核CPU，每个CPU都有自己的cache</p>
<ol>
<li>某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播（Write Propagation）；</li>
<li>某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（Transaction Serialization）。比如两块CPU修改一个变量，按第一条传播的时候，必须有先后顺序，可以依赖锁防止这种情况</li>
</ol>
<p>写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。最常见实现的方式是总线嗅探（Bus Snooping）。</p>
</blockquote>
<p>总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串行化。</p>
<p>于是，有一个协议基于总线嗅探机制实现了事务串行化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性。</p>
<h1 id="2-6-中断"><a href="#2-6-中断" class="headerlink" title="2.6 中断"></a>2.6 中断</h1><p>所以，中断处理程序的上部分和下半部可以理解为：</p>
<ul>
<li>上半部，对应硬中断，由硬件触发中断，用来快速处理中断；</li>
<li>下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；</li>
</ul>
<p>软中断的出现是因为，如果中断处理时间过长，在处理期间，可能无法处理新来的中断，所以分了两个半部，上半部只响应，下半部完成具体的中断业务逻辑<br>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd/CPU 编号」，比如 0 号 CPU 对应的软中断内核线程的名字是 ksoftirqd/0</p>
<h2 id="3-1-操作系统结构"><a href="#3-1-操作系统结构" class="headerlink" title="3.1 操作系统结构"></a>3.1 操作系统结构</h2><blockquote>
<p>操作系统功能</p>
</blockquote>
<ul>
<li>进程调度</li>
<li>内存管理</li>
<li>硬件通信</li>
<li>系统调用</li>
</ul>
<h2 id="4-1-内存分段"><a href="#4-1-内存分段" class="headerlink" title="4.1 内存分段"></a>4.1 内存分段</h2><blockquote>
<p>内存分段</p>
</blockquote>
<p>分段分为堆，栈，代码区和数据段<br><strong>不会产生内部碎片</strong>，因为每次都是要多少分配多少<br>但是会产生外部碎片，因为每次分的时候，要看哪一片连续区域大小够才分，所以会有很多外部碎片，如果外部碎片太多导致无法为新进程分配时，就需要内存交换，即先写入硬盘再移位置，如果文件很大，效率就很低。</p>
<blockquote>
<p>内存分页</p>
</blockquote>
<p>多级页表解决4MB（每个页表项4字节，4GB = 4KB<em>2^20,需要2^20个页,那么4字节</em>2^20 = 4MB，，2^10 = 1024所以2^20 = M）<br>主要是一个二级页表能小很多，把2^20个一级页分成1024个2级页，那么只需要4KB就存下了，然后到时候需要一级页表的时候从硬盘中读就好了<br> 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约<br>序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer）通常称为页表缓存、转址旁路缓存、快表</p>
<blockquote>
<p>虚拟内存的用处</p>
</blockquote>
<ul>
<li>内存更大：第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>进程间隔离： 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li>
<li>读写权限： 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。</li>
</ul>
<p>关注作者<br>80386是32位处理器，物理内存地址空间2^32=4G字节<br>BIOS:基本I/O处理系统<br>DISK：存放OS<br>Bootloader</p>
<h1 id="6-调度算法"><a href="#6-调度算法" class="headerlink" title="6 调度算法"></a>6 调度算法</h1><p>进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。</p>
<blockquote>
<p>什么时候会发生 CPU 调度呢？通常有以下情况：</p>
</blockquote>
<p>当进程从运行状态转到等待状态；<br>当进程从运行状态转到就绪状态；<br>当进程从等待状态转到就绪状态；<br>当进程从运行状态转到终止状态；<br>其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。<br>非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。<br>而抢占式调度，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。</p>
<blockquote>
<p>页面置换算法</p>
</blockquote>
<p>先进先出，</p>
<p>最佳页面置换算法（OPT），未来最长时间不会被使用，理想算法<br>先进先出置换算法（FIFO），没有利用任何额外信息，效果一般，belady现象<br>最近最久未使用的置换算法（LRU），需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。每次都要遍历一遍链表，访问时也要遍历找到该页，再移到链表头，开销大<br>时钟页面置换算法（Lock），还有改进式，优先换出没被修改过的，减少IO写入磁盘次数<br>最不常用置换算法（LFU），LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p>
<h1 id="7-文件系统"><a href="#7-文件系统" class="headerlink" title="7 文件系统"></a>7 文件系统</h1><p>Linux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。</p>
<ul>
<li>索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li>
<li>目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。</li>
</ul>
<p>由于<strong>索引节点唯一标识一个文件，而目录项记录着文件的名字，所以目录项和索引节点的关系是多对一</strong>，也就是说，一个文件可以有多个别名。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p>
<p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p>
<blockquote>
<p>目录项和目录是一个东西吗？</p>
</blockquote>
<p>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</p>
<p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。</p>
<p>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。</p>
<blockquote>
<p>那文件数据是如何存储在磁盘的呢？</p>
</blockquote>
<p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。</p>
<p>所以，文件系统把多个扇区组成了一个逻辑块，<strong>每次读写的最小单位就是逻辑块（数据块）</strong>，Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p>
<blockquote>
<p>虚拟文件系统</p>
<p>文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。</p>
</blockquote>
<p>我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程<strong>维护一个打开文件表，文件表里的每一项代表「文件描述符」，</strong>所以说文件描述符是打开文件的标识。</p>
<blockquote>
<p>操作系统在打开文件表中维护着打开文件的状态和信息：</p>
</blockquote>
<ul>
<li>文件指针：系统跟踪<strong>上次读写位置</strong>作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li>
<li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，<strong>当该计数为 0 时，系统关闭文件，删除该条目；</strong></li>
<li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；</li>
<li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；</li>
</ul>
<blockquote>
<p>文件系统的基本操作单位是数据块</p>
</blockquote>
<p>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。<br>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。</p>
<blockquote>
<p>文件的存储</p>
</blockquote>
<p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：</p>
<ul>
<li>连续空间存放方式<br>读写效率高，但要求文件头里需要指定「起始块的位置」和「长度」，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间<br>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷</li>
<li>非连续空间存放方式<br>分为「链表方式」和「索引方式」<br>隐式链表方式，就是文件分成了几个块，每个块包含了下一块的指针，<br>缺点就是只能按照链表顺序，依次读数据块，同时指针消耗了资源，同时如果指针丢失，会导致文件损坏<br>显式链接,它指把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，查询在内存中进行更快，但是这个链接表不适合大磁盘<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png" alt=""></li>
</ul>
<h2 id="空闲空间管理（有新文件存在哪）"><a href="#空闲空间管理（有新文件存在哪）" class="headerlink" title="空闲空间管理（有新文件存在哪）"></a>空闲空间管理（有新文件存在哪）</h2><ol>
<li>空闲表法，用于上述连续存储，表中记录了空闲连续段的起始位置和大小</li>
<li>空闲链表法，用于非连续存储，空闲空间的链表彼此相连<br>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。</li>
<li>位图法<br>用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。<br>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111110011111110001110110111111100111 ...</span><br></pre></td></tr></table></figure>
在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。</li>
</ol>
<h2 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h2><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p>
<p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p>
<p>硬链接</p>
<p>软链接相当于<strong>重新创建一个文件</strong>，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p>
<p>软链接</p>
<h1 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h1><p>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有</p>
<p>缓冲与非缓冲 I/O<br>直接与非直接 I/O<br>阻塞与非阻塞 I/O VS 同步与异步 I/O<br>接下来，分别对这些分类讨论讨论。</p>
<h1 id="缓冲与非缓冲-I-O"><a href="#缓冲与非缓冲-I-O" class="headerlink" title="缓冲与非缓冲 I/O"></a>缓冲与非缓冲 I/O</h1><p>文件操作的标准库是可以实现数据的缓存，那么根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O：</p>
<p>缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。<br>非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。<br>这里所说的「缓冲」特指标准库内部实现的缓冲。</p>
<p>比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。</p>
<h1 id="直接与非直接-I-O"><a href="#直接与非直接-I-O" class="headerlink" title="直接与非直接 I/O"></a>直接与非直接 I/O</h1><p>我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。</p>
<p>那么，根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O：</p>
<p>直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。<br>非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。<br>如果你在使用文件操作类的系统调用函数时，指定了 O_DIRECT 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">KIKI</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/02/27/OS/">http://example.com/2023/02/27/OS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">KIKI's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/offer.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">代码随想录</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux项目补充和扩展</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/006GMZnVgy1g4jclj8kuvj31400u0dy6.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">KIKI</div><div class="author-info__description">一只努力减脂的KI</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:2498333273@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%9B%B8%E5%85%B3"><span class="toc-number">1.</span> <span class="toc-text">Linux相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%981%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">问题1：进程线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A"><span class="toc-number">2.3.</span> <span class="toc-text">常见面试题：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%982-%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3"><span class="toc-number">3.</span> <span class="toc-text">问题2 内存相关</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%97%AE%E9%A2%983-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">4.</span> <span class="toc-text">问题3 中断和异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84"><span class="toc-number">5.1.</span> <span class="toc-text">CPU是如何执行程序的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">2.2存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-CPU%E8%B7%91%E7%9A%84%E6%9B%B4%E5%BF%AB"><span class="toc-number">5.3.</span> <span class="toc-text">2.3 CPU跑的更快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%BD%95%E6%97%B6%E6%8A%8Acache%E5%86%99%E4%BC%9A%E5%86%85%E5%AD%98"><span class="toc-number">5.4.</span> <span class="toc-text">2.4 何时把cache写会内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-6-%E4%B8%AD%E6%96%AD"><span class="toc-number">6.</span> <span class="toc-text">2.6 中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.</span> <span class="toc-text">3.1 操作系统结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-number">6.2.</span> <span class="toc-text">4.1 内存分段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">6 调度算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">8.</span> <span class="toc-text">7 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%EF%BC%88%E6%9C%89%E6%96%B0%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E5%93%AA%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">空闲空间管理（有新文件存在哪）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">8.2.</span> <span class="toc-text">软硬链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-I-O"><span class="toc-number">9.</span> <span class="toc-text">文件 I&#x2F;O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%86%B2-I-O"><span class="toc-number">10.</span> <span class="toc-text">缓冲与非缓冲 I&#x2F;O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5-I-O"><span class="toc-number">11.</span> <span class="toc-text">直接与非直接 I&#x2F;O</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-07-11T16:00:00.000Z" title="发表于 2023-07-12 00:00:00">2023-07-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/11/C++/" title="C++学习笔记"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/C.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++学习笔记"/></a><div class="content"><a class="title" href="/2023/07/11/C++/" title="C++学习笔记">C++学习笔记</a><time datetime="2023-07-10T16:00:00.000Z" title="发表于 2023-07-11 00:00:00">2023-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/offer.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="代码随想录"/></a><div class="content"><a class="title" href="/2023/05/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/" title="代码随想录">代码随想录</a><time datetime="2023-05-07T16:00:00.000Z" title="发表于 2023-05-08 00:00:00">2023-05-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/OS/" title="操作系统"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2023/02/27/OS/" title="操作系统">操作系统</a><time datetime="2023-02-26T16:00:00.000Z" title="发表于 2023-02-27 00:00:00">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/" title="Linux项目补充和扩展"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux项目补充和扩展"/></a><div class="content"><a class="title" href="/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/" title="Linux项目补充和扩展">Linux项目补充和扩展</a><time datetime="2023-01-26T16:00:00.000Z" title="发表于 2023-01-27 00:00:00">2023-01-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By KIKI</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>