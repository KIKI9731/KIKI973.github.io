<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>操作系统 | KIKI's Blog</title><meta name="keywords" content="博客"><meta name="author" content="KIKI"><meta name="copyright" content="KIKI"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="八股文问题的补充">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://example.com/2023/02/27/OS/index.html">
<meta property="og:site_name" content="KIKI&#39;s Blog">
<meta property="og:description" content="八股文问题的补充">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg">
<meta property="article:published_time" content="2023-02-26T16:00:00.000Z">
<meta property="article:modified_time" content="2023-04-29T02:17:41.311Z">
<meta property="article:author" content="KIKI">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/02/27/OS/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":500},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-04-29 10:17:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="KIKI's Blog" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/006GMZnVgy1g4jclj8kuvj31400u0dy6.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">KIKI's Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间线</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-02-26T16:00:00.000Z" title="发表于 2023-02-27 00:00:00">2023-02-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-29T02:17:41.311Z" title="更新于 2023-04-29 10:17:41">2023-04-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法和数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h1><h2 id="CPU是如何执行程序的"><a href="#CPU是如何执行程序的" class="headerlink" title="CPU是如何执行程序的"></a>CPU是如何执行程序的</h2><p>定义计算机基本结构为 5 个部分，分别是运算器、控制器、存储器、输入设备、输出设备这 5 个部分也被称为冯诺依曼模型。</p>
<p>存储数据的基本单位是字节（byte），1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。</p>
<p>CPU 想要操作「内存地址」就需要「地址总线」：如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，表示地址有32位，因为 2 ^ 32 = 4G</p>
<blockquote>
<p>程序的执行过程</p>
</blockquote>
<p>第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。<br>第二步，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；<br>第三步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行；</p>
<p><strong>CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令</strong></p>
<blockquote>
<p>指令执行过程</p>
</blockquote>
<p>CPU 通过程序计数器读取对应内存地址的指令，这个部分称为 Fetch（取得指令）；<br>CPU 对指令进行解码，这个部分称为 Decode（指令译码）；<br>CPU 执行指令，这个部分称为 Execution（执行指令）；<br>CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 Store（数据回写）；<br>上面这 4 个阶段，我们称为指令周期（Instrution Cycle），CPU 的工作就是一个周期接着一个周期，周而复始。</p>
<blockquote>
<p>你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？</p>
</blockquote>
<p>64 位和 32 位软件，实际上代表<strong>指令是 64 位还是 32 位</strong>的：<br>(指令中的每位也都表示了特殊的含义，比如指令类型，操作码等)<br>如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令；<br>操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。</p>
<p><strong>总之，硬件的 64 位和 32 位指的是 CPU 的位宽（指每次可以读多少位的数据，32位机处理64位数字相加，就要分低32位和高32位计算，但是没有这么大的数的运算的时候，64位机也不比32位机快），软件的 64 位和 32 位指的是指令的位宽。</strong></p>
<blockquote>
<p>64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？</p>
</blockquote>
<p>64 位相比 32 位 CPU 的优势主要体现在两个方面：</p>
<p>64 位 CPU 可以一次计算超过 32 位的数字，而 32 位 CPU 如果要计算超过 32 位的数字，要分多步骤进行计算，效率就没那么高，但是大部分应用程序很少会计算那么大的数字，所以<strong>只有运算大数字的时候，64 位 CPU 的优势才能体现出来，否则和 32 位 CPU 的计算性能相差不大。</strong><br>通常来说 64 位 CPU 的地址总线是 48 位，而 32 位 CPU 的地址总线是 32 位，所以 64 位 CPU 可以寻址更大的物理内存空间。如果一个 32 位 CPU 的地址总线是 32 位，那么该 CPU 最大寻址能力是 4G，即使你加了 8G 大小的物理内存，也还是只能寻址到 4G 大小的地址，而如果一个 64 位 CPU 的地址总线是 48 位，那么该 CPU 最大寻址能力是 2^48，远超于 32 位 CPU 最大寻址能力。</p>
<h2 id="2-2存储器"><a href="#2-2存储器" class="headerlink" title="2.2存储器"></a>2.2存储器</h2><ul>
<li>CPU（寄存器，L1/L2/L3Cache）<ol>
<li>CPU 比喻成我们的大脑，大脑正在思考的东西，就好比 CPU 中的寄存器，处理速度是最快的，我们大脑中的记忆，就好比 CPU Cache，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。</li>
<li>CPU Cache 用的是一种叫 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片。SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。，一个 bit 的数据，通常需要 6 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。</li>
</ol>
</li>
<li>内存<br> 内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 DRAM （Dynamic Random Access Memory，动态随机存取存储器） 的芯片。只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。</li>
<li><p>SSD/HDD硬盘<br>SSD（Solid-state disk） 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 10~1000 倍。</p>
<p>机械硬盘（Hard Disk Drive, HDD），它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢 10W 倍左右。</p>
</li>
</ul>
<h2 id="2-3-CPU跑的更快"><a href="#2-3-CPU跑的更快" class="headerlink" title="2.3 CPU跑的更快"></a>2.3 CPU跑的更快</h2><p>写出让 CPU 跑得更快的代码，就需要写出缓存命中率高的代码，CPU L1 Cache 分为数据缓存和指令缓存，因而需要分别提高它们的缓存命中率：</p>
<ul>
<li>对于数据缓存，我们在遍历数据的时候，应该按照内存布局的顺序操作，这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升；</li>
<li>对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率；</li>
<li>对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高线程的缓存命中率，可以考虑把线程绑定 CPU 到某一个 CPU 核心。</li>
</ul>
<h2 id="2-4-何时把cache写会内存"><a href="#2-4-何时把cache写会内存" class="headerlink" title="2.4 何时把cache写会内存"></a>2.4 何时把cache写会内存</h2><ul>
<li>写直达<br>保持内存与 Cache 一致性最简单的方式是，把数据同时写入内存和 Cache 中，这种方法称为写直达（Write Through）。<br>每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。</li>
<li>写回<br>写回机制中，当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中，</li>
</ul>
<p>在把数据写入到 Cache 的时候，只有在缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。</p>
<blockquote>
<p>缓存一致性问题，多核CPU，每个CPU都有自己的cache</p>
<ol>
<li>某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播（Write Propagation）；</li>
<li>某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（Transaction Serialization）。比如两块CPU修改一个变量，按第一条传播的时候，必须有先后顺序，可以依赖锁防止这种情况</li>
</ol>
<p>写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。最常见实现的方式是总线嗅探（Bus Snooping）。</p>
</blockquote>
<p>总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串行化。</p>
<p>于是，有一个协议基于总线嗅探机制实现了事务串行化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性。</p>
<h1 id="2-6-中断"><a href="#2-6-中断" class="headerlink" title="2.6 中断"></a>2.6 中断</h1><p>所以，中断处理程序的上部分和下半部可以理解为：</p>
<ul>
<li>上半部，对应硬中断，由硬件触发中断，用来快速处理中断；</li>
<li>下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作；</li>
</ul>
<p>软中断的出现是因为，如果中断处理时间过长，在处理期间，可能无法处理新来的中断，所以分了两个半部，上半部只响应，下半部完成具体的中断业务逻辑<br>硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd/CPU 编号」，比如 0 号 CPU 对应的软中断内核线程的名字是 ksoftirqd/0</p>
<h2 id="3-1-操作系统结构"><a href="#3-1-操作系统结构" class="headerlink" title="3.1 操作系统结构"></a>3.1 操作系统结构</h2><blockquote>
<p>操作系统功能</p>
</blockquote>
<ul>
<li>进程调度</li>
<li>内存管理</li>
<li>硬件通信</li>
<li>系统调用</li>
</ul>
<h2 id="4-1-内存分段"><a href="#4-1-内存分段" class="headerlink" title="4.1 内存分段"></a>4.1 内存分段</h2><blockquote>
<p>内存分段</p>
</blockquote>
<p>分段分为堆，栈，代码区和数据段<br><strong>不会产生内部碎片</strong>，因为每次都是要多少分配多少<br>但是会产生外部碎片，因为每次分的时候，要看哪一片连续区域大小够才分，所以会有很多外部碎片，如果外部碎片太多导致无法为新进程分配时，就需要内存交换，即先写入硬盘再移位置，如果文件很大，效率就很低。</p>
<blockquote>
<p>内存分页</p>
</blockquote>
<p>多级页表解决4MB（每个页表项4字节，4GB = 4KB<em>2^20,需要2^20个页,那么4字节</em>2^20 = 4MB，，2^10 = 1024所以2^20 = M）<br>主要是一个二级页表能小很多，把2^20个一级页分成1024个2级页，那么只需要4KB就存下了，然后到时候需要一级页表的时候从硬盘中读就好了<br> 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约<br>序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer）通常称为页表缓存、转址旁路缓存、快表</p>
<blockquote>
<p>虚拟内存的用处</p>
</blockquote>
<ul>
<li>内存更大：第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。</li>
<li>进程间隔离： 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。</li>
<li>读写权限： 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。<h1 id="关注作者"><a href="#关注作者" class="headerlink" title="关注作者"></a>关注作者</h1>80386是32位处理器，物理内存地址空间2^32=4G字节<br>BIOS:基本I/O处理系统<br>DISK：存放OS<br>Bootloader</li>
</ul>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个<strong>运行中的程序，就被称为「进程」（Process）</strong>，代码是静态的<br><strong>并行与并发</strong>：但在 1 秒钟期间，它可能会运行多个进程，这样就产生并行的错觉，实际上这是<strong>并发</strong>。并行依赖多CPU</p>
<p><strong>进程的状态</strong>：一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/联想截图_20230303111924.png" alt=""><br>为了防止阻塞进程太多，占用内存,在虚拟内存管理的操作系统中，通常<strong>会把阻塞状态的进程的物理内存空间换出到硬盘</strong>，等需要再次运行的时候，再从硬盘换入到物理内存。这个<strong>没有占用实际的物理内存空间的状态就是挂起状态</strong>。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/联想截图_20230303112220.png" alt=""></p>
<p><strong>PCB</strong>是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。<br>通常是通过链表的方式进行组织，把<strong>具有相同状态的进程链在一起，组成各种队列。</strong><br><strong>上下文切换</strong>CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。<br>所以说，<strong>CPU寄存器和程序计数是CPU</strong>在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。<br>进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。</p>
<blockquote>
<p>发生进程上下文切换有哪些场景？</p>
</blockquote>
<ol>
<li>为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；</li>
<li>进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；</li>
<li>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；</li>
<li>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；</li>
<li>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序；</li>
</ol>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><blockquote>
<p>为什么需要线程？</p>
</blockquote>
<p>对于播放视频的进程，需要读取文件，解压文件，播放文件等多个工作<br>如果采用单进程的方式，各个函数之间不是并发执行，影响资源的使用效率；<br>如果采用多进程的方式，维护进程的系统开销较大，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息；<br>为此，引入<strong>线程</strong>( Thread )，线程之间可以并发运行且共享相同的地址空间。</p>
<p>同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。<br>当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃</p>
<p>线程是调度的基本单位，而进程则是资源拥有的基本单位。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>4次挥手的时候，如果是close，那么FIN_WAIT2不会持续很久，一般是60s，但如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态</p>
<blockquote>
<p>为什么需要 TIME_WAIT 状态？</p>
</blockquote>
<p>主动发起关闭连接的一方，才会有 TIME-WAIT 状态。,需要 TIME-WAIT 状态，主要是两个原因：</p>
<ol>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；</li>
</ol>
<p>当<strong>服务端出现大量的 TIME_WAIT 状态连接</strong>的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive，因为<strong>任意一方没有开启 HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接</strong>，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。</p>
<p> TCP 针对<strong>数据包丢失</strong>的情况，会用重传机制解决。</p>
<ol>
<li><p>超时重传<br>RTT（Round-Trip Time 往返时延）指数据自发送时刻到接收到确认之间的间隔<br>RTO （Retransmission Timeout 超时重传时间），太小会频繁重发，太大效率低</p>
<p>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值，会多次采样RTT，然后动态计算RTO，每次触发超时后，会翻倍</p>
</li>
<li>快速重传<br>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</li>
</ol>
<h1 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h1><h2 id="5-文件系统"><a href="#5-文件系统" class="headerlink" title="5 文件系统"></a>5 文件系统</h2><p>Linux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。</p>
<ul>
<li>索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。</li>
<li>目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。</li>
</ul>
<p>由于<strong>索引节点唯一标识一个文件，而目录项记录着文件的名字，所以目录项和索引节点的关系是多对一</strong>，也就是说，一个文件可以有多个别名。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。</p>
<p>注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。</p>
<blockquote>
<p>目录项和目录是一个东西吗？</p>
</blockquote>
<p>虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。</p>
<p>如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。</p>
<p>注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。</p>
<blockquote>
<p>那文件数据是如何存储在磁盘的呢？</p>
</blockquote>
<p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。</p>
<p>所以，文件系统把多个扇区组成了一个逻辑块，<strong>每次读写的最小单位就是逻辑块（数据块）</strong>，Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。</p>
<blockquote>
<p>虚拟文件系统</p>
<p>文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。</p>
</blockquote>
<p>我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程<strong>维护一个打开文件表，文件表里的每一项代表「文件描述符」，</strong>所以说文件描述符是打开文件的标识。</p>
<blockquote>
<p>操作系统在打开文件表中维护着打开文件的状态和信息：</p>
</blockquote>
<ul>
<li>文件指针：系统跟踪<strong>上次读写位置</strong>作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的；</li>
<li>文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，<strong>当该计数为 0 时，系统关闭文件，删除该条目；</strong></li>
<li>文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取；</li>
<li>访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求；</li>
</ul>
<blockquote>
<p>文件系统的基本操作单位是数据块</p>
</blockquote>
<p>当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。<br>当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。</p>
<blockquote>
<p>文件的存储</p>
</blockquote>
<p>文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种：</p>
<ul>
<li>连续空间存放方式<br>读写效率高，但要求文件头里需要指定「起始块的位置」和「长度」，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间<br>但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷</li>
<li>非连续空间存放方式<br>分为「链表方式」和「索引方式」<br>隐式链表方式，就是文件分成了几个块，每个块包含了下一块的指针，<br>缺点就是只能按照链表顺序，依次读数据块，同时指针消耗了资源，同时如果指针丢失，会导致文件损坏<br>显式链接,它指把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，查询在内存中进行更快，但是这个链接表不适合大磁盘<br><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83.png" alt=""></li>
</ul>
<h2 id="空闲空间管理（有新文件存在哪）"><a href="#空闲空间管理（有新文件存在哪）" class="headerlink" title="空闲空间管理（有新文件存在哪）"></a>空闲空间管理（有新文件存在哪）</h2><ol>
<li>空闲表法，用于上述连续存储，表中记录了空闲连续段的起始位置和大小</li>
<li>空闲链表法，用于非连续存储，空闲空间的链表彼此相连<br>空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。</li>
<li>位图法<br>用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。<br>当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111110011111110001110110111111100111 ...</span><br></pre></td></tr></table></figure>
在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。</li>
</ol>
<h2 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h2><p>有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。</p>
<p>硬链接是<strong>多个目录项中的「索引节点」指向一个文件</strong>，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么<strong>只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。</strong></p>
<p>硬链接</p>
<p>软链接相当于<strong>重新创建一个文件</strong>，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。</p>
<p>软链接</p>
<h1 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I/O"></a>文件 I/O</h1><p>文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有</p>
<p>缓冲与非缓冲 I/O<br>直接与非直接 I/O<br>阻塞与非阻塞 I/O VS 同步与异步 I/O<br>接下来，分别对这些分类讨论讨论。</p>
<h1 id="缓冲与非缓冲-I-O"><a href="#缓冲与非缓冲-I-O" class="headerlink" title="缓冲与非缓冲 I/O"></a>缓冲与非缓冲 I/O</h1><p>文件操作的标准库是可以实现数据的缓存，那么根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O：</p>
<p>缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。<br>非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。<br>这里所说的「缓冲」特指标准库内部实现的缓冲。</p>
<p>比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。</p>
<h1 id="直接与非直接-I-O"><a href="#直接与非直接-I-O" class="headerlink" title="直接与非直接 I/O"></a>直接与非直接 I/O</h1><p>我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。</p>
<p>那么，根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O：</p>
<p>直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。<br>非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。<br>如果你在使用文件操作类的系统调用函数时，指定了 O_DIRECT 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。</p>
<h1 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h1><p>位图法</p>
<h1 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">KIKI</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/02/27/OS/">http://example.com/2023/02/27/OS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">KIKI's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="next-cover" src="https://raw.githubusercontent.com/KIKI9731/image/main/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90.jfif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/006GMZnVgy1g4jclj8kuvj31400u0dy6.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">KIKI</div><div class="author-info__description">一只努力减脂的KI</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:2498333273@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">硬件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84"><span class="toc-number">1.1.</span> <span class="toc-text">CPU是如何执行程序的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2.2存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-CPU%E8%B7%91%E7%9A%84%E6%9B%B4%E5%BF%AB"><span class="toc-number">1.3.</span> <span class="toc-text">2.3 CPU跑的更快</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%BD%95%E6%97%B6%E6%8A%8Acache%E5%86%99%E4%BC%9A%E5%86%85%E5%AD%98"><span class="toc-number">1.4.</span> <span class="toc-text">2.4 何时把cache写会内存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-6-%E4%B8%AD%E6%96%AD"><span class="toc-number">2.</span> <span class="toc-text">2.6 中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">3.1 操作系统结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">4.1 内存分段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E4%BD%9C%E8%80%85"><span class="toc-number">3.</span> <span class="toc-text">关注作者</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">5.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP"><span class="toc-number">5.1.</span> <span class="toc-text">TCP</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OS"><span class="toc-number">6.</span> <span class="toc-text">OS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.1.</span> <span class="toc-text">5 文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86%EF%BC%88%E6%9C%89%E6%96%B0%E6%96%87%E4%BB%B6%E5%AD%98%E5%9C%A8%E5%93%AA%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">空闲空间管理（有新文件存在哪）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">6.3.</span> <span class="toc-text">软硬链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6-I-O"><span class="toc-number">7.</span> <span class="toc-text">文件 I&#x2F;O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E4%B8%8E%E9%9D%9E%E7%BC%93%E5%86%B2-I-O"><span class="toc-number">8.</span> <span class="toc-text">缓冲与非缓冲 I&#x2F;O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%B8%8E%E9%9D%9E%E7%9B%B4%E6%8E%A5-I-O"><span class="toc-number">9.</span> <span class="toc-text">直接与非直接 I&#x2F;O</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">10.</span> <span class="toc-text">文件系统的结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95"><span class="toc-number">11.</span> <span class="toc-text">空闲表法</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/OS/" title="操作系统"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/b0e0302e6ecffa4a3e5ef149ec24c3d4.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2023/02/27/OS/" title="操作系统">操作系统</a><time datetime="2023-02-26T16:00:00.000Z" title="发表于 2023-02-27 00:00:00">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://raw.githubusercontent.com/KIKI9731/image/main/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90.jfif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/02/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-02-26T16:00:00.000Z" title="发表于 2023-02-27 00:00:00">2023-02-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/" title="Linux项目补充和扩展"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux项目补充和扩展"/></a><div class="content"><a class="title" href="/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/" title="Linux项目补充和扩展">Linux项目补充和扩展</a><time datetime="2023-01-26T16:00:00.000Z" title="发表于 2023-01-27 00:00:00">2023-01-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/13/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" title="刷题算法"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/C.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="刷题算法"/></a><div class="content"><a class="title" href="/2023/01/13/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/" title="刷题算法">刷题算法</a><time datetime="2023-01-12T16:00:00.000Z" title="发表于 2023-01-13 00:00:00">2023-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/01/09/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE5/" title="Linux项目5-Web服务器项目"><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/linux.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux项目5-Web服务器项目"/></a><div class="content"><a class="title" href="/2023/01/09/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE5/" title="Linux项目5-Web服务器项目">Linux项目5-Web服务器项目</a><time datetime="2023-01-08T16:00:00.000Z" title="发表于 2023-01-09 00:00:00">2023-01-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By KIKI</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>