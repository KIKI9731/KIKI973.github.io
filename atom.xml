<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KIKI&#39;s Blog</title>
  
  <subtitle>分享科研总结和生活琐碎</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-01-03T10:28:42.543Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>KIKI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux项目4-网络编程</title>
    <link href="http://example.com/2023/01/01/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE4/"/>
    <id>http://example.com/2023/01/01/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE4/</id>
    <published>2022-12-31T16:00:00.000Z</published>
    <updated>2023-01-03T10:28:42.543Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h1><p>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网络接口卡NIC。其拥有 MAC 地址，属于 <strong>OSI 模型的第 2 层</strong>，它使得用户可以通过电缆或无线相互连接。每一个网卡都有一个被称为 MAC 地址的<strong>独一无二的 48 位串行号</strong>。<br>网卡的主要功能：</p><ol><li>数据的封装与解封装</li><li>链路管理</li><li>数据编码与译码</li></ol><p>网卡分为以太网卡（有线网）和无线网卡通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就<br>是一个MAC 地址，其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由<br>IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的<br>某个网络产品（如网卡）的系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。<br>形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性。，每个网卡都需要独一无二的MAC地址，通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就是一个MAC 地址，其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的某个网络产品（如网卡）的系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。<br>形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性。</p><p>IP地址32位二进制数，分4组<br>A类地址：1字节网络+3字节本机号码</p><p>ARP协议：根据IP查找MAC地址</p><p>Socket由IP地址和端口结合，提供向应用层进程传送数据包的机制。<br>socket类似于一个文件描述符，通过读写缓冲区实现主机间通信<br>客户端：主动向服务器发起连接<br>服务器段：被动接受链接</p><h1 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h1><h2 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h2><p><strong>字节序：</strong>大端字节序：高位字节排放在内存的低地址端。这里举例的是32位机，即一次装载4字节时的存储结果<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/字节序.png" alt=""><br>网络字节序与CPU和操作系统无关，采用大端排序，保证了不同主机之间传输可以被正确解释。<br>网络通信时，需要将主机字节序转换成网络字节序（大端），另外一段获取到数据以后根据情况将网络字节序转换成主机字节序。<br>C++中的int 可以分为short int, long int, long long int，分别占2，4，8个字节，对应的有各自的unsigned，由于端口是16位，也就是2字节，所以用short int,IP地址是32位，所以用int型（long int和int是一回事）</p><blockquote><p>h - host，主机，主机字节序<br>to - 转换<br>n - network，网络字节序<br>s - short unsigned short<br>l - long unsigned int</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量类型</span></span><br><span class="line"><span class="keyword">uint16_t</span>：<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">uint32_t</span>：<span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 转换端口，2个字节</span></span><br><span class="line">    <span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br><span class="line"> <span class="comment">// 转IP,4个字节</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="comment">//这些函数仅涉及字节序的转换，所以输入输出的数据类型都是一样的，最后的s和l区分了是转换IP还是转换端口</span></span><br></pre></td></tr></table></figure><h2 id="Scoket地址"><a href="#Scoket地址" class="headerlink" title="Scoket地址"></a>Scoket地址</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="keyword">sa_family_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family;</span><br><span class="line"><span class="keyword">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般不适用sockaddr，而是使用sockaddr_in再进行强制类型转换<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/socket.png" alt=""></p><p>IPv4的sockaddr_in<br>关键信息就是协议类型，端口号，IP，分别如下：</p><blockquote><p>struct sockaddr_in saddr;<br>协议:saddr.sin_family<br>IP:saddr.sin_addr.s_addr<br>端口：saddr.sin_port</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family; </span><br><span class="line"><span class="keyword">in_port_t</span> sin_port; <span class="comment">//unit16_t类型，端口地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">//结构体，只有一个元素s_addr,存放IP</span></span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="built_in"><span class="keyword">sizeof</span></span> (struct sockaddr) - __SOCKADDR_COMMON_SIZE -<span class="built_in"><span class="keyword">sizeof</span></span> (<span class="keyword">in_port_t</span>) - <span class="built_in"><span class="keyword">sizeof</span></span> (struct in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">in_addr_t</span> s_addr;<span class="comment">//unit32_t类型，存放IP地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>IPv6的sockaddr_in6<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin6_family;</span><br><span class="line"><span class="keyword">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line"><span class="keyword">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line"><span class="keyword">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint16_t</span> <span class="keyword">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))</span></span><br></pre></td></tr></table></figure></p><h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><blockquote><p>p:点分十进制的IP字符串<br>n:表示network，网络字节序的整数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"><span class="comment">//主要用到以下两个，他们能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">af:地址族： AF_INET AF_INET6</span></span><br><span class="line"><span class="comment">src:需要转换的点分十进制的IP字符串</span></span><br><span class="line"><span class="comment">dst:转换后的结果保存在这个里面</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">af:地址族： AF_INET AF_INET6</span></span><br><span class="line"><span class="comment">src: 要转换的ip的整数的地址</span></span><br><span class="line"><span class="comment">dst: 转换成IP地址字符串保存的地方</span></span><br><span class="line"><span class="comment">size：第三个参数的大小（数组的大小）</span></span><br><span class="line"><span class="comment">返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>实例</strong><br>需要注意void <em>可以指向任何类型的地址，但是带类型的指针不能指向void </em>的地址，所以可以直接传入&amp;num，即一个unsigned int<em>的值给void </em>,但只有强制类型转换后才可以使用<br>当void* 指针作为函数的输入和输出时，表示可以接受任意类型的输入指针和输出任意类型的指针<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个ip字符串,点分十进制的IP地址字符串，总共有32位分为4组，即每组有8位，可以用unsigned char(1字节，8位)来表示</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = <span class="string">&quot;192.168.1.4&quot;</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 将点分十进制的IP字符串转换成网络字节序的整数</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, buf, &amp;num);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> * p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"><span class="comment">//结果：192 168 1 4，此时num = 67217600(0000 0100 0000 0001 1010 1000 1100 0000)</span></span><br><span class="line"><span class="comment">/*可以看到字节序和char类型的显示是不太一样的</span></span><br><span class="line"><span class="comment">  1100 0000 -&gt;192</span></span><br><span class="line"><span class="comment">  1010 1000 -&gt;168</span></span><br><span class="line"><span class="comment">  0000 0001 -&gt;1</span></span><br><span class="line"><span class="comment">  0000 0100 -&gt;4</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将网络字节序的IP整数转换成点分十进制的IP字符串</span></span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * str =  <span class="built_in">inet_ntop</span>(AF_INET, &amp;num, ip, <span class="number">16</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str : %s\n&quot;</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ip : %s\n&quot;</span>, ip);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ip == str);</span><br><span class="line"><span class="comment">/*结果：</span></span><br><span class="line"><span class="comment">str:192.168.1.4</span></span><br><span class="line"><span class="comment">ip:198.168.1.4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/TCP.png" alt=""><br>TCP通信需要用到的函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">- 功能：创建一个套接字</span><br><span class="line">- 参数：</span><br><span class="line">- domain: 协议族</span><br><span class="line">    AF_INET : ipv4</span><br><span class="line">    AF_INET6 : ipv6</span><br><span class="line">    AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">- type: 通信过程中使用的协议类型</span><br><span class="line">    SOCK_STREAM : 流式协议</span><br><span class="line">    SOCK_DGRAM : 报式协议</span><br><span class="line">- protocol : 具体的一个协议。一般写<span class="number">0</span>，因为一个协议族有很多，这个数字表示用族里的哪一个协议</span><br><span class="line">    SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">    SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">- 返回值：</span><br><span class="line">    成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">    失败：<span class="number">-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>; <span class="comment">// socket命</span></span><br><span class="line">名</span><br><span class="line">- 功能：绑定，将fd 和本地的IP + 端口进行绑定</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">- addrlen : 第二个参数结构体占的内存大小</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>; <span class="comment">// /proc/sys/net/core/somaxconn</span></span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通过<span class="built_in">socket</span>()函数得到的文件描述符</span><br><span class="line">- backlog : 未连接的和已经连接的和的最大值， <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 用于监听的文件描述符</span><br><span class="line">- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">- addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">- 返回值：</span><br><span class="line">- 成功 ：用于通信的文件描述符</span><br><span class="line">- <span class="number">-1</span> ： 失败</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line">- 功能： 客户端连接服务器</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 用于通信的文件描述符</span><br><span class="line">- addr : 客户端要连接的服务器的地址信息</span><br><span class="line">- addrlen : 第二个参数的内存大小</span><br><span class="line">- 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br></pre></td></tr></table></figure></p><h2 id="TCP服务器端代码"><a href="#TCP服务器端代码" class="headerlink" title="TCP服务器端代码"></a>TCP服务器端代码</h2><ol><li>创建socket</li><li>绑定bind</li><li>监听listen</li><li>接收accpet</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的服务器端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建socket(用于监听的套接字)</span></span><br><span class="line">    <span class="keyword">int</span> lfd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(lfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">saddr</span>;</span><span class="comment">//IPv4的socket地址，需要给定端口，协议，IP三个信息</span></span><br><span class="line">    saddr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">//可以通过如下函数指定IP地址，即将给定的点分10进制IP传入saddr.sin_addr.s_addr</span></span><br><span class="line">    <span class="comment">// inet_pton(AF_INET, &quot;192.168.193.128&quot;, saddr.sin_addr.s_addr);</span></span><br><span class="line">    saddr.sin_addr.s_addr = INADDR_ANY;  <span class="comment">// 0.0.0.0</span></span><br><span class="line">    saddr.sin_port = <span class="built_in">htons</span>(<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>(lfd, (struct sockaddr *)&amp;saddr, <span class="built_in"><span class="keyword">sizeof</span></span>(saddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(lfd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.接收客户端连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(clientaddr);</span><br><span class="line">    <span class="keyword">int</span> cfd = <span class="built_in">accept</span>(lfd, (struct sockaddr *)&amp;clientaddr, &amp;len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出客户端的信息</span></span><br><span class="line">    <span class="keyword">char</span> clientIP[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, <span class="built_in"><span class="keyword">sizeof</span></span>(clientIP));</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> clientPort = <span class="built_in">ntohs</span>(clientaddr.sin_port);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;client ip is %s, port is %d\n&quot;</span>, clientIP, clientPort);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.通信</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取客户端的数据</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">read</span>(cfd, recvBuf, <span class="built_in"><span class="keyword">sizeof</span></span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示客户端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;clinet closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> * data = <span class="string">&quot;hello,i am server&quot;</span>;</span><br><span class="line">        <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        <span class="built_in">write</span>(cfd, data, <span class="built_in">strlen</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 关闭文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>(cfd);</span><br><span class="line">    <span class="built_in">close</span>(lfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TCP客户端"><a href="#TCP客户端" class="headerlink" title="TCP客户端"></a>TCP客户端</h2><ol><li>创建socket</li><li>链接connect</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP通信的客户端</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.连接服务器端</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span></span><br><span class="line">    serveraddr.sin_family = AF_INET;</span><br><span class="line">    inet_pton(AF_INET, <span class="string">&quot;192.168.193.128&quot;</span>, &amp;serveraddr.sin_addr.s_addr);</span><br><span class="line">    serveraddr.sin_port = htons(<span class="number">9999</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = connect(fd, (struct sockaddr *)&amp;serveraddr, <span class="keyword">sizeof</span>(serveraddr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 通信</span></span><br><span class="line">    <span class="keyword">char</span> recvBuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> * data = <span class="string">&quot;hello,i am client&quot;</span>;</span><br><span class="line">        <span class="comment">// 给客户端发送数据</span></span><br><span class="line">        write(fd, data , <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = read(fd, recvBuf, <span class="keyword">sizeof</span>(recvBuf));</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv server data : %s\n&quot;</span>, recvBuf);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 表示服务器端断开连接</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;server closed...&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录牛客项目</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>非线性数据结构（树）</title>
    <link href="http://example.com/2022/12/29/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%A0%91)/"/>
    <id>http://example.com/2022/12/29/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%A0%91)/</id>
    <published>2022-12-28T16:00:00.000Z</published>
    <updated>2023-01-01T12:04:13.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="刷题备注"><a href="#刷题备注" class="headerlink" title="刷题备注"></a>刷题备注</h1><p>注意区分几种常见容器的操作<br>vector<br>queue单端队列</p><blockquote><p>queue<int>q；创建一个int型空队列q<br>q.empty（）；判断队列是否为空，为空返回true<br>q.push（s）；将变量s从队尾入队<br>q.pop（）；将队头元素弹出<br>q.front（）；只返回队头元素<br>q.back（）；只返回队尾元素<br>q.size（）返回队列中元素个数<br>queue从队首弹出，先入先出</p></blockquote><p>deque双端队列的操作（可以在队头队尾进行入队出队操作）</p><blockquote><p>deque<int> dq；创建一个数双端队列dq<br>dq.empty（）；判断队列是否为空，为空返回true<br>dq.push_front（s）；将s从队头入队<br>dq.push_back（s）；将s从队尾入队，和普通队列方式一样<br>dq.front（）；只返回队头元素<br>dq.back（）；只返回队尾元素<br>dq.pop_front（）；将队头元素弹出<br>dq.pop_back；将队尾元素弹出<br>dq.clear（）；将队列清空</p></blockquote><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p>&emsp;&emsp;如果数据是固定不动的，则查找数据称为静态查找（没有插入和删除操作，只有查找），如果数据会发生变化，则是动态查找。对于静态查找，可以是顺序查找，则时间复杂度为O(N)，或者二分查找，元素本身是有序排列的，时间复杂度为O(logN)，二分查找时，定义了pre,end,mid。每次查找后，end = mid - 1,或者pre = mid +1;不能直接等于mid，这样会出现死循环。根据二分查找的想法，构造了与之类似的数据结构————<strong>树</strong>，因此查找次数不会超过数的层数，也即是O(logN)。<br>&emsp;&emsp;实现时，可以通过链表实现，但如果链表指向子树，对于大部分比较稀疏或者度数较大的树，会造成很大的浪费，因此可以将链表设置为2个指针，分别指向兄弟节点和子节点（下图左）。对于二叉树，则可以直接将两个指针分别指向其左右子节点（下图右）。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220207121828.png" alt=""></p><h2 id="定义与实现"><a href="#定义与实现" class="headerlink" title="定义与实现"></a>定义与实现</h2><p>&emsp;&emsp;树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。<br>&emsp;&emsp;一棵有n个节点的树，一共有n-1条边，根节点没有，其中节点的子树个数称为<strong>结点的度</strong>，一个树的度是节点中最大的度数，二叉树的度数为2，叶结点的度数为0。假设定义$n_2$为度数为2的结点数，$n_0$为叶结点树，则$n_2+1=n_0$，因为$2n_2+n_1(每个结点下的边数)=n_0+n_1+n_2-1(节点数-1)$。<br>&emsp;&emsp;二叉树第$i$层，最多有$2^{i-1}$个结点，层数为i的二叉树，最多有$2^i-1$个结点。<br>&emsp;&emsp;<strong>完美二叉树（满二叉树）</strong>，是指每层都是满的二叉树，仅最后一层不满的且缺少的结点连续，都在右侧时为<strong>完全二叉树</strong>，其结点的标号和完美二叉树一致。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220205135620.png" alt=""><br><strong>平衡二叉搜索树</strong>：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x      <span class="comment"># 节点值</span></span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 左子节点</span></span><br><span class="line">        self.right = <span class="literal">None</span> <span class="comment"># 右子节点</span></span><br><span class="line"><span class="comment"># 初始化节点</span></span><br><span class="line">        n1 = TreeNode(<span class="number">3</span>) <span class="comment"># 根节点 root</span></span><br><span class="line">        n2 = TreeNode(<span class="number">4</span>)</span><br><span class="line">        n3 = TreeNode(<span class="number">5</span>)</span><br><span class="line">        n4 = TreeNode(<span class="number">1</span>)</span><br><span class="line">        n5 = TreeNode(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建引用指向</span></span><br><span class="line">        n1.left = n2</span><br><span class="line">        n1.right = n3</span><br><span class="line">        n2.left = n4</span><br><span class="line">        n2.right = n5</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="keyword">int</span> x): <span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h1><p>&emsp;&emsp;根据遍历根节点的顺序，分为<strong>前序，中序和后续遍历</strong>三种。通常使用递归实现，三种遍历的路径其实是一致的，区别在于每个节点输出的时刻，前序在第一次遇到该节点时即输出，中序在第二次，后序在第三次。除此之外，还有<strong>层次遍历</strong>，即从上到下，从左到右。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220207125754.png" alt=""></p><h2 id="前中后序遍历"><a href="#前中后序遍历" class="headerlink" title="前中后序遍历"></a>前中后序遍历</h2><p>迭代法-中序遍历，访问的顺序和处理的顺序不一样，先定义指针cur代表遍历访问的结点，当没有左结点的时候，开始处理，即if和else判断是继续向左遍历，还是开始处理，开始处理的时候，栈顶的元素就是要处理的元素。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode *&gt; st;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span> || !st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//递归法，比较简单，注意引用格式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zhongxu</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">zhongxu</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">zhongxu</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">zhongxu</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>后序遍历的迭代法，注意输出结果反转<br>加入顺序中-&gt;右-&gt;左，（入栈顺序是左右），反转reverse(左右中)<br>前序遍历，输出顺序中-&gt;左-&gt;右，（入栈顺序是右左）<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序，先右后左</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();                       <span class="comment">// 中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);           <span class="comment">// 右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);             <span class="comment">// 左（空节点不入栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序，先左后右，输出反转</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left); <span class="comment">// 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right); <span class="comment">// 空节点不入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>()); <span class="comment">// 将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>&emsp;&emsp;根据二分法的启示，建立一种二叉搜索树，其非空左子树的所有键值小于其根结点的键值，右子树相反，且左右子树都是二叉搜索树。应该实现插入，删除和查找这些基本操作。由于其内部顺序，其最小值为最左侧的结点，最大值为最右侧的结点。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220207191720.png" alt=""><br>&emsp;&emsp;原因是，对于完全二叉树，如果有右结点，则一定有左结点，但是可以仅有左结点，没有右结点，所以，最小值一定是叶节点，因为如果不是，必有左结点，即必有更小的值，但最大值不一定，其可以是有左结点的一个结点。</p><h3 id="L98-验证二叉搜索树"><a href="#L98-验证二叉搜索树" class="headerlink" title="L98 验证二叉搜索树"></a>L98 <a href="https://leetcode.cn/problems/validate-binary-search-tree/">验证二叉搜索树</a></h3><p>递归判断的时候注意，要求是所有右子树的节点值都大于父结点，但是递归判断的时候，只是满足当前节点，并不能保证子树往下的节点，所以会出问题。<br><strong>二叉搜索树的中序遍历是递增</strong>的，结合这个特点，可以采用递归法，也就是中序遍历的递归的时候，可以在每次往res增加，即遍历时进行判断，因为中序遍历是递增的，所以每次push_back的数，都是递增的，那么可以把这一句改为一个判断语句<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">zhongxu</span><span class="params">(TreeNode *root,vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">zhongxu</span>(root-&gt;left,res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);<span class="comment">//这一句，每次都是递增的</span></span><br><span class="line">        <span class="built_in">zhongxu</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">zhongxu</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>即，用一个变量保存每次增加的值，起始化为一个特别小的数，longlong类型,每次push_back的时候，如果比原来的大，就是符合题意得，否则，证明不是递增的，就返回false，只是把递归代码改了一下哈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxVal = LONG_MIN; <span class="comment">// 因为后台测试数据中有int最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="comment">// 中序遍历，验证遍历的元素是不是从小到大</span></span><br><span class="line">        <span class="keyword">if</span> (maxVal &lt; root-&gt;val) maxVal = root-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> right = <span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a>剑指 Offer 33. 二叉搜索树的后序遍历序列</h2><p>&emsp;&emsp;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。<br>&emsp;&emsp;假如是一个二叉搜索树，则根据<strong>左结点-右结点-根节点</strong>的后序遍历顺序，最后一个元素为根节点，且小于所有的右结点，因此从数组最左边开始遍历，一旦找到大于根结点的值（<strong>代码中用q表示</strong>），则从当前位置到根节点之前（<strong>postorder[q,j-1]</strong>），应该都大于根结点，同时其左右子树（<strong>postorder[i,q-1]，postorder[q,j-1]</strong>）再进行递归。</p><blockquote><p>方法1：递归：时间复杂度$O(N^2)$ ,每次递归的时候减去一个根节点，因此递归占用$O(N)$ ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用$O(N)$。<br>空间复杂度$O(N)$:最差情况下（即当树退化为链表），递归深度将达到N。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">i,j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            p = i</span><br><span class="line">            <span class="keyword">while</span> postorder[p]&lt;postorder[j]:</span><br><span class="line">                p+=<span class="number">1</span></span><br><span class="line">            q = p</span><br><span class="line">            <span class="keyword">while</span> postorder[p]&gt;postorder[j]:</span><br><span class="line">                p+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p==j:                </span><br><span class="line">                <span class="keyword">return</span> judge(i,q-<span class="number">1</span>) <span class="keyword">and</span> judge(q,j-<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> judge(<span class="number">0</span>,<span class="built_in">len</span>(postorder)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>方法2：辅助栈，时间复杂度降到O(N)<br>&emsp;&emsp;在后序遍历时，在遍历完右结点后会访问根节点，所以如果是完全二叉树，必然会出现一个<strong>数值减小</strong>的过程，但是必须从后往前看，因为从前往后看，树的结构不清楚，会比较乱，那么从后往前看，每次<strong>数值增大</strong>都是从根节点到右结点的过程，设计一个栈进行该操作，当出现<strong>数值减小</strong>时，说明遇到了左结点，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 层序遍历</span></span><br><span class="line"><span class="keyword">for</span>循环是精髓，保证了每次是处理一层，类似的变种有[很多题](https://www.programmercarl.com/<span class="number">0102.</span>%E4%BA%8C%E5%8F%<span class="number">89</span>%E6%A0%<span class="number">91</span>%E7%9A%<span class="number">84</span>%E5%B1%<span class="number">82</span>%E5%BA%8F%E9%<span class="number">81</span>%8D%E5%8E%<span class="number">86.</span>html)，都大差不差，注意往队列中添加元素前，判断是否为空。</span><br><span class="line">```cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="class"><span class="title">public</span>:</span></span><br><span class="line">    vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; levelOrder(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != NULL) que.push(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="built_in">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">            <span class="built_in">int</span> size = que.size();</span><br><span class="line">            vector&lt;<span class="built_in">int</span>&gt; vec;</span><br><span class="line">            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                vec.push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></h2><p>这个题，其实就是对于每个节点，交换一下他的左右节点，所以其实不管是深度优先还是广度优先都可以，但是不要用中序遍历，因为有的节点会被遍历两次<br>为什么深度遍历用栈不用队列，因为栈是先进后出，需要一次性走到头<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归实现,注意那个交换要写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left, root-&gt;right);  <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);         <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);        <span class="comment">// 右</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//层序遍历实现，这个和上面的区别就是没有for循环，因为不需要按层处理</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(node-&gt;left, node-&gt;right); <span class="comment">// 节点处理</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="comment">//深度遍历，用栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">        stack &lt;TreeNode *&gt; st;</span><br><span class="line">        TreeNode *cur = root;</span><br><span class="line">        <span class="keyword">if</span>(root) st.<span class="built_in">push</span>(cur);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cur = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(cur-&gt;left,cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right) st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left) st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><p>递归啊，递归<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left,TreeNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">NULL</span> &amp;&amp; right==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left!=<span class="literal">NULL</span> &amp;&amp; right==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">NULL</span> &amp;&amp; right!=<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val!=right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(left-&gt;left,right-&gt;right)&amp;&amp;<span class="built_in">compare</span>(left-&gt;right,right-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//或者更简洁一点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!p &amp;&amp; !q) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!p || !q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val == q-&gt;val &amp;&amp; <span class="built_in">check</span>(p-&gt;left, q-&gt;right) &amp;&amp; <span class="built_in">check</span>(p-&gt;right, q-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">关于树的知识和算法题总结</summary>
    
    
    
    <category term="算法和数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux项目3</title>
    <link href="http://example.com/2022/12/29/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE3/"/>
    <id>http://example.com/2022/12/29/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE3/</id>
    <published>2022-12-28T16:00:00.000Z</published>
    <updated>2023-01-01T05:33:54.485Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><ol><li>线程创建，分离，终止</li><li>线程与进程的区别，线程同步，互斥锁，读写锁</li><li>条件变量，信号量，生产者消费者模型</li></ol><h1 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h1><p>与进程（process）类似，<strong>线程（thread）</strong>是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，<strong>且共享同一份全局内存区域</strong>，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）<br><strong>进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。</strong><br>线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。<br>查看指定进程的 LWP 号：ps –Lf pid</p><p><strong>线程和进程的区别：</strong></p><ol><li>进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。</li><li>调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。</li><li>线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。</li><li>创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，（每个线程被分配各自独有的空间）无需采用写时复制来复制内存，也无需复制页表。</li></ol><p><strong>共享资源</strong></p><ol><li>进程 ID 和父进程 ID</li><li>进程组 ID 和会话 ID</li><li>用户 ID 和 用户组 ID</li><li>文件描述符表</li><li>信号处置</li><li>文件系统的相关信息：文件权限掩码（umask）、当前工作目录</li><li>虚拟地址空间（除栈、.text，这些每个线程自己有自己的独有空间）</li></ol><p><strong>非共享资源</strong></p><ol><li>线程 ID</li><li>信号掩码</li><li>线程特有数据</li><li>error 变量</li><li>实时调度策略和优先级</li><li>栈，本地变量和函数的调用链接信息</li></ol><p><strong>系统调用</strong><br>一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程为子线程。程序中默认只有一个进程，fork()函数调用，产生2个进程。<br>程序中默认只有一个线程，pthread_create()函数调用，产生2个线程。<br>编译时需要加 -pthread</p><h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">void</span> *(*start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：创建一个子线程<br>参数：</p><blockquote><p>thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。<br>attr : 设置线程的属性，一般使用默认值，NULL<br>start_routine : 函数指针，这个函数是子线程需要处理的逻辑代码,返回值和参数列表都是void *类型<br>arg : 给第三个参数使用，传参</p></blockquote><p>返回值：成功：0;失败：返回错误号。这个错误号和之前errno不太一样。<br>获取错误号的信息：  char * strerror(int errnum);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread...\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arg value: %d\n&quot;</span>, *(<span class="keyword">int</span> *)arg);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, (<span class="keyword">void</span> *)&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h2><p>void pthread_exit(void *retval);<br>功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程<br>参数：retval需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。</p><p>pthread_t pthread_self(void);<br>功能：获取当前的线程的线程ID</p><p>int pthread_equal(pthread_t t1, pthread_t t2);<br>功能：比较两个线程ID是否相等<br>不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的是使用结构体去实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    <span class="comment">// pthread_exit(NULL);</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main thread exit\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// exit(0);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链接已终止的线程"><a href="#链接已终止的线程" class="headerlink" title="链接已终止的线程"></a>链接已终止的线程</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span> **retval)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：和一个已经终止的线程进行连接用来回收子线程的资源，这个函数是阻塞函数，调用一次只能回收一个子线程，一般在主线程中使用<br>参数：</p><blockquote><p>thread：需要回收的子线程的ID<br>retval: 接收子线程退出时的返回值</p></blockquote><p>返回值：0 : 成功,非0 : 失败，返回的错误号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="comment">// sleep(3);</span></span><br><span class="line">    <span class="comment">// return NULL; </span></span><br><span class="line">    <span class="comment">// int value = 10; // 局部变量</span></span><br><span class="line">    pthread_exit((<span class="keyword">void</span> *)&amp;value);   <span class="comment">// return (void *)&amp;value;</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid ,pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线程调用pthread_join()回收子线程的资源</span></span><br><span class="line">    <span class="keyword">int</span> * thread_retval;</span><br><span class="line">    ret = pthread_join(tid, (<span class="keyword">void</span> **)&amp;thread_retval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;exit data : %d\n&quot;</span>, *thread_retval);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;回收子线程资源成功！\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。</span></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分离线程"><a href="#分离线程" class="headerlink" title="分离线程"></a>分离线程</h2><p>int pthread_detach(pthread_t thread);<br>功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。</p><ol><li>不能多次分离，会产生不可预料的行为。</li><li>不能去连接一个已经分离的线程，会报错。</li></ol><p>参数：需要分离的线程的ID<br>返回值：成功：0,失败：返回错误号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放</span></span><br><span class="line">    ret = pthread_detach(tid);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error2 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置分离后，对分离的子线程进行连接 pthread_join()</span></span><br><span class="line">    <span class="comment">// ret = pthread_join(tid, NULL);</span></span><br><span class="line">    <span class="comment">// if(ret != 0) &#123;</span></span><br><span class="line">    <span class="comment">//     char * errstr = strerror(ret);</span></span><br><span class="line">    <span class="comment">//     printf(&quot;error3 : %s\n&quot;, errstr);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区别</strong></p><blockquote><p>线程的分离属性(detach属性):资源释放操作。在线程结束后，由系统释放资源;<br>线程的连接属性(join属性):资源释放操作。由一个线程监督该执行线程，结束后释放资源。</p></blockquote><h2 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h2><p>int pthread_cancel(pthread_t thread);<br>功能：取消线程（让线程终止）<br>取消某个线程，可以终止某个线程的运行，但是<strong>并不是立马终止</strong>，而是当子线程执行到一个取消点，线程才会终止。<br>取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child : %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消线程</span></span><br><span class="line">    pthread_cancel(tid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//初始化线程属性变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">//释放线程属性的资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *detachstate)</span></span>;</span><br><span class="line"><span class="comment">//获取线程分离的状态属性</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">//设置线程分离的状态属性</span></span><br></pre></td></tr></table></figure><p>示例代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">callback</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chid thread id : %ld\n&quot;</span>, pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程属性变量</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">    <span class="comment">// 初始化属性变量</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置属性</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, &amp;attr, callback, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> * errstr = strerror(ret);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error1 : %s\n&quot;</span>, errstr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取线程的栈的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    pthread_attr_getstacksize(&amp;attr, &amp;size);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;thread stack size : %ld\n&quot;</span>, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出主线程和子线程的id</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;tid : %ld, main thread id : %ld\n&quot;</span>, tid, pthread_self());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放线程属性资源</span></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><p>线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须<strong>确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。</strong><br><strong>临界区</strong>是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作(不可以被分割执行的操作，必须执行完)，也就是<strong>同时访问同一共享资源的其他线程不应中断该片段的执行。</strong><br><strong>线程同步：</strong>即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。这样会降低效率（只针对操作临界区的代码，不是所有代码），但是可以保证数据安全性。</p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>为避免线程更新共享变量时出现问题，可以使用<strong>互斥量</strong>（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。<br>互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。<br>一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问<br>同一资源时将采用如下协议：</p><ol><li>针对共享资源锁定互斥量</li><li>访问共享资源</li><li>对互斥量解锁</li></ol><p>如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（<strong>其他线程将遭到阻塞</strong>），即同时只有一个线程能够进入这段代码区域，<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥量的类型 pthread_mutex_t</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">//初始化互斥量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;<span class="comment">//释放互斥量的资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;<span class="comment">//加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;<span class="comment">//尝试加锁，如果加锁失败，不会阻塞，会直接返回。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;<span class="comment">//解锁</span></span><br></pre></td></tr></table></figure></p><p>参数 ：</p><blockquote><p>mutex ： 需要初始化的互斥量变量<br>attr ： 互斥量相关的属性，NULL<br>restrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。<br>pthread_mutex_t <em>restrict mutex = xxx;<br>pthread_mutex_t </em> mutex1 = mutex;//用mutex1指向mutex,不可以执行操作，因为被restrict限制</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，所有的线程都共享这一份资源。</span></span><br><span class="line"><span class="keyword">int</span> tickets = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">sellticket</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卖票</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加锁</span></span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            usleep(<span class="number">6000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%ld 正在卖第 %d 张门票\n&quot;</span>, pthread_self(), tickets);</span><br><span class="line">            tickets--;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 解锁</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化互斥量</span></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建3个子线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2, tid3;</span><br><span class="line">    pthread_create(&amp;tid1, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid2, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;tid3, <span class="literal">NULL</span>, sellticket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回收子线程的资源,阻塞</span></span><br><span class="line">    pthread_join(tid1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid2, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(tid3, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 退出主线程</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放互斥量资源</span></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。<br>两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，<strong>若无外力作用，它们都将无法推进下去。</strong>此时称系统处于死锁状态或系统产生了死锁。</p><p>死锁的几种场景：</p><ol><li>忘记释放锁</li><li>重复加锁</li><li>多线程多锁，抢占锁资源</li></ol><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。<br>在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前<strong>能够允许多个读出，但只允许一个写入</strong>的需求，线程提供了读写锁来实现。</p><p>读写锁的特点：</p><ol><li>如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。</li><li>如果有其它线程写数据，则其它线程都不允许读、写操作。</li><li>写是独占的，写的优先级高</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">读写锁的类型 <span class="function"><span class="keyword">pthread_rwlock_t</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">producer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        usleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否有数据</span></span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 有数据</span></span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            usleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有数据</span></span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量的类型 sem_t<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;  <span class="comment">//初始化信号量  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;<span class="comment">//释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">//对信号量加锁，调用一次对信号量的值-1，如果大于0，立刻返回，如果值为0，就阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_timedwait</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">const</span> struct timespec *abs_timeout)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line"><span class="comment">//对信号量解锁，调用一次对信号量的值+1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> *sval)</span></span>;</span><br></pre></td></tr></table></figure></p><p>参数：</p><blockquote><p>sem : 信号量变量的地址<br>pshared : 0 用在线程间 ，非0 用在进程间<br>value : 信号量中的值</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="keyword">sem_t</span> psem;</span><br><span class="line"><span class="keyword">sem_t</span> csem;</span><br><span class="line">init(psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">init(csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">producer() &#123;</span><br><span class="line">    sem_wait(&amp;psem);</span><br><span class="line">    sem_post(&amp;csem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customer() &#123;</span><br><span class="line">    sem_wait(&amp;csem);</span><br><span class="line">    sem_post(&amp;psem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个互斥量</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="comment">// 创建两个信号量</span></span><br><span class="line"><span class="keyword">sem_t</span> psem;</span><br><span class="line"><span class="keyword">sem_t</span> csem;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 头结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">head</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">producer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不断的创建新的节点，添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;psem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">newNode</span> =</span> (struct Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct Node));</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">        newNode-&gt;num = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;add node, num : %d, tid : %ld\n&quot;</span>, newNode-&gt;num, pthread_self());</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;csem);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">customer</span><span class="params">(<span class="keyword">void</span> * arg)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;csem);</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="comment">// 保存头结点的指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">tmp</span> =</span> head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;del node, num : %d, tid : %ld\n&quot;</span>, tmp-&gt;num, pthread_self());</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">        sem_post(&amp;psem);</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>);</span><br><span class="line">    sem_init(&amp;psem, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    sem_init(&amp;csem, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建5个生产者线程，和5个消费者线程</span></span><br><span class="line">    <span class="keyword">pthread_t</span> ptids[<span class="number">5</span>], ctids[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_create(&amp;ptids[i], <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">        pthread_create(&amp;ctids[i], <span class="literal">NULL</span>, customer, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        pthread_detach(ptids[i]);</span><br><span class="line">        pthread_detach(ctids[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录牛客项目</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux项目2</title>
    <link href="http://example.com/2022/12/16/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE2/"/>
    <id>http://example.com/2022/12/16/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE2/</id>
    <published>2022-12-15T16:00:00.000Z</published>
    <updated>2023-01-01T05:32:34.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><ol><li>进程状态转换</li><li>进程创建fork，exec函数族</li><li>孤儿进程，僵尸进程，解决方法：wait,waitpid</li><li>进程间通信方式：管道，内存映射，信号</li><li>守护进程<h1 id="进程概述"><a href="#进程概述" class="headerlink" title="进程概述"></a>进程概述</h1><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2>程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程：</li><li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式）</li><li>机器语言指令：对程序算法进行编码。</li><li>程序入口地址：标识程序开始执行时的起始指令位置。</li><li>数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。</li><li>符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。</li><li>共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。</li><li>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</li></ol><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。<strong>程序不占用系统CPU，内存等资源，进程需要占用</strong></p><p>可以用一个程序来创建多个进程，进程是由内核定义的<strong>抽象实体</strong>，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p><h2 id="单道-amp-多道程序设计"><a href="#单道-amp-多道程序设计" class="headerlink" title="单道&amp;多道程序设计"></a>单道&amp;多道程序设计</h2><p>单道程序，即在计算机内存中只允许一个的程序运行。<br>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，<strong>相互穿插运行（宏观上是同时进行的，但实际上每个时刻只能有一个程序在执行）</strong>，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</p><p>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。<br>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</p><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>进程状态反映执行过的变化。 这些随着和外界条件而转换进程状态反映执行过的变化。<br>三态模型：就绪态，运行态，阻塞态。<br>五态模型：新建态、就绪态，运行态，阻塞态，终止态。</p><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20221216162857.png" alt=""></p><p>阻塞态不能直接转换到就绪态，和其他进程抢夺资源再进入运行态</p><p>图中没有画出，但就绪态和阻塞态可以直接到达终止态，进入终止态之后就不能再执行了，会释放用户区的数据</p><p>查看进程信息命令：</p><blockquote><p>ps ajx/aux<br>PID进程ID,PPID父进程ID，PGID组ID，SID会话ID</p></blockquote><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>进程可以创建新进程，形成进程树<br>打开的终端自身也是一个进程，父进程和子进程是交替运行的<br>子进程会复制父进程的虚拟地址空间，实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。<br>写时拷贝是一种可以推迟甚至避免拷贝数据的技术。<br>内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。<br><strong>只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</strong><br>也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。<br>注意：fork之后父子进程共享文件，<br>fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">pid_t fork(void);</span></span><br><span class="line"><span class="comment">作用：创建一个子进程</span></span><br><span class="line"><span class="comment">返回值：返回两次，一次在父进程，一次在子进程</span></span><br><span class="line"><span class="comment">在父进程中，成功：返回子进程的ID，失败：返回-1，设置errno为EAGAIN（进程数达到上限）或ENOME（没有内存）</span></span><br><span class="line"><span class="comment">在子进程中，成功：返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="comment">//子进程仅执行该行代码之后的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;pid : %d\n&quot;, pid);</span></span><br><span class="line">        <span class="comment">// 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, getpid(), getppid());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num += 10 : %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, getpid(),getppid());</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num += 100 : %d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , getpid());</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父子进程之间的关系"><a href="#父子进程之间的关系" class="headerlink" title="父子进程之间的关系"></a>父子进程之间的关系</h3><p>区别：<br>    1.fork()函数的返回值不同<br>        父进程中: &gt;0 返回的子进程的ID<br>        子进程中: =0<br>    2.pcb中的一些数据<br>        当前的进程的id pid<br>        当前的进程的父进程的id ppid<br>        信号集</p><p>共同点：<br>    某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</p><pre><code>    - 用户区的数据    - 文件描述符表</code></pre><p>父子进程对变量是不是共享的？</p><pre><code>- 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。- 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</code></pre><h2 id="有名管道（FIFO）"><a href="#有名管道（FIFO）" class="headerlink" title="有名管道（FIFO）"></a>有名管道（FIFO）</h2><p>匿名管道由于没有名字，因此只能用于亲缘关系的进程间通信</p><h2 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h2><p>将硬件中的物理位置映射到内存中，实现通信<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line">mmap,munmap</span><br></pre></td></tr></table></figure><br>void <em>mmap(void </em>addr, size_t length, int prot, int flags,int fd, off_t offset);<br>功能：将一个文件或者设备的数据映射到内存中<br>参数：</p><blockquote><p>void *addr: NULL, 由内核指定，指映射到内核中的地址<br>length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。（获取文件的长度：stat lseek）<br>prot : 对申请的内存映射区的操作权限</p><ol><li>PROT_EXEC ：可执行的权限</li><li>PROT_READ ：读权限</li><li>PROT_WRITE ：写权限</li><li>PROT_NONE ：没有权限<br>要操作映射内存，<strong>必须要有读的权限。</strong>PROT_READ（读）、PROT_READ|PROT_WRITE（读写）</li></ol><p>flags :</p><ol><li>MAP_SHARED : <strong>映射区的数据会自动和磁盘文件进行同步</strong>，进程间通信，必须要设置这个选项</li><li>MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建</li></ol><p>fd: 需要映射的那个文件的文件描述符，通过open得到，open的是一个磁盘文件<br>注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。<strong>prot的权限必须小于open的权限，且必须有read权限</strong><br>prot: PROT_READ, open:只读/读写<br>prot: PROT_READ | PROT_WRITE, open:读写</p><p>offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移。</p></blockquote><p>返回值：</p><blockquote><p>返回创建的内存的首地址<br>失败返回MAP_FAILED，(void *) -1</p></blockquote><p>int munmap(void *addr, size_t length);<br>功能：释放内存映射<br>参数：</p><blockquote><p>addr : 要释放的内存的首地址<br>length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。</p></blockquote><p>使用内存映射实现进程间通信：</p><ol><li><p>有关系的进程（父子进程）<br>还没有子进程的时候：通过唯一的父进程，先创建内存映射区<br>有了内存映射区以后，创建子进程：父子进程共享创建的内存映射区</p></li><li><p>没有关系的进程间通信<br>准备一个大小不是0的磁盘文件<br>进程1 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针<br>进程2 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针，使用内存映射区通信</p></li></ol><p>注意：内存映射区通信，是非阻塞。</p><h2 id="设置定时器setitimer"><a href="#设置定时器setitimer" class="headerlink" title="设置定时器setitimer"></a>设置定时器setitimer</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">include &lt;sys/time.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *new_value,struct itimerval *old_value)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：</p><blockquote><p>设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时<br>参数：<br>which : 定时器以什么时间计时</p><ol><li>ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM   常用</li><li>ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM</li><li>ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF</li></ol><p>new_value: 设置定时器的属性<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span>      <span class="comment">// 定时器的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span>  <span class="comment">// 每个阶段的时间，间隔时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>     <span class="comment">// 延迟多长时间执行定时器</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span>        <span class="comment">// 时间的结构体</span></span><br><span class="line">    <span class="keyword">time_t</span>      tv_sec;     <span class="comment">//  秒数     </span></span><br><span class="line">    <span class="keyword">suseconds_t</span> tv_usec;    <span class="comment">//  微秒    </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>过10秒后，每个2秒定时一次<br>old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL</p></blockquote><p>返回值：</p><blockquote><p>成功 0<br>失败 -1 并设置错误号</p></blockquote><h2 id="捕捉信号"><a href="#捕捉信号" class="headerlink" title="捕捉信号"></a>捕捉信号</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure><p>功能：设置某个信号的捕捉行为，<strong>SIGKILL SIGSTOP不能被捕捉，不能被忽略。</strong><br>参数：</p><blockquote><p>signum: 要捕捉的信号,一般使用宏值<br>handler: 捕捉到信号要如何处理</p><ol><li>SIG_IGN ： 忽略信号</li><li>SIG_DFL ： 使用信号默认的行为</li><li>回调函数 :  这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。<ol><li>需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义</li><li>不是程序员调用，而是当信号产生，由内核调用</li><li>函数指针是实现回调的手段，函数实现之后，<strong>将函数名放到函数指针的位置就可以了。</strong></li></ol></li></ol></blockquote><p>返回值：</p><blockquote><p>成功，返回上一次注册的信号处理函数的地址。（sighandler_t）类型第一次调用返回NULL<br>失败，返回SIG_ERR，设置错误号</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myalarm</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;捕捉到了信号的编号是：%d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xxxxxxx\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 过3秒以后，每隔2秒钟定时一次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册信号捕捉</span></span><br><span class="line">    <span class="comment">// signal(SIGALRM, SIG_IGN);</span></span><br><span class="line">    <span class="comment">// signal(SIGALRM, SIG_DFL);</span></span><br><span class="line">    <span class="comment">// void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。</span></span><br><span class="line">    signal(SIGALRM, myalarm);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置间隔的时间</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置延迟的时间,3秒之后开始第一次定时</span></span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">3</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>); <span class="comment">// 非阻塞的</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;定时器开始了...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;setitimer&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号集和相关函数"><a href="#信号集和相关函数" class="headerlink" title="信号集和相关函数"></a>信号集和相关函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li><p>用户通过键盘  Ctrl + C, 产生2号信号SIGINT (信号被创建)</p></li><li><p>信号产生但是没有被处理 （未决）<br>在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）<br>SIGINT信号状态被存储在第二个标志位上<br>这个标志位的值为0， 说明信号不是未决状态<br>这个<strong>标志位的值为1， 说明信号处于未决状态</strong></p></li><li><p>这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较<br>阻塞信号集默认不阻塞任何的信号，如果想要阻塞某些信号需要用户调用系统的API</p></li><li><p>在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了<br>如果没有阻塞，这个信号就被处理<br><strong>如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理</strong></p></li></ol><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>以下信号集相关的函数<strong>都是对自定义的信号集进行操作</strong>。</p><p>int sigemptyset(sigset_t <em>set);<br>int sigfillset(sigset_t </em>set);</p><blockquote><p>功能：<br>将信号集中的所有的标志位置为0(sigemptyset)<br>将信号集中的所有的标志位置为1(sigfillset)<br>参数：set, 传出参数，需要操作的信号集<br>返回值：成功返回0， 失败返回-1</p></blockquote><p>int sigaddset(sigset_t <em>set, int signum);<br>int sigdelset(sigset_t </em>set, int signum);</p><blockquote><p>功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号<br>参数：<br>set：传出参数，需要操作的信号集<br>signum：<br>需要设置阻塞的那个信号(sigaddset)<br>需要设置不阻塞的那个信号(sigdelset)<br>返回值：成功返回0， 失败返回-1</p></blockquote><p>int sigismember(const sigset_t *set, int signum);</p><blockquote><p>功能：判断某个信号是否阻塞<br>参数：<br>set：需要操作的信号集<br>signum：需要判断的那个信号<br>返回值：<br>    1 ： signum被阻塞<br>    0 ： signum不阻塞<br>    -1 ： 失败</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个信号集</span></span><br><span class="line">    <span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空信号集的内容</span></span><br><span class="line">    sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 SIGINT 是否在信号集 set 里</span></span><br><span class="line">    <span class="keyword">int</span> ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加几个信号到信号集中</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGINT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGINT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从信号集中删除一个信号</span></span><br><span class="line">    sigdelset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断SIGQUIT是否在信号集中</span></span><br><span class="line">    ret = sigismember(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">    <span class="keyword">if</span>(ret == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 不阻塞\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;SIGQUIT 阻塞\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int sigprocmask(int how, const sigset_t <em>set, sigset_t </em>oldset);</p><blockquote><p>功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）<br>参数：<br>how : 如何对内核阻塞信号集进行处理</p><ol><li>SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变 假设内核中默认的阻塞信号集是mask， 这个操作相当于 <strong>mask = mask | set</strong>(set中需要设置<strong>阻塞的信号位设置为1</strong>)</li><li>SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞，相当于<strong>mask = mask &amp;= ~set</strong>(set中需要设置<strong>解除阻塞的信号位设置为1</strong>) </li><li>SIG_SETMASK:覆盖内核中原来的值</li></ol><p>set ：已经初始化好的用户自定义的信号集<br>oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL<br>返回值：成功：0,失败：-1,设置错误号：EFAULT、EINVAL</p></blockquote><p>int sigpending(sigset_t *set);</p><blockquote><p>功能：获取内核中的未决信号集<br>参数：set,传出参数，保存的是内核中的未决信号集中的信息。</p></blockquote><h2 id="sigaction"><a href="#sigaction" class="headerlink" title="sigaction"></a>sigaction</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);</span><br></pre></td></tr></table></figure><p>功能：检查或者改变信号的处理。信号捕捉<br>参数：</p><blockquote><p>signum : 需要捕捉的信号的编号或者宏值（信号的名称）<br>act ：捕捉到信号之后的处理动作<br>oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL</p></blockquote><p>返回值：成功 0, 失败 -1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="comment">// 函数指针，指向的函数就是信号捕捉到之后的处理函数</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">// 不常用</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="comment">// 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。</span></span><br><span class="line">    <span class="keyword">sigset_t</span>   sa_mask;</span><br><span class="line">    <span class="comment">// 使用哪一个信号处理对捕捉到的信号进行处理</span></span><br><span class="line">    <span class="comment">// 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction</span></span><br><span class="line">    <span class="keyword">int</span>        sa_flags;</span><br><span class="line">    <span class="comment">// 被废弃掉了</span></span><br><span class="line">    <span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h2><p>SIGCHLD信号产生的3个条件：</p><ol><li>子进程结束</li><li>子进程暂停了</li><li>子进程继续运行<br>都会给父进程发送该信号，父进程默认忽略该信号。<br>使用SIGCHLD信号解决<strong>僵尸进程</strong>的问题</li></ol><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>允许两个或多个进程共享物理内存中同一块区域，<strong>只需内核介入，效率更高</strong>，和管道，内存映射比更快。因为管道和内存映射都需要用户和内核之间的切换和数据拷贝。</p><h3 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h3><ol><li>调用shmget()创建一个新的共享内存段或取得一个现有的共享内存段的标识符。这个调用返回需要用到的共享内存标识符。</li><li>使用shmat()来附上共享内存段，使该段成为调用进程的虚拟内存的一部分。即，将上述共享内存段与进程绑定，可以通过进程的虚拟内存访问该共享内存段。</li><li>此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，<br>程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间<br>中该共享内存段的起点的指针。</li><li>调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在<strong>进程终止时会自动完成这一步</strong>。</li><li>调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。<strong>只有一个进程需要执行这一步。</strong></li></ol><h3 id="操作函数"><a href="#操作函数" class="headerlink" title="操作函数"></a>操作函数</h3><h4 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h4><p>shmget(key_t key, size_t size, int shmflg);<br>功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。新创建的内存段中的数据都会被初始化为0<br>参数：</p><blockquote><p>key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。一般使用16进制表示，非0值<br>size: 共享内存的大小<br>shmflg: 属性</p><ol><li>访问权限</li><li>附加属性：创建/判断共享内存是不是存在<ol><li>创建：IPC_CREAT</li><li>判断共享内存是否存在：IPC_EXCL , 需要和IPC_CREAT一起使用(IPC_CREAT | IPC_EXCL | 0664）即先判断，不存在的时候创建</li></ol></li></ol></blockquote><p>返回值：失败：-1 并设置错误号, 成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。</p><h4 id="shmat"><a href="#shmat" class="headerlink" title="shmat"></a>shmat</h4><p>void <em>shmat(int shmid, const void </em>shmaddr, int shmflg);<br>功能：和当前的进程进行关联<br>参数：</p><blockquote><p>shmid : 共享内存的标识（ID）,由shmget返回值获取<br>shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定<br>shmflg : 对共享内存的操作</p><ol><li>读 ： SHM_RDONLY, <strong>必须要有读权限</strong></li><li>读写： 0，即默认有读写权限</li></ol></blockquote><p>返回值：成功：返回共享内存的首（起始）地址。  失败(void *) -1</p><h4 id="shmdt"><a href="#shmdt" class="headerlink" title="shmdt"></a>shmdt</h4><p>int shmdt(const void *shmaddr);</p><blockquote><p>功能：解除当前进程和共享内存的关联<br>参数：shmaddr：共享内存的首地址<br>返回值：成功 0， 失败 -1</p></blockquote><h4 id="shmctl"><a href="#shmctl" class="headerlink" title="shmctl"></a>shmctl</h4><p>int shmctl(int shmid, int cmd, struct shmid_ds *buf);<br>功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。<br>参数：</p><blockquote><p>shmid: 共享内存的ID<br>cmd : 要做的操作</p><ol><li>IPC_STAT : 获取共享内存的当前的状态</li><li>IPC_SET : 设置共享内存的状态</li><li>IPC_RMID: 标记共享内存被销毁</li></ol><p>buf：需要设置或者获取的共享内存的属性信息</p><ol><li>IPC_STAT : buf存储数据</li><li>IPC_SET : buf中需要初始化数据，设置到内核中</li><li>IPC_RMID : 没有用，NULL</li></ol></blockquote><h4 id="key-t-ftok"><a href="#key-t-ftok" class="headerlink" title="key_t ftok"></a>key_t ftok</h4><p>key_t ftok(const char *pathname, int proj_id);<br>功能：根据指定的路径名，和int值，生成一个共享内存的key<br>参数：</p><blockquote><p>pathname:指定一个存在的路径:/home/nowcoder/Linux/a.txt/<br>proj_id: int类型的值，但是这系统调用只会使用其中的1个字节<br>范围 ： 0-255  一般指定一个字符 ‘a’</p></blockquote><p>read.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.获取一个共享内存,第二个参数可以写0，表示是获取而不是创建一个</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">0</span>, IPC_CREAT);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.读数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="keyword">char</span> *)ptr);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>write.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建一个共享内存</span></span><br><span class="line">    <span class="keyword">int</span> shmid = shmget(<span class="number">100</span>, <span class="number">4096</span>, IPC_CREAT|<span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;shmid : %d\n&quot;</span>, shmid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.和当前进程进行关联</span></span><br><span class="line">    <span class="keyword">void</span> * ptr = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> * str = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.写数据,+1是拷贝字符串结束符</span></span><br><span class="line">    <span class="built_in">memcpy</span>(ptr, str, <span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;按任意键继续\n&quot;</span>);</span><br><span class="line">    getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解除关联</span></span><br><span class="line">    shmdt(ptr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.删除共享内存</span></span><br><span class="line">    shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h4><p>问题1：操作系统如何知道一块共享内存被多少个进程关联？</p><blockquote><p>共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattch<br>shm_nattach 记录了关联的进程个数</p></blockquote><p>问题2：可不可以对共享内存进行多次删除 shmctl</p><blockquote><p>可以的<br>因为shmctl 标记删除共享内存，不是直接删除<br>什么时候真正删除呢?<br>当和共享内存关联的进程数为0的时候，就真正被删除<br>当共享内存的key为0的时候，表示共享内存被标记删除了<br>如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。</p></blockquote><p>共享内存和内存映射的区别</p><blockquote><ol><li>共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）</li><li>共享内存效果更高</li><li>内存<br>所有的进程操作的是同一块共享内存。<br>内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。</li><li>数据安全<br>进程突然退出:共享内存还存在,内存映射区消失<br>运行进程的电脑死机，宕机了:数据存在在共享内存中，没有了,内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。</li><li>生命周期<br>内存映射区：进程退出，内存映射区销毁<br>共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机<br>如果一个进程退出，会自动和共享内存进行取消关联。</li></ol></blockquote><h2 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h2>]]></content>
    
    
    <summary type="html">记录牛客项目</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux项目</title>
    <link href="http://example.com/2022/12/14/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2022/12/14/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE/</id>
    <published>2022-12-13T16:00:00.000Z</published>
    <updated>2023-01-01T05:28:14.787Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><ol><li>静态库和动态库的区别，使用</li><li>GDB多进程，多线程调试，Makefile</li><li>虚拟地址空间，文件描述符</li><li>系统API，open,read,lseek等</li><li>dup,dup2,fcntl<h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1>cp file1 path 复制文件到指定路径，如果是目录，不能直接复制，要加上 -r<br>mkdir生成文件夹<br>rm删除，可以通过*实现条件删除<br>mv 移动文件或重命名文件<h1 id="GCC工作流程"><a href="#GCC工作流程" class="headerlink" title="GCC工作流程"></a>GCC工作流程</h1><img src="https://img-blog.csdnimg.cn/e508ddda911c49188cd96505fbfad076.png#pic_center" alt="在这里插入图片描述"></li></ol><p>从源代码生成可执行程序的过程，需经历 4 个过程，分别是预处理、编译、汇编和链接。</p><ol><li>预处理包括导入头文件，并对相应函数进行复制，宏定义等进行替换，去掉注释</li><li>编译生成汇编代码</li><li>汇编后生成机器可识别的代码，其本质为二进制文件，但由于尚未经过链接操作，所以无法直接运行。</li><li>连接就是将同一项目中各源文件生成的目标文件以及程序中用到的库文件整合为一个可执行文件。<br>通过使用以下命令实现每个过程。<br><img src="https://img-blog.csdnimg.cn/5471f15c28894f09952eec285c185479.jpeg#pic_center" alt="在这里插入图片描述"><br>但是<strong>可以跳过一些步骤</strong>，如可以直接通过-c，实现预处理，编译和汇编，直接从源代码生成目标代码。实际使用时并不关心这些流程，因此可以直接通过gcc或g++,从源代码生成可执行程序（用gcc编译C，g++编译C++程序）如果不通过-o指定输出文件名，默认生成a.out。<br>指定宏，可以用于控制调试时输出，发布时不输出某些信息。<br><img src="https://img-blog.csdnimg.cn/876936c266254920a4a9e8f48b124738.png#pic_center" alt="在这里插入图片描述"><h1 id="库"><a href="#库" class="headerlink" title="库"></a>库</h1>静态库在连接阶段被复制到程序中<br>动态库在运行时由系统动态加载到内存中供程序调用。<br>优势：代码保密（C++程序反编译之后，还原程度很低），方便部署和分发。<h2 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h2></li><li>首先将源文件通过gcc -c 生成.o文件</li><li>将.o文件打包，使用ar工具<br>Linux：<strong>libxxx.a</strong>前缀lib和后缀.a是固定的，Windows的后缀是lib,一定记得加.a和.o的后缀<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a xxx.o xxx.o</span><br></pre></td></tr></table></figure>注意<strong>静态库的名称是xxx，不需要包含lib</strong><br>3.编译用到静态库的代码，注意静态库需要有一个头文件.h（指明了静态库中的函数名称和参数类型）配合使用。<br>假设现有如下文件结构<blockquote><p>├── include<br>│   └── head.h<br>├── lib<br>│   └── libjisuan<br>├── main.c<br>└── src<br> ├── add.c<br> ├── add.o<br> ├── div.c<br> ├── div.o<br> ├── libjisuan.a<br> ├── mult.c<br> ├── mult.o<br> ├── sub.c<br> └── sub.o</p></blockquote></li></ol><p>我们需要编译main.c使用如下指令，其中-I指明了头文件head.h位于./include目录下，-L指定了搜索库的路径为./src -l指定库的名称，是<strong>jisuan而不是libjisuan</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -I ./include -L ./src -l jisuan</span><br></pre></td></tr></table></figure><br>然后执行即可，执行的时候不需要用gcc</p><h2 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h2><p>Linux：<strong>libxxx.so</strong>前缀lib和后缀.so是固定的，Windows的后缀是dll<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c -fpic/-fPIC  a.c b.c //得到和位置无关的代码</span><br><span class="line">gcc - shared a.o b.o -o libcalc.so //得到动态库</span><br></pre></td></tr></table></figure></p><h1 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h1><p>自定义变量：<br>变量名= 变量值，用$（变量名）获取变量值<br>预定义变量：<br>AR 归档维护程序的名称，默认值ar<br>CC C编译器的名称，默认值cc<br>CXX：C++编辑器的名称<br>$@:目标的完整名称<br>$&lt;:第一个依赖文件<br>$^:所有依赖文件</p><p>$(wildcard PATTERN…)<br>如 $(wildcard <em>.c ./sub/ </em>.c)<br>获取当前目录下的.c文件和sub目录下 的.c文件都返回，多个目录用空格隔开</p><p>$(patsubst &lt; pattern &gt;, &lt; replacement &gt;, &lt; &gt;)</p><h1 id="GDB测试"><a href="#GDB测试" class="headerlink" title="GDB测试"></a>GDB测试</h1><p>通常，在为调试而编译时，我们会(）关掉编译器的优化选项（<code>-o</code>)，并打开调试选项(<code>-g</code>)。另外， ‘-wall`在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的 BUG。<br>输出时加上-g调试，在可执行文件中加入源代码信息</p><blockquote><p>gcc -g -wall program.c -o program</p></blockquote><p>‘-g’选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。</p><ol><li>启动与退出<br>gdb 可执行程序<br>quit</li><li>给程序设置参数/获取设置参数<br>set args 10 20<br>show args</li><li>使用帮助<br>help</li><li>查看文件<br>set nu 显示代码行号</li><li>查看当前文件<ol><li>list/简写l 显示代码，一次显示10行，如果有main函数，main函数在中间</li><li>list/l 行号/函数名 显示该行/该函数上下几行的代码</li></ol></li><li>查看非当前文件<ol><li>list/l 文件名：行号</li><li>list/l 文件名：函数名</li></ol></li><li>查看并设置每次查看多少代码<ol><li>查看 show list/listsize</li><li>设置set list/listsize 行数</li></ol></li><li>设置断点</li><li>调试命令<ol><li>n  不会进入函数体,s/step会进入函数体 </li></ol></li></ol><h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><p>从内存角度来看：<br>输入：从文件中读入数据，输出：将内存中数据写入文件<br>标准C库是可以跨平台使用的，库在封装的时候针对不同平台采用不用平台各自的API<br>即标准C库通过调用LINUX的API实现调用</p><p>fopen返回FILE *fp 文件指针<br>包含3个部分：</p><ol><li>文件描述符（整形）</li><li>文件读写指针位置</li><li>I/O缓冲区（内存地址），提高执行效率，修改先保存到缓冲区，通过缓冲区（默认8192byte）写入磁盘，避免频繁写入磁盘，而LINUX本身的API没有缓冲区，效率低，但实时性高。</li></ol><p>文件描述符表是一个数组，用于管理打开的多个文件<br>大小默认是1024，每个进程都有一个文件描述符表，即一个进程最多可以同时打开1021个文件，其前3个位置是被占用的（标准输入，输出，错误），对应当前设备终端<br>同一文件可以被打开多次，如果不释放，再打开，则同一个文件会占用不同的文件描述符<br>LINUX会把所有东西都变成一个文件，包括设备等也会虚拟为一个文件，</p><h1 id="Linux系统IO函数"><a href="#Linux系统IO函数" class="headerlink" title="Linux系统IO函数"></a>Linux系统IO函数</h1><p>int open(const char <em>pathname, int flags);<br>int open(const char </em>pathname, int flags,mode_t mode);<br>参数：</p><blockquote><p>pathname：要打开的文件路径<br>flags: O_RDONLY（只读），O_WRONLY（只写），O_RDWR（可读写）</p></blockquote><p>返回值：</p><blockquote><p>成功：返回实际读取到的字节数，&gt;0表示实际读取到的字节数，=0表示文件读取完了<br>失败：返回-1，设置errno<br>int close(int fd);</p></blockquote><p><strong>ssize_t read(int fd,void *buf,size_t count);</strong><br>参数：</p><blockquote><p>fd：文件描述符，open得到<br>buf：缓冲区，存放读取到的数据的地方，数组的地址<br>count: 指定的数组的大小</p></blockquote><p>返回值：</p><blockquote><p>成功：返回实际读取到的字节数，&gt;0表示实际读取到的字节数，=0表示文件读取完了<br>失败：返回-1，设置errno</p></blockquote><p>ssize_t write(int fd,const void *buf,size_t count);<br>参数：</p><blockquote><p>fd：文件描述符，open得到<br>buf：要写入的数据<br>count: 要写的数据的实际大小</p></blockquote><p>返回值：</p><blockquote><p>成功：写入字节数<br>失败：返回-1，设置errno</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//打开源文件</span></span><br><span class="line">    <span class="keyword">int</span> srcfd = open(<span class="string">&quot;english.txt&quot;</span>,O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span>(srcfd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建目标文件并打开</span></span><br><span class="line">    <span class="keyword">int</span> desfd = open(<span class="string">&quot;cpy.txt&quot;</span>,O_WRONLY|O_CREAT ,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(srcfd==<span class="number">-1</span>)&#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);<span class="comment">//只是人为定义的描述</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//读取源文件，存放在buf数组中</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((len = read(srcfd,buf,<span class="keyword">sizeof</span>(buf)))&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//将buf中的内容写入目标文件，当len=0表示读取完了</span></span><br><span class="line">        write(desfd,buf,len);</span><br><span class="line">    &#125;</span><br><span class="line">    close(desfd);</span><br><span class="line">    close(srcfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录牛客项目</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="http://example.com/2022/06/30/%E9%9A%8F%E7%AC%94/"/>
    <id>http://example.com/2022/06/30/%E9%9A%8F%E7%AC%94/</id>
    <published>2022-06-29T16:00:00.000Z</published>
    <updated>2022-06-30T08:19:31.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="祝我自己健健康康"><a href="#祝我自己健健康康" class="headerlink" title="祝我自己健健康康"></a>祝我自己健健康康</h1><p><em>/2019.9.8，转自QQ空间日志/</em><br>我也不知道怎么说，也不能说是突然想写一篇日志，其实也想好久了，但是不知道怎么开头，也不知道自己到底要写什么，就连打开写日志这个窗口都感觉要比写说说要复杂很多，只是觉得可能自己有很多话要说，所以就想写一篇长长的东西，时间过得真么快啊，就已经20了，完全没想到当年从九岁变成十岁，如今从19变成20会过得这么快。</p><p>其实想写这些的原因就是因为暑假的时候做了人生中的第一次手术，为什么说是第一次，而不是第一个呢？因为一次就做了五个，可能我也没跟很多人说啦，但是就自己身体出现了一些问题，虽然都不是什么特别大的事情，但是就做手术本身也算是件大事，或多或少对自己的心态上会产生一些触动，也因为做了手术之后无所事事的一个暑假，我也有机会开始仔细去想自己的一些事情。</p><p>20岁于我而言是一个比较尴尬的年龄吧，很多事情也想不明白，没有到而立之年，但是也永远不可能像一个十岁的孩子一样去拒绝去想一些即将发生的事情，就好比我现在已经大三，但是我似乎对自己的未来没有什么特别明确的规划，当我遇到一件我自己不懂的事情，我还是去想我要不要去问一下别人，然后别人给我的答案，好像总感觉还是那么的模糊，我对许多事情还是得不到一个确切的说法。 就好比虽然已经学了两年的机械，但是我好像还是回答不了“你这个专业将来是做什么的”这个问题。我看到周围的同学都在忙，我不知道他们在忙什么，感觉全世界好像只有自己不知道该干什么，在过去的两年，我体验了自己想去体验的事情，但是总有一些事情就我不知道怎么去下手，我或许想做或不想做我自己也说不清楚，<strong>我不再像十几岁的时候那样，对一件事有很高的热情，好像现在所有的事情对我来说就都是那种。嗯，还行，可以吧，没有一个很确切的态度，也没有一个很明确的情绪。</strong></p><p>前段时间我去看过一次心理医生，说是中度抑郁，可是我感觉我过的还行，只是好像到了一个也不算成熟，但是总觉得到了一个对什么都没有了好奇心的状态，这可能就是所谓的变老了吧表情我发现我开始很在意我的家人，会好奇自己前两年是怎么做到一个月可以不跟家里打一个电话的那种状态，也因为这种在意，我会在这个暑假里跟他们走的格外的近，我发现其实我弟现在十岁，也是从九岁到十岁这个十位数要发生改变的年龄，他好像还有很多事情是希望被我知道，但是我之前都没有关注到的，我会跟他聊很多，很多之前我可能不太感兴趣的东西，然后我才知道很多事情和我想的也不一样，他也有他自己的问题和烦恼，我就在好奇，十年前我自己是什么样子？我原以为小孩子都是那种没心没肺的，天天很快乐的样子，但是当我弟很严肃的跟我说起一些关于自己的事情的时候，我会发现好像也没我想象的那么简单，我也会跟我妈聊，我发现成年人的世界真的很复杂，好多从理论上来讲，不会发生争执的事情，倒引发了很大很大的问题，好多，我以为那不明摆的事情吗？但是人们就是不愿意那么做，我会在逛超市的时候，留意那些我不认识的人们的一举一动，他们的语言，他们的一些小动作，好像每个人都有自己的故事，我有时候可以什么都不干，一下午在那里胡思乱想，会开始在意自己的身体健康，甚至可以熟练的说出来十几种几年前可能完全没有听说过的病的名字，会开始不着边际的想一些可能十年20年甚至更久之后可能会发生的一些事情，对很多事变得很佛，很养生，反倒越想越迷茫。算了，就这样吧，明天就是新学期的第一天了，虽然自己其实已经搞了两个星期课设了。</p><p>嗯，可能也是因为这个原因，对新学期提不起来什么兴趣，总觉得要放假的一样，因为不知道未来要走向何方，所以也没什么动力和方向，只想简简单单，然后emmm祝家人身体健康<br>愿我十年之后，能……</p><p>emmm算了，我不想给自己什么承诺</p><p>语音转文字的结果，就是没有逻辑也可以写很多东西</p><blockquote><p>2022.6.30注：其实过了三年来看三年前，应该是大二暑假的这个日志的话，还是多少有些心酸吧，那个时候的心境还是会和现在有很大不同，不过突出的一点就是对于未来的迷茫感，我不是那种会计划很长久的人，本着走一步看一步的想法，应该也是因为如此，所以才会迷茫吧，王天磊跟我聊未来的时候，我会羡慕，他想的好远，想的好周全，可是有些事情，尤其是个人对生活的态度这种事，其实很难改变的，只能说，找点事来做吧，热爱可抵岁月漫长，找不到热爱，只能说，那就收集点面包吧。</p></blockquote><h1 id="迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪"><a href="#迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪" class="headerlink" title="迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪"></a>迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪</h1><p>/<em>2022.6.30</em>/</p><blockquote><p>一切从研究生开始的时候说起</p></blockquote><h2 id="幻想回不去的过去"><a href="#幻想回不去的过去" class="headerlink" title="幻想回不去的过去"></a>幻想回不去的过去</h2><p>一年过去了，其实给人最大的感觉就是很迷茫，突然就没了目标一样，好在学校不宜久居，缺乏生活气息的环境帮我果断打消了读博的念头，当然还有一个原因是老师确实没有给出一个切实可行的研究计划，所以，眼下摆在面前的似乎只有毕业工作这条路。<br>迷茫，是因为不知道自己要做什么才能毕业，好像每天都在学些东西，看些论文，但是说实话每天的有效学习时间并不长，印象里自己也不是那种坐不住的人，只是缺少一个明确的任务，所以从这点上来说，或许工作了会好一些吧，我常这样安慰自己。偶尔可能会有一两天，突然觉得未来可期，可能是找到了一段觉得还不错的视频，或者有了一点点想法，然后，努力几天后，就又没了下午，我属于那种情绪来的特别快，去的也特别快的人，当然负面情绪好像去的并不快，所以，三分钟热度算是很确切的一种说法，我常常会在周一定好计划，说自己这周开始要早睡，然后，在某天晚上没有早睡之后，就放弃，更多的时候，当我刻意想要早睡的时候，却总是睡不着，脑子里想的最多的，是假如我能回到过去，诸如：<br>假如我能回到过去，我会毫不犹豫的转专业，学个计算机，或者至少不会来西交<br>假如我能回到过去，我会好好学习语文，不那么看重考试成绩，而是考试的错误<br>假如我能回到过去，我会控制饮食，不让自己变胖，以及不让自己近视等等<br>。。。。。。<br>生活中的很多问题，似乎只要带着现在的大脑回去再来一次，就不会犯错，可是，真的会是这样么，其实也无所谓了，每个人应该都会后悔自己做过的某个选择，即使重来一遍，也，好吧，我其实觉得重来一遍是有用的，可惜，回不去的过去告诉我，把握好现在，才能让未来的自己不后悔</p><h2 id="无限放大的负面情绪和得失心"><a href="#无限放大的负面情绪和得失心" class="headerlink" title="无限放大的负面情绪和得失心"></a>无限放大的负面情绪和得失心</h2><p>之前一位好友邀请我做了人格测试，INFP，她很惊讶，她说，想不到我这么乐观外向的人居然是这个，其实，好像成年之后，人才开始慢慢形成更完善的性格，至少，之前初高中的生活过于单调，而人的性格是在不同的生活经历中培养起来的，所以，其实到了大学之后，或者说，到了自己照顾起自己的生活之后，许多情绪便只能自己消化，然后潜移默化的影响着自己的人格<br>从一位朋友生病住院开始，我开启了漫长的与疑病症对抗的生活，虽然最后证明我确实有病，但是，怎么说，至少我感觉我心理层面的问题会更大一点，生病=花很多很多钱=万一挂了怎么办，以及害怕将来家人生病等一系列情绪，其实核心问题还是怕花钱，我感觉这个问题其实也影响到了我看待很多问题的方式，既然说到这里了，就捋一下关系：</p><ol><li>因为怕花钱，所以身体有症状之后很担心，害怕是大病，害怕要花大钱，所以不停的去医院，有病就想赶紧治，稍微不舒服，就想看医生，包括一些小病，没有给自己身体适应的过程，结果是，负面情绪太高往往也不利于病情恢复，而且会很绝望</li><li>因为怕花钱，考驾照的时候，导致自己特别特别紧张，说实话，我开车倒是真的没那么怕，怕速度快或者怎么样，我就真的是算了一下，挂科之后要花小一千，我就难受，还有就是长期被指责动手能力不行，导致我不管是学车还是金工实习，都有一个很强的先入为主的想法，觉得自己不行，然后那些平日里动手能力很强的人，我会觉得他一定行，不过傲慢与偏见，也算是人之常情，只是，这种潜移默化对别人的评价，真的会刻在骨子里，影响很多很多时候自己的想法，所以，不要PUA别人</li><li>因为怕花钱，所以想赚钱，这个逻辑好像也没什么毛病，所以直接导致，研究生之后，成绩被判的很低之后，总是在担心能不能拿到奖学金，进而各种郁闷，以及对一些不合理规则，不公平竞争的埋怨，只是有时候也觉得，为这点钱不至于，不过好像，得失心太重了，接受不了这种落差，前几天看北大数学学院的小姐姐演讲，说总有人在你专业的领域和你喜欢的领域两方面都比你优秀，我们能做的只有优化自己，今天早上其实自己还在想排名这件事以及其派生物内卷给自己带来了多大的苦恼，其实能专注于自己，规划好自己的未来，比起在意别人的想法或许更重要一点。</li></ol><p>写到这里其实心情已经好很多了，INFP嘛，哈哈，只是如果再拿一个“良”的话，应该还是会难受一阵子，不过没有那么快的转变嘛，只能说，要学会在经历挫折中，锻炼自己消化情绪的能力</p><p>体重其实好久没变了，就像没有起色的科研，和看不到光的未来一样，可是时间不管你的失落，他公平的近乎冷漠的走啊走啊走，村上喜欢跑步，说不必像其他运动一样那么富有竞争性，可以按照自己的节奏来，我其实也挺烦竞争的，只想安稳地按照自己的节奏来，可是当曾经比你胖的人已经比你瘦了，当你认为不如你的人却拿到比你更高的分数的时候，是不吃一顿晚饭然后不顾身体的去跑个6公里么，或者开始新一轮emo为了一分两分悲伤一晚上，然后幻想回到过去么<br>高考结束的时候，我安慰自己<strong>一切都是最好的安排</strong>，回看过去，长沙和中南带给我的全是美好的回忆，至少现在看来，当然某些时刻还是会悲伤，不过都熬过来了，此时此刻，在抱怨西安，抱怨科研，抱怨各种琐碎的时候，或许回看现在，也会是美好的，考不过驾照的时候，悲伤，我安慰自己<strong>人的快乐都是自己给的，不快乐也是</strong>。<br>所以，看淡一点吧，或者我应该劝自己，努力看淡一点吧，我爱猴叔对生活的热情，我也渴望做一个热爱生活的人，琐碎的烦恼既然躲不掉，就面对吧，emo的情绪，如果化解不掉，或许可以仔细分析一下情绪的前因后果，然后理清楚了，就有方法了，起码安慰起自己来也有理有据and有用？对，有用。<br>前段时间复习中特，现在就特别喜欢分条罗列，类似于划重点，hhh，大道至简，党的智慧啊，总结一下：</p><blockquote><ol><li>既然过去回不去，那就抓住现在，渴望被打鸡血</li><li>不以物喜，不以己悲，完美概括了自己的得失心和想不开，呜呜呜，范仲淹懂我</li><li>学会自我调节，整理心情，分析情绪，乐观，热爱生活，就要接收生活的酸甜苦辣咸<br>以上</li></ol></blockquote>]]></content>
    
    
    <summary type="html">一些丧丧的记录，希望不全是吧</summary>
    
    
    
    <category term="博客和写作" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer(1)——算法和数据结构基础</title>
    <link href="http://example.com/2022/06/06/%E5%89%91%E6%8C%87Offer/"/>
    <id>http://example.com/2022/06/06/%E5%89%91%E6%8C%87Offer/</id>
    <published>2022-06-05T16:00:00.000Z</published>
    <updated>2022-07-17T03:09:27.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构-数组和字符串"><a href="#数据结构-数组和字符串" class="headerlink" title="数据结构__数组和字符串"></a>数据结构__数组和字符串</h1><h2 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 数组中重复的数字</h2><blockquote><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br><strong>例：</strong><br>输入：[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p></blockquote><p><strong>方法1：原地交换</strong><br>利用题目信息：即在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内。说明数组元素的索引和值是<strong>一对多</strong>的关系。每个元素最多被交换两次就被送到了对应的位置，所以时间复杂度是<script type="math/tex">O(N)</script>，原地交换，所以空间复杂度是<script type="math/tex">O(1)</script>.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[nums[i]] == nums[i]: <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><br>注意最后一行交换两个数时的a,b = c,d赋值语句：Python操作的原理是先暂存元组 (c, d)，然后 “按左右顺序” 赋值给 a 和 b 。<br>因此，若写为 nums[i], nums[nums[i]] = nums[nums[i]],nums[i]，则 nums[i] 会先被赋值nums[nums[i]]，之后赋值时 nums[nums[i]] ，元素索引会出现错误，因为这个时候nums[i]已经被改变<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">i = <span class="number">2</span> <span class="comment">#交换位置2和位置3（nums[2]=3）</span></span><br><span class="line">nums[i],nums[nums[i]]=nums[nums[i]],nums[i]</span><br><span class="line"><span class="built_in">print</span>(nums)<span class="comment">#[1,2,4,4,5]发生错误</span></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">nums[nums[i]],nums[i]=nums[i],nums[nums[i]]</span><br><span class="line"><span class="built_in">print</span>(nums)<span class="comment">#[1,2,4,3,5]正确</span></span><br></pre></td></tr></table></figure></p><p><strong>方法2：哈希表</strong><br>没啥好说的，注意哈希表的添加是add就好，然后就是空间复杂度比方法一高。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dic = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> dic: <span class="keyword">return</span> num</span><br><span class="line">            dic.add(num)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p><strong>题目拓展</strong><br>书上给出了进一步的要求，数组长度n+1,包含的数字在1~n范围内，要求不改变原数组的情况下找出重复元素。<br>思路1：新建一个辅助数组，长度也为n+1,然后从原数组往辅助数组拷贝，每次拷贝保证索引和值对应，由于数字是1开始，所以应该保证nums[i]=i+1，然后如果重复的话，直接返回，缺点是空间复杂度。<br>思路2：避免额外空间，二分法，由于1~n共有n个数，而数组长度n+1，所以必然有重复，可以把范围分为1~m和m+1~n，然后分别统计两个范围的数的个数，二分缩小范围。时间复杂度<script type="math/tex">O(nlogn)</script>,每次计数复杂度是<script type="math/tex">O（n）</script>,所以是拿时间换空间。<br>这个改进不能拿原题跑了，因为原题长度是n,可取的数也有n个，计数不一定满足。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">countrange</span>(<span class="params">nums,a,b</span>):</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">if</span> a&lt;=i <span class="keyword">and</span> i&lt;=b:</span><br><span class="line">                    count +=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> count</span><br><span class="line">        a = <span class="number">0</span></span><br><span class="line">        b = <span class="built_in">len</span>(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> b&gt;a:</span><br><span class="line">            mid = (a+b)//<span class="number">2</span></span><br><span class="line">            res = countrange(nums,a,mid)</span><br><span class="line">            <span class="built_in">print</span>(a,mid)</span><br><span class="line">            <span class="keyword">if</span> res&gt;mid-a+<span class="number">1</span>:</span><br><span class="line">                b = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                a = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> b==a:</span><br><span class="line">                <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure></p><h2 id="04-二维数组中的查找"><a href="#04-二维数组中的查找" class="headerlink" title="04 二维数组中的查找"></a>04 二维数组中的查找</h2><blockquote><p>在一个 n <em> m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><em>*示例:</em></em><br>现有矩阵 matrix 如下：<br>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。<br>给定 target = 20，返回 false。</p></blockquote><p>常规想法可能是先找到在哪一行，然后再找哪一列，但这样其实比较浪费，没有很好的利用本来有序的信息，试想如果其小于某一列的最后一个元素，则必然小于该行下所有行最后一列的元素，这样一次就可以缩小一行或一列了。时间复杂度就降为<script type="math/tex">O(M+N)</script>,当然从左下角开始也是一样的，K神的代码相比于从右上角开始j=len(matrix[0])-1，这样写直接省下了判断matrix[0]是否是None<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findNumberIn2DArray</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        i, j = <span class="built_in">len</span>(matrix) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][j] &gt; target: i -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[i][j] &lt; target: j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure></p><h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05 替换空格"></a>05 替换空格</h2><blockquote><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。<br><strong>示例</strong>：<br>输入：s = “We are happy.”<br>输出：”We%20are%20happy.”</p></blockquote><p>在 Python 和 Java 等语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。实现也比较容易。主要难点在于使用C++时，需要改变长度，因此采用倒序遍历，双指针的做法，具体可参考<a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/solution/mian-shi-ti-05-ti-huan-kong-ge-ji-jian-qing-xi-tu-/">题解</a>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27; &#x27;</span>: res.append(<span class="string">&quot;%20&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>: res.append(c)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure><br>补充材料：</p><blockquote><p><a href="https://www.runoob.com/python/python-strings.html">Python字符串操作</a><br><a href="https://www.runoob.com/python/python-strings.html">字符串用到的join函数</a></p></blockquote><p>感觉Python字符串很好用的一个操作就是可以直接相加，并且按位索引，很像列表，比如旋转字符串的题可以直接s[n:]+s[:n]，如果不允许用切片的话，就是用列表写了，然后用join函数转换为字符串</p><p>还有一个哈希表的事，现在Python3.6之后的字典默认是有序的，也就不需要再定义OrderedDict</p><h1 id="数据结构-链表"><a href="#数据结构-链表" class="headerlink" title="数据结构__链表"></a>数据结构__链表</h1><h2 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06 从尾到头打印链表"></a>06 <a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></h2><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。<br><strong>示例 1：</strong><br>输入：head = [1,3,2]<br>输出：[2,3,1]</p></blockquote><p>两种方法的时间复杂度和空间复杂度都是<script type="math/tex">O(N)</script></p><p><strong>方法1：辅助栈</strong><br>比较容易就想到了，先进后出的做法。书中指到可以采用<strong>反转链表的方式</strong>，在面试时，需要与面试官沟通是否可以改变原始输入数据。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            stack.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> stack[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><br><strong>方法2：递归</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="comment">#大佬的简易版</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="keyword">return</span> self.reversePrint(head.<span class="built_in">next</span>) + [head.val] <span class="keyword">if</span> head <span class="keyword">else</span> []</span><br><span class="line"></span><br><span class="line"><span class="comment">#自己写的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">digui</span>(<span class="params">head</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            digui(head.<span class="built_in">next</span>)</span><br><span class="line">            stack.append(head.val)</span><br><span class="line"></span><br><span class="line">        digui(head)</span><br><span class="line">        <span class="keyword">return</span> stack</span><br></pre></td></tr></table></figure></p><h1 id="数据结构-树"><a href="#数据结构-树" class="headerlink" title="数据结构__树"></a>数据结构__树</h1><h2 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07 重建二叉树"></a>07 <a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></h2><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。<br><strong>示例</strong>：<br>Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]<br>Output: [3,9,20,null,null,15,7]</p></blockquote><p>感觉切片的方法还是很直观且好理解的<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 切片</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> preorder:</span><br><span class="line">            root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">            index = inorder.index(preorder[<span class="number">0</span>])       </span><br><span class="line">            root.left = self.buildTree(preorder[<span class="number">1</span>:index+<span class="number">1</span>],inorder[:index])</span><br><span class="line">            root.right = self.buildTree(preorder[index+<span class="number">1</span>:],inorder[index+<span class="number">1</span>:])</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><br>大佬写的效率会更高一点，至少不用切片，递归函数三个参数<br>recur(root,left,right)<br>其中第一个参数表示在前序遍历中根节点的索引，后面的left和right对应在中序遍历时，该子树的范围，所以每次先寻找根节点的位置i，然后建立范围，很明显：<br>左子树的根节点在前序遍历中，就在当前根节点下一个位置即root+1<br>左子树本身在中序遍历中，就是left到i的左边，即left~i-1<br>右子树的根节点在前序遍历中，就在左子树的下一个，而左子树的长度，由左子树的范围可知，为i-1-left+1,为i-left，而左子树的起点是root+1,所以右子树根节点就是i-left+root+1<br>右子树本身在中序遍历中，就是i的右边到结尾，即i+1~right</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, preorder: <span class="type">List</span>[<span class="built_in">int</span>], inorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">root, left, right</span>):</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; right: <span class="keyword">return</span>                               <span class="comment"># 递归终止</span></span><br><span class="line">            node = TreeNode(preorder[root])                       <span class="comment"># 建立根节点</span></span><br><span class="line">            i = dic[preorder[root]]                               <span class="comment"># 划分根节点、左子树、右子树</span></span><br><span class="line">            node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>)              <span class="comment"># 开启左子树递归</span></span><br><span class="line">            node.right = recur(i - left + root + <span class="number">1</span>, i + <span class="number">1</span>, right) <span class="comment"># 开启右子树递归</span></span><br><span class="line">            <span class="keyword">return</span> node                                           <span class="comment"># 回溯返回根节点</span></span><br><span class="line"></span><br><span class="line">        dic, preorder = &#123;&#125;, preorder</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(inorder)):</span><br><span class="line">            dic[inorder[i]] = i</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">len</span>(inorder) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="08-二叉树的下一个节点-力扣题名中序后继"><a href="#08-二叉树的下一个节点-力扣题名中序后继" class="headerlink" title="08 二叉树的下一个节点(力扣题名中序后继)"></a>08 二叉树的下一个节点(力扣题名中序后继)</h2><h1 id="数据结构-栈与队列"><a href="#数据结构-栈与队列" class="headerlink" title="数据结构__栈与队列"></a>数据结构__栈与队列</h1><h2 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09 用两个栈实现队列"></a>09 用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>做法：辅助栈，每次需要删除的时候，从A栈里pop出所有元素到B栈中，这样A的栈底元素会变到B的栈顶，所以当需要删除栈顶元素时，总是从B开始，当B为空时，从A栈pop出所有元素，比较简单。</p><blockquote><p>时间复杂度：<br>appendTail()函数为 <script type="math/tex">O(1)</script> ；<br>deleteHead() 函数在<script type="math/tex">N</script>次队首元素删除操作中总共需完成<script type="math/tex">N</script>个元素的倒序。<br>空间复杂度<script type="math/tex">O(N)</script>： 最差情况下，栈 A 和 B 共保存<script type="math/tex">N</script>个元素。<br><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-2/">题解</a></p><p><a href="https://m.php.cn/article/471345.html">Python删除元素方法</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.B: <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br></pre></td></tr></table></figure><h1 id="算法操作-递归和循环"><a href="#算法操作-递归和循环" class="headerlink" title="算法操作__递归和循环"></a>算法操作__递归和循环</h1><p>通常递归代码比较简洁，但是性能不如基于循环的代码，每次调用都需要在内存栈中分配空间以保存参数，返回地址及临时变量，所以效率低。但是在树的遍历的时候，递归比较常用，在没有要求的情况下，<strong>尽可能的用递归</strong>。还有在比如斐波那契数列这种问题下，使用递归会造成大量的重复计算。<br><strong>递归</strong>：函数调用自身<br>如果面试的时候告诉了动态规划的思路后，面试官提醒说在分解子问题的时候，是不是存在特殊的选择，如果采用这个特殊的选择将一定能得到最优解，这个可能在提示用贪婪算法。</p><h2 id="10-斐波那契数列和青蛙跳台阶"><a href="#10-斐波那契数列和青蛙跳台阶" class="headerlink" title="10 斐波那契数列和青蛙跳台阶"></a>10 斐波那契数列和青蛙跳台阶</h2><blockquote><p>Those who cannot remember the past are condemned to repeat it.<br>要不要这么哲理啊，哈哈哈</p></blockquote><p>以斐波那契数为例，最容易想到的递归，其实一直在重复调用，造成了很大的时间（重复计算）和空间浪费（保存中间结果）<br>解决办法：</p><ol><li>自顶向下，相当于建立了一个备忘录，创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在Memo数组中，下次在调用fib（n）的时候就不会重新递归了。问题就是空间浪费，需要有个数组存放</li><li>自下向上，计算fib（6）的时候最后还是要计算出fib（1），fib（2），fib（3）…,那么何不先计算出fib（1），fib（2），fib（3）…,呢？这也就是动态规划的核心，先计算子问题，再由子问题计算父问题。实现了对空间的压缩。</li></ol><p>逆向思维：这个我真的是没有<br>青蛙跳楼梯，可以一次跳一个或两个，问跳n阶有几种方案f(n),那其实，他最后一步，要么是跳一个，就有f(n-1)种，要么是跳两个，就有f(n-2)种，f(n) = f(n-1)+f(n-2)</p><blockquote><p><a href="https://blog.csdn.net/u013309870/article/details/75193592">动态规划</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            a, b = b, a + b</span><br><span class="line">        <span class="keyword">return</span> a % <span class="number">1000000007</span></span><br></pre></td></tr></table></figure><p>青蛙跳台阶只需要把n改为n-1即可，因为斐波那契数列是从0开始，而青蛙从1开始</p><blockquote><p>需要注意的是，python只要内存够不会出现大数溢出的问题，所以可以只在返回结果的时候取余，但是在java等其他语言中，每次计算时都要取余。</p></blockquote><p><strong>青蛙问题java版</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法操作-查找和排序"><a href="#算法操作-查找和排序" class="headerlink" title="算法操作__查找和排序"></a>算法操作__查找和排序</h1><p>如果面试时要求在排序数组（或者部分排序数组）中查找或统计，可以尝试<strong>二分法</strong>，排序算法中比较重要的是<strong>快排</strong></p><h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11 旋转数组的最小数字"></a>11 <a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">旋转数组的最小数字</a></h2><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。<br>注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。<br><strong>示例 1：</strong><br>输入：numbers = [3,4,5,1,2]<br>输出：1</p></blockquote><p>比较容易想到二分啦，然后就是看后段（看前半段是判断不了的，比如num[m]&gt;num[i],如果数组没有旋转的话，其实找的数在左半段，但旋转过的话，就在右半段，判断不了）<br>如果num[m]&lt; num[j],这个时候，也就是说后半段是有序的，那么肯定不在后半段中，也有可能恰好就是m，当m是旋转的那个元素时,所以令j=m<br>如果num[m]&gt; num[j],这个时候，肯定就在后半段内，而且不会是m，因为这个元素是大的，肯定是在左半段，所以就令i=m+1<br>比较复杂的就是相等的情况了，这个时候你是判断不了在那一部分的，书中写的是直接从头遍历（不是指原数组，而是当前的[i,j]），k神提到可以直接j=j-1,如果j不是旋转的起始元素，那就不影响，如果恰好是的话，就会有num[m]=num[j],而num[m]之前的数组是递增的（或者不变），那么可以判断num[i]~num[m]都等于num[j],而且由于j就是旋转的那个数字，所以其实接下来的数组就都是左半段了，那继续循环就能找到那个数字了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minArray</span>(<span class="params">self, numbers: [<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="built_in">len</span>(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            m = (i + j) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> numbers[m] &gt; numbers[j]: i = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[m] &lt; numbers[j]: j = m</span><br><span class="line">            <span class="keyword">else</span>: j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> numbers[i]</span><br></pre></td></tr></table></figure></p><h1 id="算法操作-回溯法"><a href="#算法操作-回溯法" class="headerlink" title="算法操作__回溯法"></a>算法操作__回溯法</h1><p>就有点感觉像是，一条路试一试，不行就再回来试一下另一条，所以多数会涉及置0的操作，也就是设置某个节点为已经访问过，可以用辅助数组存储是否访问过，也可以用一个集合表示，注意的是<strong>回溯时，需要把状态复原</strong></p><h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12 矩阵中的路径"></a>12 <a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof">矩阵中的路径</a></h2><blockquote><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。<br>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p></blockquote><p>采用深度优先遍历，结束当前路径的条件包括，越界，不相等，由于已经将访问过的元素置为空字符，所以不会存在重复访问的问题，值得注意的是<strong>board[i][j] = word[k]</strong>，即在遍历后，要把状态复原。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], word: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j, k</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= i &lt; <span class="built_in">len</span>(board) <span class="keyword">or</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= j &lt; <span class="built_in">len</span>(board[<span class="number">0</span>]) <span class="keyword">or</span> board[i][j] != word[k]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="built_in">len</span>(word) - <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            board[i][j] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            res = dfs(i + <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i - <span class="number">1</span>, j, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j + <span class="number">1</span>, k + <span class="number">1</span>) <span class="keyword">or</span> dfs(i, j - <span class="number">1</span>, k + <span class="number">1</span>)</span><br><span class="line">            board[i][j] = word[k]</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(i, j, <span class="number">0</span>): <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13 机器人的运动范围"></a>13 <a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">机器人的运动范围</a></h2><blockquote><p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？<br><strong>示例 1</strong>：<br>输入：m = 2, n = 3, k = 1<br>输出：3</p></blockquote><p>题解比较突出的一点就是，论证了只需要向下和向右走就可以遍历到所有的可达解，利用<strong>集合</strong>来保证不重复，然后就是当前位置各数位和的计算，当十位发生变化时，比如19—&gt;20,十位多了1，个位少了9，所以总体-8，对应(i + 1) % 10==0，不进位的话就直接+1就好，结束当前路径的条件包括越界和不满足要求，以及重复。<br>回溯法的代码很相似，都是设置了一个结束条件，这道题由于不涉及修改数据，所以不用复原，防止重复是依靠集合。</p><p><strong>深度优先</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">i, j, si, sj</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj) + dfs(i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>广度优先就是依靠栈来实现，其实差不多，只是访问的顺序不一致。<br><strong>广度优先</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        queue, visited = [(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)], <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            i, j, si, sj = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n <span class="keyword">or</span> k &lt; si + sj <span class="keyword">or</span> (i, j) <span class="keyword">in</span> visited: <span class="keyword">continue</span></span><br><span class="line">            visited.add((i,j))</span><br><span class="line">            queue.append((i + <span class="number">1</span>, j, si + <span class="number">1</span> <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> si - <span class="number">8</span>, sj))</span><br><span class="line">            queue.append((i, j + <span class="number">1</span>, si, sj + <span class="number">1</span> <span class="keyword">if</span> (j + <span class="number">1</span>) % <span class="number">10</span> <span class="keyword">else</span> sj - <span class="number">8</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(visited)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="算法操作-动态规划与贪婪"><a href="#算法操作-动态规划与贪婪" class="headerlink" title="算法操作__动态规划与贪婪"></a>算法操作__动态规划与贪婪</h1><p>这个其实之前也提到过了，主要是贪婪法在使用的时候需要证明贪婪可以得到最优解。</p><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220717104522.png" alt="sss"><br>其中快速取余数的操作，简单证明一下：</p><script type="math/tex; mode=display">a^2modc=((amodc)(amodc))modc=(amodc)^2modc</script><script type="math/tex; mode=display">a^4modc=((a^2modc)*(a^2modc))modc=((amodc)^2modc*(amodc)^2modc)modc</script><p>然后类似第一个式子，这里的化简结果就相当于把第一个式子的<script type="math/tex">a</script>替换为了<script type="math/tex">(amodc)^2</script>,所以同理我们把<script type="math/tex">a^2modc</script>替换成了<script type="math/tex">((amodc)^2)^2modc=(amodc)^4modc</script><br>大概是这么个证明过程，主要是奇数和偶数不一样，就是需要把求幂分好多次二分来求，需要二分的此书就是a不断除2，偶数情况下，就是不断的平方取余就好，奇数的话就要多乘一个x。</p><blockquote><p>比如计算<script type="math/tex">x^4modp=(x^2modp)^2modp</script></p><ol><li>先执行<script type="math/tex">x=x^2modp(a=4//2=2)</script>,计算括号里的</li><li>再执行<script type="math/tex">x=(x^2modp)^2modp(a=2//2=1)</script>,计算得到结果</li><li>最后，<script type="math/tex">rem=(1*x)modp(a=0)</script></li></ol></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求 (x^a) % p —— 快速幂求余</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remainder</span>(<span class="params">x, a, p</span>):</span></span><br><span class="line">    rem = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> a &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> a % <span class="number">2</span>: rem = (rem * x) % p</span><br><span class="line">        x = x ** <span class="number">2</span> % p</span><br><span class="line">        a //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> rem</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>回到题目本身</p><h2 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14 剪绳子"></a>14 <a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof">剪绳子</a></h2><blockquote><p>给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。<br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</p></blockquote><p>证明用到了基本不等式，求解之后发现剪成越多的长度为3的绳子越好，具体证明参考<a href="https://leetcode.cn/problems/jian-sheng-zi-ii-lcof/solution/mian-shi-ti-14-ii-jian-sheng-zi-iitan-xin-er-fen-f/">题解</a>,这道题，也可以用动态规划，只是不是一个固定的值，需要去作比较，比如f(4)=f(1)+f(3)=f(2)+f(2),需要比较不同的组合(f(n)=f(a)+f(n-a),循环终止条件是a&lt;n//2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cuttingRope</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">3</span>: <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">        a, b, p, x, rem = n // <span class="number">3</span> - <span class="number">1</span>, n % <span class="number">3</span>, <span class="number">1000000007</span>, <span class="number">3</span> , <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> a &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> a % <span class="number">2</span>: rem = (rem * x) % p</span><br><span class="line">            x = x ** <span class="number">2</span> % p</span><br><span class="line">            a //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">0</span>: <span class="keyword">return</span> (rem * <span class="number">3</span>) % p <span class="comment"># = 3^(a+1) % p</span></span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">1</span>: <span class="keyword">return</span> (rem * <span class="number">4</span>) % p <span class="comment"># = 3^a * 4 % p</span></span><br><span class="line">        <span class="keyword">return</span> (rem * <span class="number">6</span>) % p <span class="comment"># = 3^(a+1) * 2  % p</span></span><br></pre></td></tr></table></figure><h1 id="算法操作-位运算"><a href="#算法操作-位运算" class="headerlink" title="算法操作__位运算"></a>算法操作__位运算</h1><h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15 二进制中1的个数"></a>15 <a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></h2><blockquote><p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。</p></blockquote><p>比较容易陷入死循环（部分语言）的原因是，负数在右移时，是默认补全符号位，也就是会在左边填充1的，但是在控制台输入时，题目进行的是无符号的右移操作，即默认最左边的1不表示符号位，这个就有点迷惑其实，主要还是掌握一下python的变量特点就是<strong>会自动根据数值大小，扩充位数，只要内存够</strong>，所以包括以上剪绳子时出现的大数问题，都是可以储存下的，反正就是python很奇怪。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            res += n &amp; <span class="number">1</span></span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>主要是<a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/solution/mian-shi-ti-15-er-jin-zhi-zhong-1de-ge-shu-wei-yun/">题解</a>里另一种 <script type="math/tex">n&(n-1)</script>的方法</p><h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30 包含min函数的栈"></a>30 包含min函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。<br>主要问题在于怎么找最小的数，这个也是用了一个辅助栈，这个辅助栈用于存放当前栈中最小的数，每次在添加的时候，比较添加的元素和辅助栈栈顶的元素，并添加两者中更小的数到辅助栈中，因为栈是<strong>先进先出</strong>的，所以，只要后面压入的数比当前辅助栈顶的数大，那么最小数是不会改变的。</p><blockquote><p>时间复杂度：对于题目中的所有操作，时间复杂度均为 <script type="math/tex">O(1)</script>。因为栈的插入、删除与读取操作都是 <script type="math/tex">O(1)</script>，我们定义的每个操作最多调用栈操作两次。<br>空间复杂度：<script type="math/tex">O(n)</script>，其中n为总操作数。最坏情况下，我们会连续插入 nn 个元素，此时两个栈占用的空间为 <script type="math/tex">O(n)</script>。<br><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/solution/bao-han-minhan-shu-de-zhan-by-leetcode-s-i2fk/">题解</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minstack = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.minstack:<span class="comment">#没有元素时为空</span></span><br><span class="line">            self.minstack.append(<span class="built_in">min</span>(x,self.minstack[-<span class="number">1</span>]))<span class="comment">#和辅助栈自己比</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minstack.append(x)</span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">            self.minstack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.minstack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure><h2 id="补充知识：None和NULL的区别："><a href="#补充知识：None和NULL的区别：" class="headerlink" title="补充知识：None和NULL的区别："></a>补充知识：None和NULL的区别：</h2><ol><li>None是一个对象，而NULL是一个类型。</li><li>Python中没有NULL，只有None，None有自己的特殊类型NoneType。</li><li>None不等于0、任何空字符串、False等。</li><li>在Python中，None、False、0、””(空字符串)、<a href="空列表"></a>、()(空元组)、{}(空字典)都相当于False。所以，判断列表为空的时候可以直接用if list:</li><li>None是Python中的一个关键字，None本身也是个一个数据类型，而这个数据类型就是None，它可0、空字符串以及false均不一样，这些都只是对象，而None也是一个类。<blockquote><p>详细参考<a href="https://www.jb51.net/article/213184.htm">None</a></p></blockquote></li></ol><p>if X is not None写法清晰明了，且不会出错，推荐使用；<br>if not x使用前，必须确定X为None、False、””、0、[]、()、{}时对判断无影响。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = []</span><br><span class="line">y = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;X is None测试结果&#x27;</span></span><br><span class="line"><span class="built_in">print</span> x <span class="keyword">is</span> <span class="literal">None</span> <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span> y <span class="keyword">is</span> <span class="literal">None</span> <span class="comment">#True</span></span><br></pre></td></tr></table></figure></p><p>Python的赋值操作，上面的一行必须写两个[]，不然会指向同一变量，同样对于</p><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24 反转链表"></a>24 反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br>做法就是双指针，注意引入那个临时变量，链表的题，<strong>画图画图画图</strong>，更改指向后，记得把原来的连接线打岔就好，还有就是不需要再额外加上非空的判断了，空的话直接就是返回None。时间复杂度<script type="math/tex">O(N)</script>，原地变换，空间复杂度<script type="math/tex">O(1)</script>，双指针真的很好用。</p><blockquote><p><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution/jian-zhi-offer-24-fan-zhuan-lian-biao-die-dai-di-2/">题解</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        cur, pre = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span> <span class="comment"># 暂存后继节点 cur.next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre <span class="comment"># 修改 next 引用指向</span></span><br><span class="line">            pre = cur      <span class="comment"># pre 暂存 cur</span></span><br><span class="line">            cur = tmp      <span class="comment"># cur 访问下一节点</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 复杂链表的复制</h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。<br><a href="https://leetcode.cn/problemsfu-za-lian-biao-de-fu-zhi-lcof">题目描述</a><br>需要看一下题目的图的，比较难理解，就是说要构造一个一模一样的链表，但是存储的地方不一样，主要的问题是Random，在复制时，这个节点很可能还不存在，所以可以考虑先复制所有的节点，Random先初始化为None,然后就是一个指向问题，比较好理解的方法是复制加拆分，<strong>画图画图画图</strong>。<br>尤其是在拆分的时候，在恢复原链表的时候，最后的指向None,因为复制后，原链表的最后一项是指向复制链表的最后一项的，退出循环后要单独加上一句，将其指向None。<br>还有就是最后的while判断，不能是原链表非空，即while pre，因为假设链表为：<br>3-&gt;3-&gt;7-&gt;7-&gt;null<br>到第一个7的时候，如果是while pre,则第二个7没有下一个节点了，即cur.next.next会报错(cur.next=null，没有next),所以应该是while cur.next，即保证是倒数第二个节点，然后修改原链表中7的指向。正如上一句所说。<br>还有就是在构建random指向的时候，注意判断是否为None,原因都是类似的，因为None没有next，基本都是这个错。</p><blockquote><p><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/">题解</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = Node(cur.val)</span><br><span class="line">            tmp.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            cur = tmp.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 2. 构建各新节点的 random 指向</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.random:</span><br><span class="line">                cur.<span class="built_in">next</span>.random = cur.random.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 3. 拆分两链表</span></span><br><span class="line">        cur = res = head.<span class="built_in">next</span></span><br><span class="line">        pre = head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 单独处理原链表尾节点</span></span><br><span class="line">        <span class="keyword">return</span> res      <span class="comment"># 返回新链表头节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Day04-05-查找算法"><a href="#Day04-05-查找算法" class="headerlink" title="Day04-05 查找算法"></a>Day04-05 查找算法</h1><blockquote><p>这一部分重要的方法就是二分法，尤其适用于本来内部有序的数组，mid = (a+b)//2，表示向下取整，这个还是有好几个题可以看的</p></blockquote><h2 id="53-I-在排序数组中查找数字"><a href="#53-I-在排序数组中查找数字" class="headerlink" title="53 I.在排序数组中查找数字"></a>53 I.在排序数组中查找数字</h2><p>统计一个数字在排序数组中出现的次数。<br>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2</p><blockquote><p>有序数组基本都用二分法，时间复杂度<script type="math/tex">O(logN)</script></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: [<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">tar</span>):</span></span><br><span class="line">            i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                m = (i + j) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt;= tar: i = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> helper(target) - helper(target - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>i = m+1 和j = m-1的目的是为了保证，如果target存在的话，始终在[i,j]这个区间内，<br>若 nums[m] &lt; targe，则 target 在闭区间[m+1,j]中，因此执行 i = m + 1<br>若 nums[m] &gt; target，则 target 在闭区间[i,m−1]中，因此执行 j = m - 1；<br>若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；因此和nums[m] &lt; targe，保持一致，这样保证了右边界在[i,j]这个区间内，但是对于nums[m] &gt; target，的情况，执行j = m-1后，很可能右边界就不在[i,j]内了，这种情况的话右边界就是j+1,不过不用担心的是，<strong>循环结束前的最后一次循环一定是i=j,并且如果存在target的话，i和j(i=j=m)指向的都是最右边的target或者右边界</strong>,如果指向target,执行i=m+1,刚好指向右边界,如果指向右边界，执行j = m-1,i仍指向右边界。<br>这个比较好理解，i小于等于target时总是往右移，而j只有大于target时才往左移，所以两者都是共同逼近最右边的target<br>特殊情况,就是target比最左边的数还小时，j会不断左移，直到i和j都指向0，此时仍然比target大,j=-1,i=0,同理比最右边的数大时，i会不断右移，最终i=len(nums),<br>最后一行也比较好理解，helper(target)指向比target大的第一个数，helper(target-1)指向比target-1大的第一个数，如果存在target,则刚好指向第一个target,如果不存在，他和helper(target)指向的都是同一个数。</p><blockquote><p><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/">题解</a></p></blockquote>]]></content>
    
    
    <summary type="html">剑指Offer第二章</summary>
    
    
    
    <category term="算法和数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>线性数据结构</title>
    <link href="http://example.com/2022/02/01/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/02/01/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-01-31T16:00:00.000Z</published>
    <updated>2023-01-01T05:32:45.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>&emsp;&emsp;特点是插入删除容易，但查找不容易，因此，在涉及链表查找的题目时，一般用哈希表来实现，哈希表通过哈希函数将一个输入插入到固定位置，因此哈希表有可能出现空间的浪费，因为插入时不是连续的，但是查找时方便，是用空间换时间的一种方法。发生哈希冲突时则是以链表存储的。</p><p>&emsp;&emsp;除此之外，由于链表并不需要初始化长度，因此采用动态内存分配，区别于数组，数组在内存中的空间是连续的，但是链表在内存中不连续。链表属于动态分配，需要申请内存空间(C++中用new)，但是需要手动释放(用delete)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">/*数据类型 *指针名称 = new 数据类型 </span></span><br><span class="line"><span class="comment">或</span></span><br><span class="line"><span class="comment">数据类型 *指针名称 = new 数据类型（初值）；*/</span></span><br><span class="line"><span class="keyword">delete</span> p<span class="comment">//delete指针名称</span></span><br><span class="line"><span class="comment">//如果分配成功，会返回内存空间起始地址，不成功返回NULL</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/KIKI9731/image/raw/master/QQ截图20220128171114.png" alt="动态内存与静态对比"></p><blockquote><p>使用结构体指针访问变量中成员的两种格式：(*指针变量).成员名  或者  指针变量-&gt;成员名</p></blockquote><p>用C++初始化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;        <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *next; <span class="comment">// 后继节点引用</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//结构体的初始化函数，传入x则自动给val赋值x</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例化节点</span></span><br><span class="line">ListNode *n1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>); <span class="comment">// 节点 head</span></span><br><span class="line">ListNode *n2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">ListNode *n3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1-&gt;next = n2;</span><br><span class="line">n2-&gt;next = n3;</span><br></pre></td></tr></table></figure><br>用Python初始化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x     <span class="comment"># 节点值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 后继节点引用</span></span><br><span class="line"><span class="comment"># 实例化节点</span></span><br><span class="line">n1 = ListNode(<span class="number">4</span>) <span class="comment"># 节点 head</span></span><br><span class="line">n2 = ListNode(<span class="number">5</span>)</span><br><span class="line">n3 = ListNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建引用指向</span></span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br></pre></td></tr></table></figure></p><h2 id="链表实现-Python"><a href="#链表实现-Python" class="headerlink" title="链表实现(Python)"></a>链表实现(Python)</h2><blockquote><p>参考自：<a href="https://blog.csdn.net/Blood_Seeker/article/details/78992722">https://blog.csdn.net/Blood_Seeker/article/details/78992722</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment">#结点初始化函数, p 即模拟所存放的下一个结点的地址</span></span><br><span class="line">    <span class="comment">#为了方便传参, 设置 p 的默认值为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x = <span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#链表初始化函数, 方法类似于尾插</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initList</span>(<span class="params">self, dataList</span>):</span></span><br><span class="line">        <span class="comment">#创建头结点</span></span><br><span class="line">        self.head = ListNode(<span class="literal">None</span>) <span class="comment"># 创建节点的时候传一个参数进去    # 创建头结点，里面不包含数据，头结点之后第一个才存放数据,head节点的数据默认None</span></span><br><span class="line">        pTail = self.head              <span class="comment"># 指向头结点的指针</span></span><br><span class="line">        <span class="comment">#逐个为 data 内的数据创建结点, 建立链表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dataList:            <span class="comment"># 遍历列表</span></span><br><span class="line">            newNode = ListNode(i)        <span class="comment"># 生成新的节点</span></span><br><span class="line">            pTail.<span class="built_in">next</span> = newNode      <span class="comment"># 新节点挂在尾结点上，即 上一个节点指针指向新的节点，由于新节点的next被初始化为None，所以pTail的next自然也是None</span></span><br><span class="line">            pTail = newNode          <span class="comment"># 当前新节点成为新的尾结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#链表判空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#取链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        p = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">len</span> += <span class="number">1</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traveList</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;link list traving result:&#x27;</span>)</span><br><span class="line">        p = self.head.<span class="built_in">next</span>   <span class="comment"># 取得表头之后的第一个数据</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">print</span> (p.val, end= <span class="string">&quot; &quot;</span>)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#链表插入数据函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertElem</span>(<span class="params">self, val, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 在 第index个节点(p.next)之前插入&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        p = self.head</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> i &lt; index:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> i &gt; index:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR, 无法插入节点&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        pNew = ListNode(val)    <span class="comment"># 生成新的节点 包含了 pNew.val = key</span></span><br><span class="line">        pNew.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = pNew</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteElem</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;删除第index个节点（即删除 p.next节点）&quot;</span></span><br><span class="line"></span><br><span class="line">        p = self.head</span><br><span class="line">        i = <span class="number">1</span>             <span class="comment"># 节点计数</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> i &lt; index:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> i &gt; index:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR, 该节点不存在&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        delVal = p.<span class="built_in">next</span>.val</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;deleted value:&quot;</span>, delVal)</span><br><span class="line">        p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#初始化链表与数据</span></span><br><span class="line">    <span class="comment"># data = [1,2,3,4,5]</span></span><br><span class="line">    dataList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    l = LinkList()</span><br><span class="line">    l.initList(dataList)</span><br><span class="line">    l.traveList()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(l.getLength())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#插入结点到索引值为3之后, 值为666</span></span><br><span class="line">    l.insertElem(<span class="number">666</span>, <span class="number">6</span>)</span><br><span class="line">    l.traveList()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#删除索引值为4的结点</span></span><br><span class="line">    l.deleteElem(<span class="number">4</span>)</span><br><span class="line">    l.traveList()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="一些链表相关题目"><a href="#一些链表相关题目" class="headerlink" title="一些链表相关题目"></a>一些链表相关题目</h2><h3 id="L160-相交链表"><a href="#L160-相交链表" class="headerlink" title="L160 相交链表"></a>L160 相交链表</h3><p>   &emsp;&emsp;这道题注意的是不仅仅是值相交，两个链表相交，则相交部分是完全一致的，因此可以用哈希表实现，也可以用<strong>双指针</strong>实现，两个指针分别从链表A(总长a)和链表B(总长b)的头出发，当到达结尾后，转向另一个链表，则如果两个链表有相交(相交部分为c)，此时都运动了a+b-c(a+(b-c)和b+(a-c));</p><h3 id="L141-环形链表"><a href="#L141-环形链表" class="headerlink" title="L141 环形链表"></a>L141 环形链表</h3><p>   &emsp;&emsp;利用<strong>双指针</strong>中的快慢指针，类比跑道上的两个速度不同的人，如果存在环形，则会相遇，但是注意的是两者的速度一定不同，而不能只是起点不同，起点不同不会相遇，会保持固定间隔。当然这种类似于查找是否有重复的，都可以用哈希表</p><blockquote><p>解法1：哈希表，时间复杂度O(n)，空间复杂度O(n)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span>                 </span><br><span class="line">        s = <span class="built_in">set</span>()             <span class="comment"># 定义一个set(集合，内部元素不重复)，然后不断遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> head:<span class="comment"># 如果某个节点在set中，说明遍历到重复元素了，也就是有环</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> s:     <span class="comment"># 不能把head.val这个值存在哈希表中，因为有可能只是值相同还不够，还需要指针也相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            s.add(head)       <span class="comment"># 如果节点不在哈希表中，说明之前没有相同节点，就存入表中  </span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>解法2：快慢双指针，时间复杂度O(n)，空间复杂度O(1)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:<span class="comment">#链表中是单元素且非循环或链表为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:<span class="comment">#只用考虑更快的指针，因为如果链表有限，则快指针先达到结束条件，必须加上fast.next，因为后面有fast.next.next，如果fast.next为null，则null不会有next变量，会报错</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="L234-回文链表"><a href="#L234-回文链表" class="headerlink" title="L234 回文链表"></a>L234 回文链表</h3><p>&emsp;&emsp;实现时，先利用快慢指针，找到链表的中间节点，可以参考后面的面试问题中有提到，同时在指针移动的过程中，进行反转链表，之后从中间位置往两个方向展开。<br>&emsp;&emsp;需要注意的是，对于奇数，慢指针会停在最中间的元素，因此在展开前需要将其后移一位，偶数，则指在中间靠后的元素，因此不需操作。<br>&emsp;&emsp;关于如何判断元素数是奇还是偶，可以对比跳出循环的条件：对于快指针，依次指向0，2，4，即<strong>fast指向元素的索引始终为偶数</strong>，所以如果有偶数个元素，最后一个元素索引为奇数，则倒数第二次循环后,fast指向倒数第二个元素，fast.next指向最后一个，再次进入循环，此时fast为null,fast.next会报错，但因为是and所以不会,<strong>and前是0，自动忽略后面语句（短路现象），如果改为fast.next and fast则会报错</strong>。如果有奇数个元素，则最后一次循环q指向最后一个元素,q.next=null;<strong>即奇数个元素，fast.next=null,偶数个元素，fast=null,所以if(fast)：在奇数时执行</strong>，而为了反转链表引入的pre和prepre则始终在慢指针前面一位，反转时先将pre后移，然后将prepre赋给pre.next，即pre-&gt;prepre,然后prepre后移，即循环结束时，两者指向同一元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (head <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        pre = head</span><br><span class="line">        prepre = ListNode(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast <span class="keyword">and</span> fast.<span class="built_in">next</span>):</span><br><span class="line">            pre = slow             <span class="comment"># pre 紧跟在slow 后面一步</span></span><br><span class="line"></span><br><span class="line">            slow = slow.<span class="built_in">next</span>       <span class="comment"># 快慢指针用于找到中间节点 </span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            pre.<span class="built_in">next</span> = prepre      <span class="comment"># 用于反转前半部分链表</span></span><br><span class="line">            prepre = pre</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast):                 <span class="comment"># 如果跳出上一个while循环是 fast.next is None,那么就是奇数个节点，slow需要再走一步</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>(pre <span class="keyword">and</span> slow):       <span class="comment"># 从中间对称的位置往两边扩展，比对两边的数是否相等 </span></span><br><span class="line">            <span class="keyword">if</span> (pre.val != slow.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><h2 id="链表面试问题"><a href="#链表面试问题" class="headerlink" title="链表面试问题"></a>链表面试问题</h2><p>&emsp;&emsp;无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用<strong>双指针</strong>来解决。</p><blockquote><p>双指针并不是固定的公式，而是一种思维方式~</p></blockquote><p>&emsp;&emsp;先来看”倒数第k个元素的问题”。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;   <span class="comment">//将 p指针移动 k 次</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;<span class="comment">//同时移动，直到 p == nullptr</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。<strong>fast 和 slow 的距离就会增加一。</strong>设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 指向中间两个结点的靠前一个还是靠后一个，需要调整循环的条件，下述代码是n为偶数的情况，慢指针指向<strong>靠后元素</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于上述代码：</p><blockquote><ol><li>比如n=5(下标0~4),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;4，此时q-&gt;next = null结束循环，p指向2，恰好是中间节点。（0，1，2，3，4）</li><li>比如n=4(下标0~3),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;null(2.next为3，3.next为null)，此时q = null结束循环，p指向2，是中间节点靠后一个。（0，1，2，3）</li><li>将条件改为while(q != nullptr &amp;&amp; q-&gt;next-&gt;next != nullptr)，会指向靠前一个，因为此时不会进行第二轮循环。</li></ol></blockquote><p>&emsp;&emsp;如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。<br>&emsp;&emsp;如何判断环的入口呢？<br><img src="https://gitee.com/KIKI9731/image/raw/master/QQ截图20220203130512.png" alt="环的入口"><br>&emsp;&emsp;由等式可知，相遇时d=x+ns(n为相遇时快指针多转了几圈)，则相遇后把两个指针速度变为一致，一个从起点出发，一个从相遇点出发，则因为<strong>d=x+ns</strong>，必然会在从相遇点出发的指针运动n圈+x后，在环的入口处相遇。(d为起点处出发指针路程，x+ns为从相遇点出发指针路程)，代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        walker = head</span><br><span class="line">        runner = head</span><br><span class="line">        <span class="keyword">while</span>(runner <span class="keyword">and</span> runner.<span class="built_in">next</span>):</span><br><span class="line">            walker = walker.<span class="built_in">next</span></span><br><span class="line">            runner = runner.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> walker == runner:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (runner.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>):  <span class="comment"># 如果是因为走到头而退出循环，那就是没有环</span></span><br><span class="line">            <span class="keyword">return</span>                                     <span class="comment"># return False 的话会报错Your returned value is not a ListNode type.</span></span><br><span class="line">        <span class="comment"># 如果是因为break而跳出循环，那就是有环</span></span><br><span class="line">        walker = head             <span class="comment"># 步行者回到起点</span></span><br><span class="line">        <span class="keyword">while</span>(walker != runner):  <span class="comment"># 没相遇</span></span><br><span class="line">            walker = walker.<span class="built_in">next</span></span><br><span class="line">            runner = runner.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> runner</span><br></pre></td></tr></table></figure><br>链表相关链接:</p><blockquote><ol><li><a href="https://zhuanlan.zhihu.com/p/31401474?utm_source=wechat_session&amp;utm_medium=social&amp;from=singlemessage">漫画算法：如何判断链表有环？</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/">L141环形链表</a></li></ol></blockquote><h1 id="一些刷题小总结"><a href="#一些刷题小总结" class="headerlink" title="一些刷题小总结"></a>一些刷题小总结</h1><h2 id="判断输入是否为None"><a href="#判断输入是否为None" class="headerlink" title="判断输入是否为None"></a>判断输入是否为None</h2><p>if not A 和 if A is None 看起来都是在判断A是否为空，实际上这两者是不同的：<br>（1）if not A 判断的是A是否为空，也就是说里面有东西没？<br>（2） if A is None则判断的是A是否声明并定义了？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:<span class="comment">#这里可以写成if head==None or head.next == None，但是其实是不一样的，因为如果head==None，则head.next会报错，因为Nonetype没有next的索引，即上述中的(2),不适用not则判断是否声明同时判断是否为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">记录刷题过程中的总结</summary>
    
    
    
    <category term="算法和数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="http://example.com/2022/01/13/C++/"/>
    <id>http://example.com/2022/01/13/C++/</id>
    <published>2022-01-12T16:00:00.000Z</published>
    <updated>2022-05-22T04:21:57.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h1><h2 id="前置-和后置-的区别："><a href="#前置-和后置-的区别：" class="headerlink" title="前置++和后置++的区别："></a>前置++和后置++的区别：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>,m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line">a = n++;<span class="comment">//后置++</span></span><br><span class="line">b = m--;</span><br><span class="line">c = ++n;<span class="comment">//前置++</span></span><br><span class="line">d = --m;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;<span class="comment">/*输出结果为5，10，7，8。首先对于后置++，可以看到对于a和b是先进行了赋值操作，再进行后置++。执行后a=15,b=10,n=6,m=9。对于前置++，首先进行前置++，再进行赋值操作*/</span></span><br></pre></td></tr></table></figure><p>后置++的优先级&gt;前置++的优先级&gt;乘和除的优先级&gt;…&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，！=&gt;赋值运算，优先级和上述性质无关。用优先性解释上述现象有矛盾，所以，可以按照这个记吧</p><h2 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (a)</span><br><span class="line">(int) a    //两种方式均可</span><br></pre></td></tr></table></figure><p>其优先级高于乘数法，和逻辑非，按位取反同级。<br>因此  double(n)/2  是先将n转换为double再做除法</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><blockquote><p>双目运算：&amp;&amp; ||<br>单目运算：!</p></blockquote><p>逻辑！负号-&gt;乘除运算等&gt;&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，!=&gt;逻辑&amp;&amp;&gt;逻辑||。<br>为了避免优先级的混乱，多使用圆括号</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote><p>&amp;，|，^(异或)，&lt;&lt;左移,&gt;&gt;右移,~(按位取反)</p></blockquote><p><strong>按位取反的时候要考虑到数据的字节数，对于一个正数，前面所有的0都要变成1</strong>,左移一位相当于<em>2，右移相当于除2。复合位运算(&amp;=，|=等)的结合顺序是<em>*从右向左</em></em>，除此之外还有(!,~,+,-,前置++/—)也是从右向左结合，比较特殊。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><ol><li>“=”赋值运算，其结合顺序是从右向左且其左侧(lvalue)不能是表达式，只能是变量，数组等</li><li>?:,比如y=(x&gt;=1?1:0)即可表达一个分段函数:y=1(x&gt;=1),y=0(x&lt;1)</li><li>逗号表达式，依次计算每个表达式的值，整体等于最后一个逗号后式子的值，如y=(1,2,3+5),则y=8</li></ol><hr><h2 id="算法优先级顺序"><a href="#算法优先级顺序" class="headerlink" title="算法优先级顺序"></a>算法优先级顺序</h2><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220113205502.png" alt=""></p><h2 id="数据类型转换原则"><a href="#数据类型转换原则" class="headerlink" title="数据类型转换原则"></a>数据类型转换原则</h2><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220113210115.png" alt=""></p><h2 id="整型变量和字符变量"><a href="#整型变量和字符变量" class="headerlink" title="整型变量和字符变量"></a>整型变量和字符变量</h2><p>其在内存中存放的都是整数，整数，存放的是二进制格式，字符，存放的是ASCII码值(<128)，因此可以出现以下形式：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">a = c+<span class="number">2</span>;<span class="comment">//将字符变量赋给整型变量</span></span><br><span class="line">c = <span class="number">98</span>; <span class="comment">//将整数常量赋给字符变量</span></span><br></pre></td></tr></table></figure><br>上述输出a=67,因为’A’的ASCII码的值为65<br>c = ‘b’,因为’b’的ASCII码的值为98</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>char name[40] = ‘zhang’;<br>转义字符：\r回车，回到本行开头，\n换行，到下一行开头<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;xjtu\nhello&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;xjtu123\rhello&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>执行得：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xjtu</span><br><span class="line">hello</span><br><span class="line">hello23//第二次cout的xjtu1被\r后的hello覆盖</span><br></pre></td></tr></table></figure></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>字符数组和字符串的区别在于，用字符串定义数组时，末尾是’\0’，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220115164804.png" alt=""><br>实例，将单词中的小写字母转换为大写字母：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i]=str[i]<span class="number">-32</span>;<span class="comment">//大小写字母的ASCII码差值为32</span></span><br><span class="line">        i = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>enum &lt;枚举类型名&gt;{枚举常量表}</p>]]></content>
    
    
    <summary type="html">主要总结C++的一些小的概念</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>如何利用Hexo搭建自己的博客</title>
    <link href="http://example.com/2022/01/10/Hexo/"/>
    <id>http://example.com/2022/01/10/Hexo/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-05-22T04:13:38.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>&emsp;&emsp;安装的过程可以参考 <a href="https://hexo.io/">Hexo官网</a>。<br>&emsp;&emsp;首先，需要保证安装好了node.js和git，这两个软件的安装也比较简单，直接官网安装就好。然后在命令行窗口中利用以下命令安装hexo，其中g代表对全局安装<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli-g</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;然后是新建一个文件夹，这个文件夹将自动生成一些默认的文件,之后的命令行窗口操作都是在该文件夹下进行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init [文件夹名]</span><br><span class="line">cd [文件夹名]</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;然后安装一下需要的依赖（可能就是默认工具包的意思？）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;然后执行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><h1 id="部署操作"><a href="#部署操作" class="headerlink" title="部署操作"></a>部署操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo s #生成本地预览</span><br><span class="line">hexo g #生成静态文章</span><br><span class="line">hexo d #上传，必须先执行hexo g</span><br></pre></td></tr></table></figure><h1 id="选择一个好看的主题"><a href="#选择一个好看的主题" class="headerlink" title="选择一个好看的主题"></a>选择一个好看的主题</h1><p>&emsp;&emsp;在 <a href="https://hexo.io/">Hexo官网</a>提供了很多主题，选择一个好看的主题后，点击进入主题对应的github中，即可看到相关的命令，仍然在该文件夹下执行命令后即可安装，安装后会在theme文件夹下看到一个对应得主题文件夹，比如这里我选择安装了<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a>主题，就会生成一个对应的文件夹<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220110160802.png" alt=""></p><blockquote><p>Butterfly各种参数介绍及实际操作视频，强推这个宝藏UP啊<br><a href="https://space.bilibili.com/13282871/?spm_id_from=333.999.0.0">主题操作教程</a></p></blockquote><h1 id="Markdown写作基础"><a href="#Markdown写作基础" class="headerlink" title="Markdown写作基础"></a>Markdown写作基础</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下：<br><img src="https://raw.githubusercontent.com/KIKI9731/image/main/QQ%E6%88%AA%E5%9B%BE20220111152402.png" alt="image"></p><h2 id="字体效果"><a href="#字体效果" class="headerlink" title="字体效果"></a>字体效果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*斜体*</span><br><span class="line">~~删除~~</span><br><span class="line">==高亮==</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">加两个空格：&amp;emsp;&amp;emsp;（这个还挺麻烦的）</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下：<br>&emsp;&emsp;<strong>加粗</strong>  &emsp;&emsp;<em>斜体</em>&emsp;&emsp; <del>删除</del>&emsp;&emsp;==高亮==</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用内容</span><br><span class="line">&gt;&gt;增加&gt;数量可以设置多层引用</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下： </p><blockquote><p>引用内容</p><blockquote><p>增加&gt;数量可以设置多层引用</p></blockquote></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下： </p><hr><h2 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片的名字](网上图片的链接或者本地图片的路径)</span><br><span class="line">[连接名称](链接地址)</span><br><span class="line">比如：[baidu](www.baidu.com)</span><br></pre></td></tr></table></figure><h2 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h2><p>Gitee崩了啊可恶，还是Github香</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/489236769">Github图床搭建操作</a></p></blockquote><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><blockquote><p>可以参考链接：<a href="https://blog.csdn.net/weixin_42546496/article/details/88115095">https://blog.csdn.net/weixin_42546496/article/details/88115095</a></p></blockquote>]]></content>
    
    
    <summary type="html">记录利用Hexo的一些常用命令和步骤</summary>
    
    
    
    <category term="博客和写作" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"/>
    
    
  </entry>
  
</feed>
