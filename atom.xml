<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KIKI&#39;s Blog</title>
  
  <subtitle>分享科研总结和生活琐碎</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-07-08T07:46:07.735Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>KIKI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>时序预测(1)————Deep AR</title>
    <link href="http://example.com/2022/07/08/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B(1)%E2%80%94%E2%80%94Deep%20AR/"/>
    <id>http://example.com/2022/07/08/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B(1)%E2%80%94%E2%80%94Deep%20AR/</id>
    <published>2022-07-07T16:00:00.000Z</published>
    <updated>2022-07-08T07:46:07.735Z</updated>
    
    <content type="html"><![CDATA[<h1 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h1><p><a href="">代码github</a><br><a href="https://blog.csdn.net/weixin_52185313/article/details/124874403">相关博客</a></p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>对应<strong>preprocess-elect.py</strong>文件<br>代码写的十分完备，包含了数据集的下载，如果已经下载好，只需将文件放在<code>./data/elect/</code>下即可。<br>数据由txt文件存储，记录了2011 ~2014期间欧洲地区370个家庭的用电量，采样频率为 15分钟,但在训练时是以一个小时为单位取的，数据集如下图所示，其中部分用户在2011年并没有入住，所以用电量从0开始。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/txt原始数据集.jpg" alt="原始数据"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_frame = pd.read_csv(csv_path, sep=<span class="string">&quot;;&quot;</span>, index_col=<span class="number">0</span>, parse_dates=<span class="literal">True</span>, decimal=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">data_frame = data_frame.resample(<span class="string">&#x27;1H&#x27;</span>,label = <span class="string">&#x27;left&#x27;</span>,closed = <span class="string">&#x27;right&#x27;</span>).<span class="built_in">sum</span>()[train_start:test_end]</span><br></pre></td></tr></table></figure><br><strong>pd.read_csv</strong>:seq是分隔符，这里为‘;’,decimal是指小数点，是字符串类型，默认就是’.’，由于是欧洲国家，小数点不是’.’，而是’,’,因此需要用参数指定，index_col=0指第一列为索引，parse_dates指将该索引变为时间类型。<br><strong>dataframe.resample</strong>:用于重新采样的函数，label指用哪一边来标记数据，比如这里按‘1H’，即一个小时采样后，用最左边的标志，即2011-01-01 00：00：00，如果改为right则为2011-01-01 01：00：00，closed指闭区间的范围，除了‘M’、‘A’、‘Q’、‘BM’、‘BA’、‘BQ’和‘W’之外，所有频率偏移的默认值都是‘left’，它们的默认值都是‘right’。这里把H也改为right。也就是把01：00：00算在0~1这一个小时内，右边界是闭的，如果改为left,则01：00：00算在1~2小时这个区间内。</p><blockquote><p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.resample.html">官方文档</a><br>比较有意思的是，分钟不是M，M表示的是月，分钟是T。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data_frame.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)<span class="comment">#填充缺失值</span></span><br><span class="line">covariates = gen_covariates(data_frame[train_start:test_end].index, num_covariates)<span class="comment">#自定义函数得到协变量</span></span><br><span class="line">train_data = data_frame[train_start:train_end].values<span class="comment">#.values,将dataframe转化为数组</span></span><br><span class="line">test_data = data_frame[test_start:test_end].values</span><br><span class="line">data_start = (train_data!=<span class="number">0</span>).argmax(axis=<span class="number">0</span>) </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">时序预测模型Deep AR及其基于居民用电量的应用实例</summary>
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>随笔</title>
    <link href="http://example.com/2022/06/30/%E9%9A%8F%E7%AC%94/"/>
    <id>http://example.com/2022/06/30/%E9%9A%8F%E7%AC%94/</id>
    <published>2022-06-29T16:00:00.000Z</published>
    <updated>2022-06-30T08:19:31.667Z</updated>
    
    <content type="html"><![CDATA[<h1 id="祝我自己健健康康"><a href="#祝我自己健健康康" class="headerlink" title="祝我自己健健康康"></a>祝我自己健健康康</h1><p><em>/2019.9.8，转自QQ空间日志/</em><br>我也不知道怎么说，也不能说是突然想写一篇日志，其实也想好久了，但是不知道怎么开头，也不知道自己到底要写什么，就连打开写日志这个窗口都感觉要比写说说要复杂很多，只是觉得可能自己有很多话要说，所以就想写一篇长长的东西，时间过得真么快啊，就已经20了，完全没想到当年从九岁变成十岁，如今从19变成20会过得这么快。</p><p>其实想写这些的原因就是因为暑假的时候做了人生中的第一次手术，为什么说是第一次，而不是第一个呢？因为一次就做了五个，可能我也没跟很多人说啦，但是就自己身体出现了一些问题，虽然都不是什么特别大的事情，但是就做手术本身也算是件大事，或多或少对自己的心态上会产生一些触动，也因为做了手术之后无所事事的一个暑假，我也有机会开始仔细去想自己的一些事情。</p><p>20岁于我而言是一个比较尴尬的年龄吧，很多事情也想不明白，没有到而立之年，但是也永远不可能像一个十岁的孩子一样去拒绝去想一些即将发生的事情，就好比我现在已经大三，但是我似乎对自己的未来没有什么特别明确的规划，当我遇到一件我自己不懂的事情，我还是去想我要不要去问一下别人，然后别人给我的答案，好像总感觉还是那么的模糊，我对许多事情还是得不到一个确切的说法。 就好比虽然已经学了两年的机械，但是我好像还是回答不了“你这个专业将来是做什么的”这个问题。我看到周围的同学都在忙，我不知道他们在忙什么，感觉全世界好像只有自己不知道该干什么，在过去的两年，我体验了自己想去体验的事情，但是总有一些事情就我不知道怎么去下手，我或许想做或不想做我自己也说不清楚，<strong>我不再像十几岁的时候那样，对一件事有很高的热情，好像现在所有的事情对我来说就都是那种。嗯，还行，可以吧，没有一个很确切的态度，也没有一个很明确的情绪。</strong></p><p>前段时间我去看过一次心理医生，说是中度抑郁，可是我感觉我过的还行，只是好像到了一个也不算成熟，但是总觉得到了一个对什么都没有了好奇心的状态，这可能就是所谓的变老了吧表情我发现我开始很在意我的家人，会好奇自己前两年是怎么做到一个月可以不跟家里打一个电话的那种状态，也因为这种在意，我会在这个暑假里跟他们走的格外的近，我发现其实我弟现在十岁，也是从九岁到十岁这个十位数要发生改变的年龄，他好像还有很多事情是希望被我知道，但是我之前都没有关注到的，我会跟他聊很多，很多之前我可能不太感兴趣的东西，然后我才知道很多事情和我想的也不一样，他也有他自己的问题和烦恼，我就在好奇，十年前我自己是什么样子？我原以为小孩子都是那种没心没肺的，天天很快乐的样子，但是当我弟很严肃的跟我说起一些关于自己的事情的时候，我会发现好像也没我想象的那么简单，我也会跟我妈聊，我发现成年人的世界真的很复杂，好多从理论上来讲，不会发生争执的事情，倒引发了很大很大的问题，好多，我以为那不明摆的事情吗？但是人们就是不愿意那么做，我会在逛超市的时候，留意那些我不认识的人们的一举一动，他们的语言，他们的一些小动作，好像每个人都有自己的故事，我有时候可以什么都不干，一下午在那里胡思乱想，会开始在意自己的身体健康，甚至可以熟练的说出来十几种几年前可能完全没有听说过的病的名字，会开始不着边际的想一些可能十年20年甚至更久之后可能会发生的一些事情，对很多事变得很佛，很养生，反倒越想越迷茫。算了，就这样吧，明天就是新学期的第一天了，虽然自己其实已经搞了两个星期课设了。</p><p>嗯，可能也是因为这个原因，对新学期提不起来什么兴趣，总觉得要放假的一样，因为不知道未来要走向何方，所以也没什么动力和方向，只想简简单单，然后emmm祝家人身体健康<br>愿我十年之后，能……</p><p>emmm算了，我不想给自己什么承诺</p><p>语音转文字的结果，就是没有逻辑也可以写很多东西</p><blockquote><p>2022.6.30注：其实过了三年来看三年前，应该是大二暑假的这个日志的话，还是多少有些心酸吧，那个时候的心境还是会和现在有很大不同，不过突出的一点就是对于未来的迷茫感，我不是那种会计划很长久的人，本着走一步看一步的想法，应该也是因为如此，所以才会迷茫吧，王天磊跟我聊未来的时候，我会羡慕，他想的好远，想的好周全，可是有些事情，尤其是个人对生活的态度这种事，其实很难改变的，只能说，找点事来做吧，热爱可抵岁月漫长，找不到热爱，只能说，那就收集点面包吧。</p></blockquote><h1 id="迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪"><a href="#迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪" class="headerlink" title="迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪"></a>迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪</h1><p>/<em>2022.6.30</em>/</p><blockquote><p>一切从研究生开始的时候说起</p></blockquote><h2 id="幻想回不去的过去"><a href="#幻想回不去的过去" class="headerlink" title="幻想回不去的过去"></a>幻想回不去的过去</h2><p>一年过去了，其实给人最大的感觉就是很迷茫，突然就没了目标一样，好在学校不宜久居，缺乏生活气息的环境帮我果断打消了读博的念头，当然还有一个原因是老师确实没有给出一个切实可行的研究计划，所以，眼下摆在面前的似乎只有毕业工作这条路。<br>迷茫，是因为不知道自己要做什么才能毕业，好像每天都在学些东西，看些论文，但是说实话每天的有效学习时间并不长，印象里自己也不是那种坐不住的人，只是缺少一个明确的任务，所以从这点上来说，或许工作了会好一些吧，我常这样安慰自己。偶尔可能会有一两天，突然觉得未来可期，可能是找到了一段觉得还不错的视频，或者有了一点点想法，然后，努力几天后，就又没了下午，我属于那种情绪来的特别快，去的也特别快的人，当然负面情绪好像去的并不快，所以，三分钟热度算是很确切的一种说法，我常常会在周一定好计划，说自己这周开始要早睡，然后，在某天晚上没有早睡之后，就放弃，更多的时候，当我刻意想要早睡的时候，却总是睡不着，脑子里想的最多的，是假如我能回到过去，诸如：<br>假如我能回到过去，我会毫不犹豫的转专业，学个计算机，或者至少不会来西交<br>假如我能回到过去，我会好好学习语文，不那么看重考试成绩，而是考试的错误<br>假如我能回到过去，我会控制饮食，不让自己变胖，以及不让自己近视等等<br>。。。。。。<br>生活中的很多问题，似乎只要带着现在的大脑回去再来一次，就不会犯错，可是，真的会是这样么，其实也无所谓了，每个人应该都会后悔自己做过的某个选择，即使重来一遍，也，好吧，我其实觉得重来一遍是有用的，可惜，回不去的过去告诉我，把握好现在，才能让未来的自己不后悔</p><h2 id="无限放大的负面情绪和得失心"><a href="#无限放大的负面情绪和得失心" class="headerlink" title="无限放大的负面情绪和得失心"></a>无限放大的负面情绪和得失心</h2><p>之前一位好友邀请我做了人格测试，INFP，她很惊讶，她说，想不到我这么乐观外向的人居然是这个，其实，好像成年之后，人才开始慢慢形成更完善的性格，至少，之前初高中的生活过于单调，而人的性格是在不同的生活经历中培养起来的，所以，其实到了大学之后，或者说，到了自己照顾起自己的生活之后，许多情绪便只能自己消化，然后潜移默化的影响着自己的人格<br>从一位朋友生病住院开始，我开启了漫长的与疑病症对抗的生活，虽然最后证明我确实有病，但是，怎么说，至少我感觉我心理层面的问题会更大一点，生病=花很多很多钱=万一挂了怎么办，以及害怕将来家人生病等一系列情绪，其实核心问题还是怕花钱，我感觉这个问题其实也影响到了我看待很多问题的方式，既然说到这里了，就捋一下关系：</p><ol><li>因为怕花钱，所以身体有症状之后很担心，害怕是大病，害怕要花大钱，所以不停的去医院，有病就想赶紧治，稍微不舒服，就想看医生，包括一些小病，没有给自己身体适应的过程，结果是，负面情绪太高往往也不利于病情恢复，而且会很绝望</li><li>因为怕花钱，考驾照的时候，导致自己特别特别紧张，说实话，我开车倒是真的没那么怕，怕速度快或者怎么样，我就真的是算了一下，挂科之后要花小一千，我就难受，还有就是长期被指责动手能力不行，导致我不管是学车还是金工实习，都有一个很强的先入为主的想法，觉得自己不行，然后那些平日里动手能力很强的人，我会觉得他一定行，不过傲慢与偏见，也算是人之常情，只是，这种潜移默化对别人的评价，真的会刻在骨子里，影响很多很多时候自己的想法，所以，不要PUA别人</li><li>因为怕花钱，所以想赚钱，这个逻辑好像也没什么毛病，所以直接导致，研究生之后，成绩被判的很低之后，总是在担心能不能拿到奖学金，进而各种郁闷，以及对一些不合理规则，不公平竞争的埋怨，只是有时候也觉得，为这点钱不至于，不过好像，得失心太重了，接受不了这种落差，前几天看北大数学学院的小姐姐演讲，说总有人在你专业的领域和你喜欢的领域两方面都比你优秀，我们能做的只有优化自己，今天早上其实自己还在想排名这件事以及其派生物内卷给自己带来了多大的苦恼，其实能专注于自己，规划好自己的未来，比起在意别人的想法或许更重要一点。</li></ol><p>写到这里其实心情已经好很多了，INFP嘛，哈哈，只是如果再拿一个“良”的话，应该还是会难受一阵子，不过没有那么快的转变嘛，只能说，要学会在经历挫折中，锻炼自己消化情绪的能力</p><p>体重其实好久没变了，就像没有起色的科研，和看不到光的未来一样，可是时间不管你的失落，他公平的近乎冷漠的走啊走啊走，村上喜欢跑步，说不必像其他运动一样那么富有竞争性，可以按照自己的节奏来，我其实也挺烦竞争的，只想安稳地按照自己的节奏来，可是当曾经比你胖的人已经比你瘦了，当你认为不如你的人却拿到比你更高的分数的时候，是不吃一顿晚饭然后不顾身体的去跑个6公里么，或者开始新一轮emo为了一分两分悲伤一晚上，然后幻想回到过去么<br>高考结束的时候，我安慰自己<strong>一切都是最好的安排</strong>，回看过去，长沙和中南带给我的全是美好的回忆，至少现在看来，当然某些时刻还是会悲伤，不过都熬过来了，此时此刻，在抱怨西安，抱怨科研，抱怨各种琐碎的时候，或许回看现在，也会是美好的，考不过驾照的时候，悲伤，我安慰自己<strong>人的快乐都是自己给的，不快乐也是</strong>。<br>所以，看淡一点吧，或者我应该劝自己，努力看淡一点吧，我爱猴叔对生活的热情，我也渴望做一个热爱生活的人，琐碎的烦恼既然躲不掉，就面对吧，emo的情绪，如果化解不掉，或许可以仔细分析一下情绪的前因后果，然后理清楚了，就有方法了，起码安慰起自己来也有理有据and有用？对，有用。<br>前段时间复习中特，现在就特别喜欢分条罗列，类似于划重点，hhh，大道至简，党的智慧啊，总结一下：</p><blockquote><ol><li>既然过去回不去，那就抓住现在，渴望被打鸡血</li><li>不以物喜，不以己悲，完美概括了自己的得失心和想不开，呜呜呜，范仲淹懂我</li><li>学会自我调节，整理心情，分析情绪，乐观，热爱生活，就要接收生活的酸甜苦辣咸<br>以上</li></ol></blockquote>]]></content>
    
    
    <summary type="html">一些丧丧的记录，希望不全是吧</summary>
    
    
    
    <category term="博客和写作" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指Offer</title>
    <link href="http://example.com/2022/06/06/%E5%89%91%E6%8C%87Offer/"/>
    <id>http://example.com/2022/06/06/%E5%89%91%E6%8C%87Offer/</id>
    <published>2022-06-05T16:00:00.000Z</published>
    <updated>2022-06-14T13:03:58.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Day01-栈与队列"><a href="#Day01-栈与队列" class="headerlink" title="Day01 栈与队列"></a>Day01 栈与队列</h1><h2 id="09-用两个栈实现队列"><a href="#09-用两个栈实现队列" class="headerlink" title="09 用两个栈实现队列"></a>09 用两个栈实现队列</h2><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p><p>做法：辅助栈，每次需要删除的时候，从A栈里pop出所有元素到B栈中，这样A的栈底元素会变到B的栈顶，所以当需要删除栈顶元素时，总是从B开始，当B为空时，从A栈pop出所有元素，比较简单。</p><blockquote><p>时间复杂度：<br>appendTail()函数为 <script type="math/tex">O(1)</script> ；<br>deleteHead() 函数在<script type="math/tex">N</script>次队首元素删除操作中总共需完成<script type="math/tex">N</script>个元素的倒序。<br>空间复杂度<script type="math/tex">O(N)</script>： 最差情况下，栈 A 和 B 共保存<script type="math/tex">N</script>个元素。<br><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/solution/mian-shi-ti-09-yong-liang-ge-zhan-shi-xian-dui-l-2/">题解</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.A, self.B = [], []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.B: <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A: <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br></pre></td></tr></table></figure><h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30 包含min函数的栈"></a>30 包含min函数的栈</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。<br>主要问题在于怎么找最小的数，这个也是用了一个辅助栈，这个辅助栈用于存放当前栈中最小的数，每次在添加的时候，比较添加的元素和辅助栈栈顶的元素，并添加两者中更小的数到辅助栈中，因为栈是<strong>先进先出</strong>的，所以，只要后面压入的数比当前辅助栈顶的数大，那么最小数是不会改变的。</p><blockquote><p>时间复杂度：对于题目中的所有操作，时间复杂度均为 <script type="math/tex">O(1)</script>。因为栈的插入、删除与读取操作都是 <script type="math/tex">O(1)</script>，我们定义的每个操作最多调用栈操作两次。<br>空间复杂度：<script type="math/tex">O(n)</script>，其中n为总操作数。最坏情况下，我们会连续插入 nn 个元素，此时两个栈占用的空间为 <script type="math/tex">O(n)</script>。<br><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/solution/bao-han-minhan-shu-de-zhan-by-leetcode-s-i2fk/">题解</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stack = []</span><br><span class="line">        self.minstack = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.minstack:<span class="comment">#没有元素时为空</span></span><br><span class="line">            self.minstack.append(<span class="built_in">min</span>(x,self.minstack[-<span class="number">1</span>]))<span class="comment">#和辅助栈自己比</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.minstack.append(x)</span><br><span class="line">        self.stack.append(x)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            self.stack.pop()</span><br><span class="line">            self.minstack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.minstack[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> null</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MinStack()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.top()</span></span><br><span class="line"><span class="comment"># param_4 = obj.min()</span></span><br></pre></td></tr></table></figure><h2 id="补充知识：None和NULL的区别："><a href="#补充知识：None和NULL的区别：" class="headerlink" title="补充知识：None和NULL的区别："></a>补充知识：None和NULL的区别：</h2><ol><li>None是一个对象，而NULL是一个类型。</li><li>Python中没有NULL，只有None，None有自己的特殊类型NoneType。</li><li>None不等于0、任何空字符串、False等。</li><li>在Python中，None、False、0、””(空字符串)、<a href="空列表"></a>、()(空元组)、{}(空字典)都相当于False。所以，判断列表为空的时候可以直接用if list:</li><li>None是Python中的一个关键字，None本身也是个一个数据类型，而这个数据类型就是None，它可0、空字符串以及false均不一样，这些都只是对象，而None也是一个类。<blockquote><p>详细参考<a href="https://www.jb51.net/article/213184.htm">None</a></p></blockquote></li></ol><p>if X is not None写法清晰明了，且不会出错，推荐使用；<br>if not x使用前，必须确定X为None、False、””、0、[]、()、{}时对判断无影响。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = []</span><br><span class="line">y = <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;X is None测试结果&#x27;</span></span><br><span class="line"><span class="built_in">print</span> x <span class="keyword">is</span> <span class="literal">None</span> <span class="comment">#False</span></span><br><span class="line"><span class="built_in">print</span> y <span class="keyword">is</span> <span class="literal">None</span> <span class="comment">#True</span></span><br></pre></td></tr></table></figure></p><p>Python的赋值操作，上面的一行必须写两个[]，不然会指向同一变量，同样对于</p><h1 id="Day02-链表"><a href="#Day02-链表" class="headerlink" title="Day02 链表"></a>Day02 链表</h1><h2 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06 从尾到头打印链表"></a>06 从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。<br>做法：辅助栈</p><blockquote><p>时间复杂度 <script type="math/tex">O(N)</script>： 入栈和出栈共使用时间。<br>空间复杂度 <script type="math/tex">O(N)</script>： 辅助栈 stack 和数组 res 共使用的额外空间。</p></blockquote><p>比较简单，主要就是掌握最后一行，列表逆向输出时，是两个冒号，递归的方法好复杂，自己写不出来。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        a =[]</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            a.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> a[::-<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24 反转链表"></a>24 反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。<br>做法就是双指针，注意引入那个临时变量，链表的题，<strong>画图画图画图</strong>，更改指向后，记得把原来的连接线打岔就好，还有就是不需要再额外加上非空的判断了，空的话直接就是返回None。时间复杂度<script type="math/tex">O(N)</script>，原地变换，空间复杂度<script type="math/tex">O(1)</script>，双指针真的很好用。</p><blockquote><p><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/solution/jian-zhi-offer-24-fan-zhuan-lian-biao-die-dai-di-2/">题解</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line">        cur, pre = head, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span> <span class="comment"># 暂存后继节点 cur.next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = pre <span class="comment"># 修改 next 引用指向</span></span><br><span class="line">            pre = cur      <span class="comment"># pre 暂存 cur</span></span><br><span class="line">            cur = tmp      <span class="comment"># cur 访问下一节点</span></span><br><span class="line">        <span class="keyword">return</span> pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 复杂链表的复制</h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。<br><a href="https://leetcode.cn/problemsfu-za-lian-biao-de-fu-zhi-lcof">题目描述</a><br>需要看一下题目的图的，比较难理解，就是说要构造一个一模一样的链表，但是存储的地方不一样，主要的问题是Random，在复制时，这个节点很可能还不存在，所以可以考虑先复制所有的节点，Random先初始化为None,然后就是一个指向问题，比较好理解的方法是复制加拆分，<strong>画图画图画图</strong>。<br>尤其是在拆分的时候，在恢复原链表的时候，最后的指向None,因为复制后，原链表的最后一项是指向复制链表的最后一项的，退出循环后要单独加上一句，将其指向None。<br>还有就是最后的while判断，不能是原链表非空，即while pre，因为假设链表为：<br>3-&gt;3-&gt;7-&gt;7-&gt;null<br>到第一个7的时候，如果是while pre,则第二个7没有下一个节点了，即cur.next.next会报错(cur.next=null，没有next),所以应该是while cur.next，即保证是倒数第二个节点，然后修改原链表中7的指向。正如上一句所说。<br>还有就是在构建random指向的时候，注意判断是否为None,原因都是类似的，因为None没有next，基本都是这个错。</p><blockquote><p><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/solution/jian-zhi-offer-35-fu-za-lian-biao-de-fu-zhi-ha-xi-/">题解</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">self, head: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="comment"># 1. 复制各节点，并构建拼接链表</span></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = Node(cur.val)</span><br><span class="line">            tmp.<span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = tmp</span><br><span class="line">            cur = tmp.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 2. 构建各新节点的 random 指向</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur.random:</span><br><span class="line">                cur.<span class="built_in">next</span>.random = cur.random.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 3. 拆分两链表</span></span><br><span class="line">        cur = res = head.<span class="built_in">next</span></span><br><span class="line">        pre = head</span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span>:</span><br><span class="line">            pre.<span class="built_in">next</span> = pre.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        pre.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 单独处理原链表尾节点</span></span><br><span class="line">        <span class="keyword">return</span> res      <span class="comment"># 返回新链表头节点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Day03-字符串"><a href="#Day03-字符串" class="headerlink" title="Day03 字符串"></a>Day03 字符串</h1><blockquote><p><a href="https://www.runoob.com/python/python-strings.html">Python字符串操作</a><br><a href="https://www.runoob.com/python/python-strings.html">字符串用到的join函数</a></p></blockquote><p>在 Python 和 Java 等语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。<br>感觉很好用的一个操作就是可以直接相加，并且按位索引，很像列表，比如旋转字符串的题可以直接s[n:]+s[:n]，如果不允许用切片的话，就是用列表写了，然后用join函数转换为字符串</p><p>还有一个哈希表的事，现在Python3.6之后的字典默认是有序的，也就不需要再定义OrderedDict</p><h1 id="Day04-05-查找算法"><a href="#Day04-05-查找算法" class="headerlink" title="Day04-05 查找算法"></a>Day04-05 查找算法</h1><blockquote><p>这一部分重要的方法就是二分法，尤其适用于本来内部有序的数组，mid = (a+b)//2，表示向下取整，这个还是有好几个题可以看的</p></blockquote><h2 id="03-数组中重复的数字"><a href="#03-数组中重复的数字" class="headerlink" title="03 数组中重复的数字"></a>03 数组中重复的数字</h2><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">self, nums: [<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[i] == i:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[nums[i]] == nums[i]: <span class="keyword">return</span> nums[i]</span><br><span class="line">            nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>注意最后一行交换两个数时的a,b = c,d赋值语句：Python操作的原理是先暂存元组 (c, d)，然后 “按左右顺序” 赋值给 a 和 b 。<br>因此，若写为 nums[i], nums[nums[i]] = nums[nums[i]],nums[i]，则 nums[i] 会先被赋值nums[nums[i]]，之后赋值时 nums[nums[i]] ，元素索引会出现错误，因为这个时候nums[i]已经被改变<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">i = <span class="number">2</span> <span class="comment">#交换位置2和位置3（nums[2]=3）</span></span><br><span class="line">nums[i],nums[nums[i]]=nums[nums[i]],nums[i]</span><br><span class="line"><span class="built_in">print</span>(nums)<span class="comment">#[1,2,4,4,5]发生错误</span></span><br><span class="line">nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">nums[nums[i]],nums[i]=nums[i],nums[nums[i]]</span><br><span class="line"><span class="built_in">print</span>(nums)<span class="comment">#[1,2,4,3,5]正确</span></span><br></pre></td></tr></table></figure></p><blockquote><p><a href="https://m.php.cn/article/471345.html">Python删除元素方法</a></p></blockquote><h2 id="53-I-在排序数组中查找数字"><a href="#53-I-在排序数组中查找数字" class="headerlink" title="53 I.在排序数组中查找数字"></a>53 I.在排序数组中查找数字</h2><p>统计一个数字在排序数组中出现的次数。<br>输入: nums = [5,7,7,8,8,10], target = 8<br>输出: 2</p><blockquote><p>有序数组基本都用二分法，时间复杂度<script type="math/tex">O(logN)</script></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, nums: [<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">tar</span>):</span></span><br><span class="line">            i, j = <span class="number">0</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">                m = (i + j) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt;= tar: i = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: j = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> helper(target) - helper(target - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>i = m+1 和j = m-1的目的是为了保证，如果target存在的话，始终在[i,j]这个区间内，<br>若 nums[m] &lt; targe，则 target 在闭区间[m+1,j]中，因此执行 i = m + 1<br>若 nums[m] &gt; target，则 target 在闭区间[i,m−1]中，因此执行 j = m - 1；<br>若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；因此和nums[m] &lt; targe，保持一致，这样保证了右边界在[i,j]这个区间内，但是对于nums[m] &gt; target，的情况，执行j = m-1后，很可能右边界就不在[i,j]内了，这种情况的话右边界就是j+1,不过不用担心的是，<strong>循环结束前的最后一次循环一定是i=j,并且如果存在target的话，i和j(i=j=m)指向的都是最右边的target或者右边界</strong>,如果指向target,执行i=m+1,刚好指向右边界,如果指向右边界，执行j = m-1,i仍指向右边界。<br>这个比较好理解，i小于等于target时总是往右移，而j只有大于target时才往左移，所以两者都是共同逼近最右边的target<br>特殊情况,就是target比最左边的数还小时，j会不断左移，直到i和j都指向0，此时仍然比target大,j=-1,i=0,同理比最右边的数大时，i会不断右移，最终i=len(nums),<br>最后一行也比较好理解，helper(target)指向比target大的第一个数，helper(target-1)指向比target-1大的第一个数，如果存在target,则刚好指向第一个target,如果不存在，他和helper(target)指向的都是同一个数。</p><blockquote><p><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/solution/mian-shi-ti-53-i-zai-pai-xu-shu-zu-zhong-cha-zha-5/">题解</a></p></blockquote><h1 id="Day06-07-搜索与回溯算法"><a href="#Day06-07-搜索与回溯算法" class="headerlink" title="Day06-07 搜索与回溯算法"></a>Day06-07 搜索与回溯算法</h1><h1 id="Day08-10-动态规划"><a href="#Day08-10-动态规划" class="headerlink" title="Day08-10 动态规划"></a>Day08-10 动态规划</h1><blockquote><p>Those who cannot remember the past are condemned to repeat it.<br>要不要这么哲理啊，哈哈哈</p></blockquote><p>以斐波那契数为例，最容易想到的递归，其实一直在重复调用，造成了很大的时间（重复计算）和空间浪费（保存中间结果）<br>解决办法：</p><ol><li>自顶向下，相当于建立了一个备忘录，创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在Memo数组中，下次在调用fib（n）的时候就不会重新递归了。问题就是空间浪费，需要有个数组存放</li><li>自下向上，计算fib（6）的时候最后还是要计算出fib（1），fib（2），fib（3）…,那么何不先计算出fib（1），fib（2），fib（3）…,呢？这也就是动态规划的核心，先计算子问题，再由子问题计算父问题。实现了对空间的压缩。</li></ol><p>逆向思维：这个我真的是没有<br>青蛙跳楼梯，可以一次跳一个或两个，问跳n阶有几种方案f(n),那其实，他最后一步，要么是跳一个，就有f(n-1)种，要么是跳两个，就有f(n-2)种，f(n) = f(n-1)+f(n-2)</p><blockquote><p><a href="https://blog.csdn.net/u013309870/article/details/75193592">动态规划</a></p></blockquote>]]></content>
    
    
    <summary type="html">剑指Offer31天打卡</summary>
    
    
    
    <category term="算法和数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>Pytorch笔记</title>
    <link href="http://example.com/2022/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2022/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</id>
    <published>2022-05-21T16:00:00.000Z</published>
    <updated>2022-07-08T06:59:41.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深度学习零碎知识"><a href="#深度学习零碎知识" class="headerlink" title="深度学习零碎知识"></a>深度学习零碎知识</h1><h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>&emsp;&emsp;常用的有如下两种，其中Sigmoid函数饱和时梯度非常小，接近于0，因此容易出现梯度消失现象。ReLu缺点在于反向传播过程中，如果有一个非常大的梯度经过时，反向传播更新后可能导致权重分布中心小于0，使得无法更新权重(此时ReLu后为0，不会再有梯度信息产生)，进入失活状态，且无法恢复。</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><ol><li><strong>SGD优化器</strong>： $w_{t+1} = w_t -\alpha*g(w_t)$容易受样本噪声影响，可能陷入局部最优解。</li><li><strong>SGD+Momentum优化器</strong>:  <script type="math/tex">v_t =\eta *v_{t-1}+\alpha*g(w_t),w_{t+1}=w_t-v_t</script>，引入了动量，优化时会考虑上一步的优化方向。</li><li><strong>Adagrad</strong>，<strong>RMSProp</strong>，<strong>Adam优化器</strong>：都属于自适应的优化器，比较接近，但各有不同，Adagrad的学习率下降可能会过快，在收敛前就收敛，RMS相对会慢一点，Adam则更复杂，包含了一阶动量和二阶动量，效果会更好一点。</li></ol><h2 id="ToTensor"><a href="#ToTensor" class="headerlink" title="ToTensor"></a>ToTensor</h2><p>&emsp;&emsp;值得注意的是，在将一个图片或者数组变为Tensor时，会将维度位置发生变化，(H x W x C)  变为  (C x H x W)。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToTensor</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Convert a ``PIL Image`` or ``numpy.ndarray`` to tensor. This transform does not support torchscript.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Converts a PIL Image or numpy.ndarray (H x W x C) in the range</span></span><br><span class="line"><span class="string">    [0, 255] to a torch.FloatTensor of shape (C x H x W) in the range [0.0, 1.0]</span></span><br><span class="line"><span class="string">    if the PIL Image belongs to one of the modes (L, LA, P, I, F, RGB, YCbCr, RGBA, CMYK, 1)</span></span><br><span class="line"><span class="string">    or if the numpy.ndarray has dtype = np.uint8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    In the other cases, tensors are returned without scaling.</span></span><br></pre></td></tr></table></figure><br>&emsp;&emsp;所以如果将tensor再还原时，要交换回来。<br><img src="https://gitee.com/KIKI9731/image/raw/master/QQ截图20220205203556.png" alt=""></p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>&emsp;&emsp;从下述交叉熵函数的定义可知，其中已经包含了Softmax函数，因此不需要再额外添加。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossEntropyLoss</span>(<span class="params">_WeightedLoss</span>):</span></span><br><span class="line">    <span class="string">r&quot;&quot;&quot;This criterion combines :class:`~torch.nn.LogSoftmax` and :class:`~torch.nn.NLLLoss` in one single class.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    It is useful when training a classification problem with `C` classes.</span></span><br><span class="line"><span class="string">    If provided, the optional argument :attr:`weight` should be a 1D `Tensor`</span></span><br><span class="line"><span class="string">    assigning weight to each of the classes.</span></span><br><span class="line"><span class="string">    This is particularly useful when you have an unbalanced training set.</span></span><br></pre></td></tr></table></figure></p><h1 id="OS相关操作"><a href="#OS相关操作" class="headerlink" title="OS相关操作"></a>OS相关操作</h1><p>os.getcwd() ,返回绝对路径<br>os.path.join(a,b)，拼接路径<br>os.path.abspath()，返回绝对路径，即磁盘中位置<br>../表示返回上级目录，则../..表示上两级目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">root = os.getcwd()</span><br><span class="line">root1 = os.path.join(root,<span class="string">&quot;../..&quot;</span>)</span><br><span class="line">data_root = os.path.abspath(root1)  </span><br><span class="line"><span class="comment">#root：C:\Users\asus\Desktop\科研\deep-learning-for-image-processing-master\pytorch_classification\Test2_alexnet</span></span><br><span class="line"><span class="comment">#root1:C:\Users\asus\Desktop\科研\deep-learning-for-image-processing-master\pytorch_classification\Test2_alexnet\../..</span></span><br><span class="line"><span class="comment">#data_root：C:\Users\asus\Desktop\科研\deep-learning-for-image-processing-master</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data_root = os.path.abspath(os.path.join(os.getcwd(), <span class="string">&quot;../..&quot;</span>))  <span class="comment"># get data root path</span></span><br><span class="line">image_path = os.path.join(data_root, <span class="string">&quot;data_set&quot;</span>, <span class="string">&quot;flower_data&quot;</span>)  <span class="comment"># flower data set path os.getcwd(),返回当前工作目录</span></span><br><span class="line"><span class="comment">#image_path：&#x27;C:\\Users\\asus\\Desktop\\科研\\deep-learning-for-image-processing-master\\data_set\\flower_data&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="Pytorch相关操作"><a href="#Pytorch相关操作" class="headerlink" title="Pytorch相关操作"></a>Pytorch相关操作</h1><h2 id="torch-nn-ReLU"><a href="#torch-nn-ReLU" class="headerlink" title="torch.nn.ReLU"></a>torch.nn.ReLU</h2><p>nn.ReLU(inplace=True)<br>第一，inplace 默认为False；inplace为True，将会改变输入的数据 ，否则不会改变原输入，只会产生新的输出。<strong>设置为True时相当于原地操作，降低内存</strong><br>第二，inplace 取值不影响loss 的反向传播，计算时可直接予以忽略。</p><p><strong>注意不能直接使用m = nn.ReLU(m)，因为这是个类，要先实例化</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m = torch.randn(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">f = nn.ReLU()</span><br><span class="line">f1 = nn.ReLU(inplace = <span class="literal">True</span>)</span><br><span class="line">n = f(m)</span><br><span class="line"><span class="built_in">print</span>(m,n)<span class="comment">#可以看到m并不发生变化</span></span><br><span class="line"><span class="comment">#tensor([[ 0.1669,  1.5454,  0.6119, -1.2171, -0.4712]]) tensor([[0.1669, 1.5454, 0.6119, 0.0000, 0.0000]])</span></span><br><span class="line">n = f1(m)</span><br><span class="line"><span class="built_in">print</span>(m,n)<span class="comment">#inplace = True,m的值也发生变化</span></span><br><span class="line"><span class="comment">#tensor([[0.1669, 1.5454, 0.6119, 0.0000, 0.0000]]) tensor([[0.1669, 1.5454, 0.6119, 0.0000, 0.0000]])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="torch-nn-Conv2d"><a href="#torch-nn-Conv2d" class="headerlink" title="torch.nn.Conv2d()"></a>torch.nn.Conv2d()</h2><p>padding 这个参数可以是整形(上下左右一致)和tuple<br>tuple(a,b)表示在上下各补a行，左右各补b列<br>如果要精确控制每一边，需要使用<strong>torch.nn.ZeroPad2d((1,1,2,0))，分别表示了左，右，上，下</strong><br>卷积计算后如果大小不是整数，会进行向下取整（把右边和下面的padding行/列舍去），具体可参考如下连接:</p><blockquote><p><a href="https://blog.csdn.net/qq_37541097/article/details/102926037?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165329262516781685394456%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=165329262516781685394456&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-102926037-null-null.nonecase&amp;utm_term=%E5%8D%B7%E7%A7%AF&amp;spm=1018.2226.3001.4450">霹雳吧啦的卷积操作详解</a><br><a href="https://blog.csdn.net/qinglv1/article/details/97815050">卷积和池化操作不为整数时的处理</a></p></blockquote><p>结论：<strong>卷积向下取整，池化向上取整</strong></p><h2 id="torch-tensor-item"><a href="#torch-tensor-item" class="headerlink" title="torch.tensor.item()"></a>torch.tensor.item()</h2><p>Returns the value of this tensor as a standard Python number. This only works for tensors with one element. This operation is not differentiable.</p><h2 id="torchvision-datasets-ImageFolder-root-str"><a href="#torchvision-datasets-ImageFolder-root-str" class="headerlink" title="torchvision.datasets.ImageFolder(root:str)"></a><a href="https://pytorch.org/vision/stable/generated/torchvision.datasets.ImageFolder.html?highlight=dataset%20image#torchvision.datasets.ImageFolder">torchvision.datasets.ImageFolder(root:str)</a></h2><p>可以直接根据文件所在路径生成数据集<br>root/dog/xxx.png<br>root/dog/xxy.png<br>root/dog/[…]/xxz.png</p><p>root/cat/123.png<br>root/cat/nsdf3.png<br>root/cat/[…]/asd932_.png</p><p>根据这种文件组成，生成数据集后，会包含class_to_idx一个属性值，是类别和编号的字典。</p><h1 id="Tensorboard-pytorch"><a href="#Tensorboard-pytorch" class="headerlink" title="Tensorboard pytorch"></a>Tensorboard pytorch</h1><ol><li>导入相关库，并实例化 SummaryWriter 对象，指定存放地址<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch.utils.tensorboard <span class="keyword">import</span> SummaryWriter</span><br><span class="line">tb_writer = SummaryWriter(log_dir=<span class="string">&quot;runs/flower_experiment&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>生产网络结构图,在生成模型图的时候，是会走一遍前向传播的过程的，示例是图片网络，init_img用于初始化输入，在<strong>add_graph</strong>时，传入model,input<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例化模型</span></span><br><span class="line"> model = resnet34(num_classes=args.num_classes).to(device)</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 将模型写入tensorboard</span></span><br><span class="line"> init_img = torch.zeros((<span class="number">1</span>, <span class="number">3</span>, <span class="number">224</span>, <span class="number">224</span>), device=device)</span><br><span class="line"> tb_writer.add_graph(model, init_img)</span><br></pre></td></tr></table></figure></li><li>生成训练过程中的参数,tag表示标签值，然后是y，x,设置在每一个epoch后传入，optimizer的param_groups是一个列表，但是只有一个元素，是字典类型，包含了’lr’和’weight_decay’等信息<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tags = [<span class="string">&quot;train_loss&quot;</span>, <span class="string">&quot;accuracy&quot;</span>, <span class="string">&quot;learning_rate&quot;</span>]</span><br><span class="line">tb_writer.add_scalar(tags[<span class="number">0</span>], mean_loss, epoch)</span><br><span class="line">tb_writer.add_scalar(tags[<span class="number">1</span>], acc, epoch)</span><br><span class="line">tb_writer.add_scalar(tags[<span class="number">2</span>], optimizer.param_groups[<span class="number">0</span>][<span class="string">&quot;lr&quot;</span>], epoch)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>生成网络某层的具体权重<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tb_writer.add_histogram(tag=<span class="string">&quot;conv1&quot;</span>,</span><br><span class="line">                        values=model.conv1.weight,</span><br><span class="line">                        global_step=epoch)</span><br><span class="line">tb_writer.add_histogram(tag=<span class="string">&quot;layer1/block0/conv1&quot;</span>,</span><br><span class="line">                        values=model.layer1[<span class="number">0</span>].conv1.weight,</span><br><span class="line">                        global_step=epoch)</span><br></pre></td></tr></table></figure>启用Tensorboard<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorboard --logdir=CMPASS </span><br></pre></td></tr></table></figure><h1 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h1><blockquote><p><a href="https://pytorch.org/docs/stable/generated/torch.nn.LSTM.html?highlight=lstm#torch.nn.LSTM">LSTM官方文档</a><br><a href="https://zhuanlan.zhihu.com/p/32085405">LSTM原理解释</a></p></blockquote></li></ol><p>LSTM训练的参数个数：[（5+10）<em>10+10]</em>4<br>官方代码详解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn              </span><br><span class="line"><span class="built_in">input</span> = torch.randn(<span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># 序列长度seq_len=5, batch_size=3, 数据向量维数=10，相当于每次运行时取3个含有5个字的句子（且句子中每个字的维度为10）</span></span><br><span class="line"></span><br><span class="line">rnn = nn.LSTM(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>) </span><br><span class="line"><span class="comment"># (input_size,hidden_size,num_layers)</span></span><br><span class="line"><span class="comment"># 输入数据x的向量维数10, 设定lstm隐藏层的特征维度20, 此model用2个lstm层。如果是1，可以省略，默认为1) </span></span><br><span class="line"><span class="comment"># 初始化的隐藏元和记忆元,通常它们的维度是一样的</span></span><br><span class="line"></span><br><span class="line">h_0 = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line">c_0 = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">20</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 这里有2层lstm，output是最后一层lstm的每个词向量对应隐藏层的输出,其与层数无关，只与序列长度相关</span></span><br><span class="line"><span class="comment"># hn,cn是所有层最后一个隐藏元和记忆元的输出</span></span><br><span class="line">output, (h_n, c_n)= rnn(<span class="built_in">input</span>, (h_0, c_0))</span><br><span class="line"><span class="comment"># 一般只用output,可以写成output,_=rnn(input, (h_0, c_0))</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(output.size(),h_n.size(),c_n.size())</span><br><span class="line"><span class="comment">#[5,3,20]表示每个单词的输出h，序列长度为5</span></span><br><span class="line"><span class="comment">#[2,3,20]表示最后一个时刻两层lstm的输出h,所以其实h_n的第二层，也就是h_n[1]是等于output的最后一个序列的输出output[4]的,维度都是[3,20]</span></span><br><span class="line"><span class="comment">#[2,3,20]c_n其实表示的是最后一个时间步LSTMcell的状态，一般用不到</span></span><br></pre></td></tr></table></figure><p>参数：</p><ol><li>batch_first:注意的是输入第一个维度5是序列长度，而不是batch_size,因为batch_first默认为<strong>false</strong>,可以更改这个参数而00BA2409.png第一个维度是batch_size </li><li>bidirectional:是否为双向，默认也是false，注意如果改为双向的话，h_0和c_0应该改为(4,3,20),因为相当于左边需要一个h_0,右边也需要一个h_0,这个时候最后一行的输出为：<br>torch.Size([5, 3, <strong>40</strong>]) torch.Size([4, 3, 20]) torch.Size([4, 3, 20])，但这个时候h_n和output的关系并不是那么简单的相等，因为ouptput的最后一个是相互拼接的，由正向的最后一个序列（理解为句子中的最后一个单词）的输出和反向的第一个序列（句子正向的最后一个单词）的输出拼接而成。而h_n在反向时对应的是（句子正向的第一个单词）。</li></ol><p>将LSTM改为单层，并设置双向，测试输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 都取batch_size=0,即第一个句子</span></span><br><span class="line"><span class="built_in">print</span>(output[<span class="number">4</span>][<span class="number">0</span>])<span class="comment">#可以看到output的最后一项的前20个数，对应正向计算的最后一个单词，和h_n的第一个维度相等</span></span><br><span class="line"><span class="built_in">print</span>(output[<span class="number">0</span>][<span class="number">0</span>])<span class="comment">#output第一项的后20个数，对应反向计算的第一个单词，和h_n的第二个维度相等</span></span><br><span class="line"><span class="built_in">print</span>(h_n[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"><span class="built_in">print</span>(h_n[<span class="number">1</span>][<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p><ol><li>tensor([ <strong>0.1486,  0.2394,  0.0672,  0.0645,  0.2413,  0.1021,  0.1093, -0.0268,0.0157,  0.2620,  0.0952, -0.0359, -0.0067,  0.2475, -0.2389,  0.0544,-0.0097, -0.0465, -0.0333,  0.0519,</strong> -0.1379,  0.2641,  0.0414, -0.3096,0.2469, -0.0276, -0.2040, -0.1074,  0.4427, -0.3472, -0.6091,  0.0125,-0.3494, -0.0487,  0.0893,  0.1615, -0.1351, -0.1330,  0.0262,  0.0840],grad_fn=<SelectBackward>)</li><li>tensor([-0.0323, -0.0765,  0.0101,  0.6987, -0.3392, -0.3428,  0.0212,  0.2404,0.0286, -0.2180,  0.1832,  0.0844,  0.0097,  0.0379, -0.0442, -0.3454,0.4237, -0.0644,  0.2047,  0.3235, <strong>-0.1628,  0.1715,  0.1617, -0.0527,0.0454, -0.2222, -0.1592, -0.0439,  0.0854, -0.1595, -0.0295,  0.0063,0.1224, -0.2310, -0.0087,  0.5124, -0.0599, -0.0084,  0.0964, -0.1349],grad_fn=<SelectBackward>)</strong></li><li>tensor([ 0.1486,  0.2394,  0.0672,  0.0645,  0.2413,  0.1021,  0.1093, -0.0268,0.0157,  0.2620,  0.0952, -0.0359, -0.0067,  0.2475, -0.2389,  0.0544,-0.0097, -0.0465, -0.0333,  0.0519], grad_fn=<SelectBackward>)</li><li>tensor([-0.1628,  0.1715,  0.1617, -0.0527,  0.0454, -0.2222, -0.1592, -0.0439,0.0854, -0.1595, -0.0295,  0.0063,  0.1224, -0.2310, -0.0087,  0.5124,-0.0599, -0.0084,  0.0964, -0.1349], grad_fn=<SelectBackward>)</li></ol><blockquote><p>详细可参考<a href="https://blog.csdn.net/qq_35605081/article/details/110734176">双向LSTM图解</a></p></blockquote>]]></content>
    
    
    <summary type="html">记录Pytorch的一些小tips</summary>
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>非线性数据结构（树）</title>
    <link href="http://example.com/2022/02/05/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%A0%91)/"/>
    <id>http://example.com/2022/02/05/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%A0%91)/</id>
    <published>2022-02-04T16:00:00.000Z</published>
    <updated>2022-05-22T04:17:56.050Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><p>&emsp;&emsp;如果数据是固定不动的，则查找数据称为静态查找（没有插入和删除操作，只有查找），如果数据会发生变化，则是动态查找。对于静态查找，可以是顺序查找，则时间复杂度为O(N)，或者二分查找，元素本身是有序排列的，时间复杂度为O(logN)，二分查找时，定义了pre,end,mid。每次查找后，end = mid - 1,或者pre = mid +1;不能直接等于mid，这样会出现死循环。根据二分查找的想法，构造了与之类似的数据结构————<strong>树</strong>，因此查找次数不会超过数的层数，也即是O(logN)。<br>&emsp;&emsp;实现时，可以通过链表实现，但如果链表指向子树，对于大部分比较稀疏或者度数较大的树，会造成很大的浪费，因此可以将链表设置为2个指针，分别指向兄弟节点和子节点（下图左）。对于二叉树，则可以直接将两个指针分别指向其左右子节点（下图右）。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220207121828.png" alt=""></p><h2 id="定义与实现"><a href="#定义与实现" class="headerlink" title="定义与实现"></a>定义与实现</h2><p>&emsp;&emsp;树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。<br>&emsp;&emsp;一棵有n个节点的树，一共有n-1条边，根节点没有，其中节点的子树个数称为<strong>结点的度</strong>，一个树的度是节点中最大的度数，二叉树的度数为2，叶结点的度数为0。假设定义$n_2$为度数为2的结点数，$n_0$为叶结点树，则$n_2+1=n_0$，因为$2n_2+n_1(每个结点下的边数)=n_0+n_1+n_2-1(节点数-1)$。<br>&emsp;&emsp;二叉树第$i$层，最多有$2^{i-1}$个结点，层数为i的二叉树，最多有$2^i-1$个结点。<br>&emsp;&emsp;<strong>完美二叉树（满二叉树）</strong>，是指每层都是满的二叉树，仅最后一层不满的且缺少的结点连续，都在右侧时为<strong>完全二叉树</strong>，其结点的标号和完美二叉树一致。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220205135620.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x      <span class="comment"># 节点值</span></span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 左子节点</span></span><br><span class="line">        self.right = <span class="literal">None</span> <span class="comment"># 右子节点</span></span><br><span class="line"><span class="comment"># 初始化节点</span></span><br><span class="line">        n1 = TreeNode(<span class="number">3</span>) <span class="comment"># 根节点 root</span></span><br><span class="line">        n2 = TreeNode(<span class="number">4</span>)</span><br><span class="line">        n3 = TreeNode(<span class="number">5</span>)</span><br><span class="line">        n4 = TreeNode(<span class="number">1</span>)</span><br><span class="line">        n5 = TreeNode(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建引用指向</span></span><br><span class="line">        n1.left = n2</span><br><span class="line">        n1.right = n3</span><br><span class="line">        n2.left = n4</span><br><span class="line">        n2.right = n5</span><br></pre></td></tr></table></figure><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>&emsp;&emsp;根据遍历根节点的顺序，分为<strong>前序，中序和后续遍历</strong>三种。通常使用递归实现，三种遍历的路径其实是一致的，区别在于每个节点输出的时刻，前序在第一次遇到该节点时即输出，中序在第二次，后序在第三次。除此之外，还有<strong>层次遍历</strong>，即从上到下，从左到右。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220207125754.png" alt=""><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span>            <span class="comment"># 树的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationTree</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data_list</span>):</span>         <span class="comment"># 把输入的列表初始化为可迭代对象</span></span><br><span class="line">        self.dataIter = <span class="built_in">iter</span>(data_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createTree</span>(<span class="params">self, root = <span class="literal">None</span></span>):</span>     <span class="comment"># 必须补充一句 默认参数root = None 不然会参数数量不匹配</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 新建一颗树 &quot;&quot;&quot;</span></span><br><span class="line">        next_data = <span class="built_in">next</span>(self.dataIter)    <span class="comment"># 步进获取下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> next_data == <span class="string">&#x27;#&#x27;</span>:               <span class="comment"># &quot;#&quot; 号表示叶节点，在程序中用 None 代替 &quot;#&quot; 号</span></span><br><span class="line">            root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:                              <span class="comment"># 是根节点，它还有孩子节点，所以继续创建Node</span></span><br><span class="line">            root = TreeNode(next_data)     <span class="comment"># 实例化对象（类似于struct）</span></span><br><span class="line">            root.left = self.createTree(root.left)</span><br><span class="line">            root.right = self.createTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 前序遍历 递归&quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            ans.append(root.val)  <span class="comment"># 前序遍历，root -&gt; left -&gt; right</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 中序遍历 递归&quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            ans.append(root.val)    <span class="comment"># 中序遍历，left -&gt; root -&gt; right</span></span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot; 后序遍历 递归&quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">            ans.append(root.val)   <span class="comment"># 后序遍历，left -&gt; right -&gt; root</span></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printTree</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 综合打印&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;递归 前序遍历：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        preOrder = self.preorderTraversal(root)</span><br><span class="line">        <span class="built_in">print</span>(preOrder, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;递归 中序遍历：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        inOrder = self.inorderTraversal(root)</span><br><span class="line">        <span class="built_in">print</span>(inOrder,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;递归 后序遍历：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        postOrder = self.postorderTraversal(root)</span><br><span class="line">        <span class="built_in">print</span>(postOrder, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    data = <span class="string">&#x27;abd#g###ce##fh###&#x27;</span></span><br><span class="line">    <span class="comment">#data = [1,2,&#x27;#&#x27;,&#x27;#&#x27;,3,&#x27;#&#x27;,&#x27;#&#x27;]</span></span><br><span class="line"></span><br><span class="line">    newTree = OperationTree(data)</span><br><span class="line">    root = newTree.createTree()</span><br><span class="line">    newTree.printTree()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归 前序遍历： [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;g&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;h&#x27;] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">递归 中序遍历： [&#x27;d&#x27;, &#x27;g&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;h&#x27;, &#x27;f&#x27;] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">递归 后序遍历： [&#x27;g&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;f&#x27;, &#x27;c&#x27;, &#x27;a&#x27;] </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>&emsp;&emsp;根据二分法的启示，建立一种二叉搜索树，其非空左子树的所有键值小于其根结点的键值，右子树相反，且左右子树都是二叉搜索树。应该实现插入，删除和查找这些基本操作。由于其内部顺序，其最小值为最左侧的结点，最大值为最右侧的结点。<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220207191720.png" alt=""><br>&emsp;&emsp;原因是，对于完全二叉树，如果有右结点，则一定有左结点，但是可以仅有左结点，没有右结点，所以，最小值一定是叶节点，因为如果不是，必有左结点，即必有更小的值，但最大值不一定，其可以是有左结点的一个结点。</p><h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><h2 id="L98-验证二叉搜索树"><a href="#L98-验证二叉搜索树" class="headerlink" title="L98 验证二叉搜索树"></a>L98 验证二叉搜索树</h2><p>&emsp;&emsp;很自然的想法就是利用递归，先对一个结点，判断其是否大于左结点，同时小于右结点，然后再判断其左右结点，在整个过程中，只要有一个地方不满足，则直接返回False,结束。但是在递归时，由于更改了原始的结点，所以其父结点的值无法保留，因此定义了一个新的函数，保存了父结点的值，并以范围的方式表示。</p><blockquote><p>方法1：递归，时间复杂度O(n),空间复杂度O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n)；</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">node, lower = <span class="built_in">float</span>(<span class="params"><span class="string">&#x27;-inf&#x27;</span></span>), upper = <span class="built_in">float</span>(<span class="params"><span class="string">&#x27;inf&#x27;</span></span>)</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            val = node.val</span><br><span class="line">            <span class="keyword">if</span> val &lt;= lower <span class="keyword">or</span> val &gt;= upper:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> helper(node.right, val, upper):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> helper(node.left, lower, val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> helper(root)</span><br></pre></td></tr></table></figure><blockquote><p>方法2：中序遍历,时间复杂度O(n)，其中 n 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。空间复杂度O(n)，其中 n 为二叉树的节点个数。栈最多存储 n 个节点，因此需要额外的 O(n) 的空间。中序遍历后对于二叉搜索树应该是按从小到大排列的，因此每次需要pop的值应该都比之前pop的值大。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        stack, inorder = [], <span class="built_in">float</span>(<span class="string">&#x27;-inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> root:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()<span class="comment">#每次pop的结点为没有左结点的结点，因此是中序，即应该为当前树中的最小值，之后pop的都应该比它大</span></span><br><span class="line">            <span class="comment"># 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树</span></span><br><span class="line">            <span class="keyword">if</span> root.val &lt;= inorder:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            inorder = root.val</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="剑指-Offer-33-二叉搜索树的后序遍历序列"><a href="#剑指-Offer-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指 Offer 33. 二叉搜索树的后序遍历序列"></a>剑指 Offer 33. 二叉搜索树的后序遍历序列</h2><p>&emsp;&emsp;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。<br>&emsp;&emsp;假如是一个二叉搜索树，则根据<strong>左结点-右结点-根节点</strong>的后序遍历顺序，最后一个元素为根节点，且小于所有的右结点，因此从数组最左边开始遍历，一旦找到大于根结点的值（<strong>代码中用q表示</strong>），则从当前位置到根节点之前（<strong>postorder[q,j-1]</strong>），应该都大于根结点，同时其左右子树（<strong>postorder[i,q-1]，postorder[q,j-1]</strong>）再进行递归。</p><blockquote><p>方法1：递归：时间复杂度$O(N^2)$ ,每次递归的时候减去一个根节点，因此递归占用$O(N)$ ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用$O(N)$。<br>空间复杂度$O(N)$:最差情况下（即当树退化为链表），递归深度将达到N。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verifyPostorder</span>(<span class="params">self, postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">judge</span>(<span class="params">i,j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            p = i</span><br><span class="line">            <span class="keyword">while</span> postorder[p]&lt;postorder[j]:</span><br><span class="line">                p+=<span class="number">1</span></span><br><span class="line">            q = p</span><br><span class="line">            <span class="keyword">while</span> postorder[p]&gt;postorder[j]:</span><br><span class="line">                p+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p==j:                </span><br><span class="line">                <span class="keyword">return</span> judge(i,q-<span class="number">1</span>) <span class="keyword">and</span> judge(q,j-<span class="number">1</span>) </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> judge(<span class="number">0</span>,<span class="built_in">len</span>(postorder)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>方法2：辅助栈，时间复杂度降到O(N)<br>&emsp;&emsp;在后序遍历时，在遍历完右结点后会访问根节点，所以如果是完全二叉树，必然会出现一个<strong>数值减小</strong>的过程，但是必须从后往前看，因为从前往后看，树的结构不清楚，会比较乱，那么从后往前看，每次<strong>数值增大</strong>都是从根节点到右结点的过程，设计一个栈进行该操作，当出现<strong>数值减小</strong>时，说明遇到了左结点，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    
    <summary type="html">关于树的知识和算法题总结</summary>
    
    
    
    <category term="算法和数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>线性数据结构</title>
    <link href="http://example.com/2022/02/01/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/02/01/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-01-31T16:00:00.000Z</published>
    <updated>2022-05-22T04:20:15.111Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>&emsp;&emsp;特点是插入删除容易，但查找不容易，因此，在涉及链表查找的题目时，一般用哈希表来实现，哈希表通过哈希函数将一个输入插入到固定位置，因此哈希表有可能出现空间的浪费，因为插入时不是连续的，但是查找时方便，是用空间换时间的一种方法。发生哈希冲突时则是以链表存储的。</p><p>&emsp;&emsp;除此之外，由于链表并不需要初始化长度，因此采用动态内存分配，区别于数组，数组在内存中的空间是连续的，但是链表在内存中不连续。链表属于动态分配，需要申请内存空间(C++中用new)，但是需要手动释放(用delete)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">/*数据类型 *指针名称 = new 数据类型 </span></span><br><span class="line"><span class="comment">或</span></span><br><span class="line"><span class="comment">数据类型 *指针名称 = new 数据类型（初值）；*/</span></span><br><span class="line"><span class="keyword">delete</span> p<span class="comment">//delete指针名称</span></span><br><span class="line"><span class="comment">//如果分配成功，会返回内存空间起始地址，不成功返回NULL</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220128171114.png" alt=""></p><blockquote><p>使用结构体指针访问变量中成员的两种格式：(*指针变量).成员名  或者  指针变量-&gt;成员名</p></blockquote><p>用C++初始化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;        <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *next; <span class="comment">// 后继节点引用</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//结构体的初始化函数，传入x则自动给val赋值x</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例化节点</span></span><br><span class="line">ListNode *n1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>); <span class="comment">// 节点 head</span></span><br><span class="line">ListNode *n2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">ListNode *n3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1-&gt;next = n2;</span><br><span class="line">n2-&gt;next = n3;</span><br></pre></td></tr></table></figure><br>用Python初始化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x     <span class="comment"># 节点值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 后继节点引用</span></span><br><span class="line"><span class="comment"># 实例化节点</span></span><br><span class="line">n1 = ListNode(<span class="number">4</span>) <span class="comment"># 节点 head</span></span><br><span class="line">n2 = ListNode(<span class="number">5</span>)</span><br><span class="line">n3 = ListNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建引用指向</span></span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br></pre></td></tr></table></figure></p><h2 id="链表实现-Python"><a href="#链表实现-Python" class="headerlink" title="链表实现(Python)"></a>链表实现(Python)</h2><blockquote><p>参考自：<a href="https://blog.csdn.net/Blood_Seeker/article/details/78992722">https://blog.csdn.net/Blood_Seeker/article/details/78992722</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment">#结点初始化函数, p 即模拟所存放的下一个结点的地址</span></span><br><span class="line">    <span class="comment">#为了方便传参, 设置 p 的默认值为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x = <span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#链表初始化函数, 方法类似于尾插</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initList</span>(<span class="params">self, dataList</span>):</span></span><br><span class="line">        <span class="comment">#创建头结点</span></span><br><span class="line">        self.head = ListNode(<span class="literal">None</span>) <span class="comment"># 创建节点的时候传一个参数进去    # 创建头结点，里面不包含数据，头结点之后第一个才存放数据,head节点的数据默认None</span></span><br><span class="line">        pTail = self.head              <span class="comment"># 指向头结点的指针</span></span><br><span class="line">        <span class="comment">#逐个为 data 内的数据创建结点, 建立链表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dataList:            <span class="comment"># 遍历列表</span></span><br><span class="line">            newNode = ListNode(i)        <span class="comment"># 生成新的节点</span></span><br><span class="line">            pTail.<span class="built_in">next</span> = newNode      <span class="comment"># 新节点挂在尾结点上，即 上一个节点指针指向新的节点，由于新节点的next被初始化为None，所以pTail的next自然也是None</span></span><br><span class="line">            pTail = newNode          <span class="comment"># 当前新节点成为新的尾结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#链表判空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#取链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        p = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">len</span> += <span class="number">1</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traveList</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;link list traving result:&#x27;</span>)</span><br><span class="line">        p = self.head.<span class="built_in">next</span>   <span class="comment"># 取得表头之后的第一个数据</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">print</span> (p.val, end= <span class="string">&quot; &quot;</span>)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#链表插入数据函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertElem</span>(<span class="params">self, val, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 在 第index个节点(p.next)之前插入&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        p = self.head</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> i &lt; index:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> i &gt; index:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR, 无法插入节点&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        pNew = ListNode(val)    <span class="comment"># 生成新的节点 包含了 pNew.val = key</span></span><br><span class="line">        pNew.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = pNew</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteElem</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;删除第index个节点（即删除 p.next节点）&quot;</span></span><br><span class="line"></span><br><span class="line">        p = self.head</span><br><span class="line">        i = <span class="number">1</span>             <span class="comment"># 节点计数</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> i &lt; index:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> i &gt; index:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR, 该节点不存在&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        delVal = p.<span class="built_in">next</span>.val</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;deleted value:&quot;</span>, delVal)</span><br><span class="line">        p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#初始化链表与数据</span></span><br><span class="line">    <span class="comment"># data = [1,2,3,4,5]</span></span><br><span class="line">    dataList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    l = LinkList()</span><br><span class="line">    l.initList(dataList)</span><br><span class="line">    l.traveList()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(l.getLength())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#插入结点到索引值为3之后, 值为666</span></span><br><span class="line">    l.insertElem(<span class="number">666</span>, <span class="number">6</span>)</span><br><span class="line">    l.traveList()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#删除索引值为4的结点</span></span><br><span class="line">    l.deleteElem(<span class="number">4</span>)</span><br><span class="line">    l.traveList()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="一些链表相关题目"><a href="#一些链表相关题目" class="headerlink" title="一些链表相关题目"></a>一些链表相关题目</h2><h3 id="L160-相交链表"><a href="#L160-相交链表" class="headerlink" title="L160 相交链表"></a>L160 相交链表</h3><p>   &emsp;&emsp;这道题注意的是不仅仅是值相交，两个链表相交，则相交部分是完全一致的，因此可以用哈希表实现，也可以用<strong>双指针</strong>实现，两个指针分别从链表A(总长a)和链表B(总长b)的头出发，当到达结尾后，转向另一个链表，则如果两个链表有相交(相交部分为c)，此时都运动了a+b-c(a+(b-c)和b+(a-c));</p><h3 id="L141-环形链表"><a href="#L141-环形链表" class="headerlink" title="L141 环形链表"></a>L141 环形链表</h3><p>   &emsp;&emsp;利用<strong>双指针</strong>中的快慢指针，类比跑道上的两个速度不同的人，如果存在环形，则会相遇，但是注意的是两者的速度一定不同，而不能只是起点不同，起点不同不会相遇，会保持固定间隔。当然这种类似于查找是否有重复的，都可以用哈希表</p><blockquote><p>解法1：哈希表，时间复杂度O(n)，空间复杂度O(n)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span>                 </span><br><span class="line">        s = <span class="built_in">set</span>()             <span class="comment"># 定义一个set(集合，内部元素不重复)，然后不断遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> head:<span class="comment"># 如果某个节点在set中，说明遍历到重复元素了，也就是有环</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> s:     <span class="comment"># 不能把head.val这个值存在哈希表中，因为有可能只是值相同还不够，还需要指针也相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            s.add(head)       <span class="comment"># 如果节点不在哈希表中，说明之前没有相同节点，就存入表中  </span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>解法2：快慢双指针，时间复杂度O(n)，空间复杂度O(1)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:<span class="comment">#链表中是单元素且非循环或链表为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:<span class="comment">#只用考虑更快的指针，因为如果链表有限，则快指针先达到结束条件，必须加上fast.next，因为后面有fast.next.next，如果fast.next为null，则null不会有next变量，会报错</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="L234-回文链表"><a href="#L234-回文链表" class="headerlink" title="L234 回文链表"></a>L234 回文链表</h3><p>&emsp;&emsp;实现时，先利用快慢指针，找到链表的中间节点，可以参考后面的面试问题中有提到，同时在指针移动的过程中，进行反转链表，之后从中间位置往两个方向展开。<br>&emsp;&emsp;需要注意的是，对于奇数，慢指针会停在最中间的元素，因此在展开前需要将其后移一位，偶数，则指在中间靠后的元素，因此不需操作。<br>&emsp;&emsp;关于如何判断元素数是奇还是偶，可以对比跳出循环的条件：对于快指针，依次指向0，2，4，即<strong>fast指向元素的索引始终为偶数</strong>，所以如果有偶数个元素，最后一个元素索引为奇数，则倒数第二次循环后,fast指向倒数第二个元素，fast.next指向最后一个，再次进入循环，此时fast为null,fast.next会报错，但因为是and所以不会,<strong>and前是0，自动忽略后面语句（短路现象），如果改为fast.next and fast则会报错</strong>。如果有奇数个元素，则最后一次循环q指向最后一个元素,q.next=null;<strong>即奇数个元素，fast.next=null,偶数个元素，fast=null,所以if(fast)：在奇数时执行</strong>，而为了反转链表引入的pre和prepre则始终在慢指针前面一位，反转时先将pre后移，然后将prepre赋给pre.next，即pre-&gt;prepre,然后prepre后移，即循环结束时，两者指向同一元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (head <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        pre = head</span><br><span class="line">        prepre = ListNode(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast <span class="keyword">and</span> fast.<span class="built_in">next</span>):</span><br><span class="line">            pre = slow             <span class="comment"># pre 紧跟在slow 后面一步</span></span><br><span class="line"></span><br><span class="line">            slow = slow.<span class="built_in">next</span>       <span class="comment"># 快慢指针用于找到中间节点 </span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            pre.<span class="built_in">next</span> = prepre      <span class="comment"># 用于反转前半部分链表</span></span><br><span class="line">            prepre = pre</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast):                 <span class="comment"># 如果跳出上一个while循环是 fast.next is None,那么就是奇数个节点，slow需要再走一步</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>(pre <span class="keyword">and</span> slow):       <span class="comment"># 从中间对称的位置往两边扩展，比对两边的数是否相等 </span></span><br><span class="line">            <span class="keyword">if</span> (pre.val != slow.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><h2 id="链表面试问题"><a href="#链表面试问题" class="headerlink" title="链表面试问题"></a>链表面试问题</h2><p>&emsp;&emsp;无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用<strong>双指针</strong>来解决。</p><blockquote><p>双指针并不是固定的公式，而是一种思维方式~</p></blockquote><p>&emsp;&emsp;先来看”倒数第k个元素的问题”。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;   <span class="comment">//将 p指针移动 k 次</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;<span class="comment">//同时移动，直到 p == nullptr</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。<strong>fast 和 slow 的距离就会增加一。</strong>设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 指向中间两个结点的靠前一个还是靠后一个，需要调整循环的条件，下述代码是n为偶数的情况，慢指针指向<strong>靠后元素</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于上述代码：</p><blockquote><ol><li>比如n=5(下标0~4),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;4，此时q-&gt;next = null结束循环，p指向2，恰好是中间节点。（0，1，2，3，4）</li><li>比如n=4(下标0~3),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;null(2.next为3，3.next为null)，此时q = null结束循环，p指向2，是中间节点靠后一个。（0，1，2，3）</li><li>将条件改为while(q != nullptr &amp;&amp; q-&gt;next-&gt;next != nullptr)，会指向靠前一个，因为此时不会进行第二轮循环。</li></ol></blockquote><p>&emsp;&emsp;如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。<br>&emsp;&emsp;如何判断环的入口呢？<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220203130512.png" alt=""><br>&emsp;&emsp;由等式可知，相遇时d=x+ns(n为相遇时快指针多转了几圈)，则相遇后把两个指针速度变为一致，一个从起点出发，一个从相遇点出发，则因为<strong>d=x+ns</strong>，必然会在从相遇点出发的指针运动n圈+x后，在环的入口处相遇。(d为起点处出发指针路程，x+ns为从相遇点出发指针路程)，代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        walker = head</span><br><span class="line">        runner = head</span><br><span class="line">        <span class="keyword">while</span>(runner <span class="keyword">and</span> runner.<span class="built_in">next</span>):</span><br><span class="line">            walker = walker.<span class="built_in">next</span></span><br><span class="line">            runner = runner.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> walker == runner:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (runner.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>):  <span class="comment"># 如果是因为走到头而退出循环，那就是没有环</span></span><br><span class="line">            <span class="keyword">return</span>                                     <span class="comment"># return False 的话会报错Your returned value is not a ListNode type.</span></span><br><span class="line">        <span class="comment"># 如果是因为break而跳出循环，那就是有环</span></span><br><span class="line">        walker = head             <span class="comment"># 步行者回到起点</span></span><br><span class="line">        <span class="keyword">while</span>(walker != runner):  <span class="comment"># 没相遇</span></span><br><span class="line">            walker = walker.<span class="built_in">next</span></span><br><span class="line">            runner = runner.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> runner</span><br></pre></td></tr></table></figure><br>链表相关链接:</p><blockquote><ol><li><a href="https://zhuanlan.zhihu.com/p/31401474?utm_source=wechat_session&amp;utm_medium=social&amp;from=singlemessage">漫画算法：如何判断链表有环？</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/">L141环形链表</a></li></ol></blockquote><h1 id="一些刷题小总结"><a href="#一些刷题小总结" class="headerlink" title="一些刷题小总结"></a>一些刷题小总结</h1><h2 id="判断输入是否为None"><a href="#判断输入是否为None" class="headerlink" title="判断输入是否为None"></a>判断输入是否为None</h2><p>if not A 和 if A is None 看起来都是在判断A是否为空，实际上这两者是不同的：<br>（1）if not A 判断的是A是否为空，也就是说里面有东西没？<br>（2） if A is None则判断的是A是否声明并定义了？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:<span class="comment">#这里可以写成if head==None or head.next == None，但是其实是不一样的，因为如果head==None，则head.next会报错，因为Nonetype没有next的索引，即上述中的(2),不适用not则判断是否声明同时判断是否为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">记录刷题过程中的总结</summary>
    
    
    
    <category term="算法和数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="http://example.com/2022/01/13/C++/"/>
    <id>http://example.com/2022/01/13/C++/</id>
    <published>2022-01-12T16:00:00.000Z</published>
    <updated>2022-05-22T04:21:57.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h1><h2 id="前置-和后置-的区别："><a href="#前置-和后置-的区别：" class="headerlink" title="前置++和后置++的区别："></a>前置++和后置++的区别：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>,m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line">a = n++;<span class="comment">//后置++</span></span><br><span class="line">b = m--;</span><br><span class="line">c = ++n;<span class="comment">//前置++</span></span><br><span class="line">d = --m;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;<span class="comment">/*输出结果为5，10，7，8。首先对于后置++，可以看到对于a和b是先进行了赋值操作，再进行后置++。执行后a=15,b=10,n=6,m=9。对于前置++，首先进行前置++，再进行赋值操作*/</span></span><br></pre></td></tr></table></figure><p>后置++的优先级&gt;前置++的优先级&gt;乘和除的优先级&gt;…&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，！=&gt;赋值运算，优先级和上述性质无关。用优先性解释上述现象有矛盾，所以，可以按照这个记吧</p><h2 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (a)</span><br><span class="line">(int) a    //两种方式均可</span><br></pre></td></tr></table></figure><p>其优先级高于乘数法，和逻辑非，按位取反同级。<br>因此  double(n)/2  是先将n转换为double再做除法</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><blockquote><p>双目运算：&amp;&amp; ||<br>单目运算：!</p></blockquote><p>逻辑！负号-&gt;乘除运算等&gt;&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，!=&gt;逻辑&amp;&amp;&gt;逻辑||。<br>为了避免优先级的混乱，多使用圆括号</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote><p>&amp;，|，^(异或)，&lt;&lt;左移,&gt;&gt;右移,~(按位取反)</p></blockquote><p><strong>按位取反的时候要考虑到数据的字节数，对于一个正数，前面所有的0都要变成1</strong>,左移一位相当于<em>2，右移相当于除2。复合位运算(&amp;=，|=等)的结合顺序是<em>*从右向左</em></em>，除此之外还有(!,~,+,-,前置++/—)也是从右向左结合，比较特殊。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><ol><li>“=”赋值运算，其结合顺序是从右向左且其左侧(lvalue)不能是表达式，只能是变量，数组等</li><li>?:,比如y=(x&gt;=1?1:0)即可表达一个分段函数:y=1(x&gt;=1),y=0(x&lt;1)</li><li>逗号表达式，依次计算每个表达式的值，整体等于最后一个逗号后式子的值，如y=(1,2,3+5),则y=8</li></ol><hr><h2 id="算法优先级顺序"><a href="#算法优先级顺序" class="headerlink" title="算法优先级顺序"></a>算法优先级顺序</h2><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220113205502.png" alt=""></p><h2 id="数据类型转换原则"><a href="#数据类型转换原则" class="headerlink" title="数据类型转换原则"></a>数据类型转换原则</h2><p><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220113210115.png" alt=""></p><h2 id="整型变量和字符变量"><a href="#整型变量和字符变量" class="headerlink" title="整型变量和字符变量"></a>整型变量和字符变量</h2><p>其在内存中存放的都是整数，整数，存放的是二进制格式，字符，存放的是ASCII码值(<128)，因此可以出现以下形式：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">a = c+<span class="number">2</span>;<span class="comment">//将字符变量赋给整型变量</span></span><br><span class="line">c = <span class="number">98</span>; <span class="comment">//将整数常量赋给字符变量</span></span><br></pre></td></tr></table></figure><br>上述输出a=67,因为’A’的ASCII码的值为65<br>c = ‘b’,因为’b’的ASCII码的值为98</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>char name[40] = ‘zhang’;<br>转义字符：\r回车，回到本行开头，\n换行，到下一行开头<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;xjtu\nhello&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;xjtu123\rhello&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>执行得：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xjtu</span><br><span class="line">hello</span><br><span class="line">hello23//第二次cout的xjtu1被\r后的hello覆盖</span><br></pre></td></tr></table></figure></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>字符数组和字符串的区别在于，用字符串定义数组时，末尾是’\0’，如下图所示<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220115164804.png" alt=""><br>实例，将单词中的小写字母转换为大写字母：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i]=str[i]<span class="number">-32</span>;<span class="comment">//大小写字母的ASCII码差值为32</span></span><br><span class="line">        i = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>enum &lt;枚举类型名&gt;{枚举常量表}</p>]]></content>
    
    
    <summary type="html">主要总结C++的一些小的概念</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>深度学习回顾性记录</title>
    <link href="http://example.com/2022/01/11/%E4%B8%8D%E6%83%B3%E5%8F%91%E5%B8%83%E7%9A%84/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/01/11/%E4%B8%8D%E6%83%B3%E5%8F%91%E5%B8%83%E7%9A%84/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-01-10T16:00:00.000Z</published>
    <updated>2022-06-10T01:28:55.128Z</updated>
    
    
    
    
    <category term="深度学习" scheme="http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>如何利用Hexo搭建自己的博客</title>
    <link href="http://example.com/2022/01/10/Hexo/"/>
    <id>http://example.com/2022/01/10/Hexo/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-05-22T04:13:38.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>&emsp;&emsp;安装的过程可以参考 <a href="https://hexo.io/">Hexo官网</a>。<br>&emsp;&emsp;首先，需要保证安装好了node.js和git，这两个软件的安装也比较简单，直接官网安装就好。然后在命令行窗口中利用以下命令安装hexo，其中g代表对全局安装<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli-g</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;然后是新建一个文件夹，这个文件夹将自动生成一些默认的文件,之后的命令行窗口操作都是在该文件夹下进行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init [文件夹名]</span><br><span class="line">cd [文件夹名]</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;然后安装一下需要的依赖（可能就是默认工具包的意思？）<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;然后执行<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></p><h1 id="部署操作"><a href="#部署操作" class="headerlink" title="部署操作"></a>部署操作</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo s #生成本地预览</span><br><span class="line">hexo g #生成静态文章</span><br><span class="line">hexo d #上传，必须先执行hexo g</span><br></pre></td></tr></table></figure><h1 id="选择一个好看的主题"><a href="#选择一个好看的主题" class="headerlink" title="选择一个好看的主题"></a>选择一个好看的主题</h1><p>&emsp;&emsp;在 <a href="https://hexo.io/">Hexo官网</a>提供了很多主题，选择一个好看的主题后，点击进入主题对应的github中，即可看到相关的命令，仍然在该文件夹下执行命令后即可安装，安装后会在theme文件夹下看到一个对应得主题文件夹，比如这里我选择安装了<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a>主题，就会生成一个对应的文件夹<br><img src="https://cdn.jsdelivr.net/gh/KIKI9731/image@main/QQ截图20220110160802.png" alt=""></p><blockquote><p>Butterfly各种参数介绍及实际操作视频，强推这个宝藏UP啊<br><a href="https://space.bilibili.com/13282871/?spm_id_from=333.999.0.0">主题操作教程</a></p></blockquote><h1 id="Markdown写作基础"><a href="#Markdown写作基础" class="headerlink" title="Markdown写作基础"></a>Markdown写作基础</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下：<br><img src="https://raw.githubusercontent.com/KIKI9731/image/main/QQ%E6%88%AA%E5%9B%BE20220111152402.png" alt="image"></p><h2 id="字体效果"><a href="#字体效果" class="headerlink" title="字体效果"></a>字体效果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*斜体*</span><br><span class="line">~~删除~~</span><br><span class="line">==高亮==</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">加两个空格：&amp;emsp;&amp;emsp;（这个还挺麻烦的）</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下：<br>&emsp;&emsp;<strong>加粗</strong>  &emsp;&emsp;<em>斜体</em>&emsp;&emsp; <del>删除</del>&emsp;&emsp;==高亮==</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用内容</span><br><span class="line">&gt;&gt;增加&gt;数量可以设置多层引用</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下： </p><blockquote><p>引用内容</p><blockquote><p>增加&gt;数量可以设置多层引用</p></blockquote></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下： </p><hr><h2 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片的名字](网上图片的链接或者本地图片的路径)</span><br><span class="line">[连接名称](链接地址)</span><br><span class="line">比如：[baidu](www.baidu.com)</span><br></pre></td></tr></table></figure><h2 id="搭建图床"><a href="#搭建图床" class="headerlink" title="搭建图床"></a>搭建图床</h2><p>Gitee崩了啊可恶，还是Github香</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/489236769">Github图床搭建操作</a></p></blockquote><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><blockquote><p>可以参考链接：<a href="https://blog.csdn.net/weixin_42546496/article/details/88115095">https://blog.csdn.net/weixin_42546496/article/details/88115095</a></p></blockquote>]]></content>
    
    
    <summary type="html">记录利用Hexo的一些常用命令和步骤</summary>
    
    
    
    <category term="博客和写作" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"/>
    
    
  </entry>
  
</feed>
