<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>KIKI&#39;s Blog</title>
  
  <subtitle>分享科研总结和生活琐碎</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-05T05:57:57.741Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>KIKI</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>非线性数据结构（树）</title>
    <link href="http://example.com/2022/02/05/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%A0%91)/"/>
    <id>http://example.com/2022/02/05/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%A0%91)/</id>
    <published>2022-02-04T16:00:00.000Z</published>
    <updated>2022-02-05T05:57:57.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="定义与实现"><a href="#定义与实现" class="headerlink" title="定义与实现"></a>定义与实现</h2><p>&emsp;&emsp;树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。<br>&emsp;&emsp;一棵有n个节点的树，一共有n-1条边，根节点没有，其中节点的子树个数称为<strong>结点的度</strong>，一个树的度是节点中最大的度数，二叉树的度数为2，叶结点的度数为0。<br>&emsp;&emsp;<strong>完美二叉树（满二叉树）</strong>，是指每层都是满的二叉树，仅最后一层不满的且缺少的结点连续，都在右侧时为<strong>完全二叉树</strong>，其结点的标号和完美二叉树一致。<br><img src="https://gitee.com/KIKI9731/image/raw/master/QQ截图20220205135620.png" alt="二叉树"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x      <span class="comment"># 节点值</span></span><br><span class="line">        self.left = <span class="literal">None</span>  <span class="comment"># 左子节点</span></span><br><span class="line">        self.right = <span class="literal">None</span> <span class="comment"># 右子节点</span></span><br><span class="line"><span class="comment"># 初始化节点</span></span><br><span class="line">        n1 = TreeNode(<span class="number">3</span>) <span class="comment"># 根节点 root</span></span><br><span class="line">        n2 = TreeNode(<span class="number">4</span>)</span><br><span class="line">        n3 = TreeNode(<span class="number">5</span>)</span><br><span class="line">        n4 = TreeNode(<span class="number">1</span>)</span><br><span class="line">        n5 = TreeNode(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建引用指向</span></span><br><span class="line">        n1.left = n2</span><br><span class="line">        n1.right = n3</span><br><span class="line">        n2.left = n4</span><br><span class="line">        n2.right = n5</span><br></pre></td></tr></table></figure><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>&emsp;&emsp;根据遍历根节点的顺序，分为前序，中序和后续遍历三种。通常使用递归实现，三种遍历的路径其实是一致的，区别在于每个节点输出的时刻，前序在第一次遇到该节点时即输出，中序在第二次，后序在第三次。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>:</span>            <span class="comment"># 树的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,x</span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OperationTree</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data_list</span>):</span>         <span class="comment"># 把输入的列表初始化为可迭代对象</span></span><br><span class="line">        self.dataIter = <span class="built_in">iter</span>(data_list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">createTree</span>(<span class="params">self, root = <span class="literal">None</span></span>):</span>     <span class="comment"># 必须补充一句 默认参数root = None 不然会参数数量不匹配</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 新建一颗树 &quot;&quot;&quot;</span></span><br><span class="line">        next_data = <span class="built_in">next</span>(self.dataIter)    <span class="comment"># 步进获取下一个元素</span></span><br><span class="line">        <span class="keyword">if</span> next_data == <span class="string">&#x27;#&#x27;</span>:               <span class="comment"># &quot;#&quot; 号表示叶节点，在程序中用 None 代替 &quot;#&quot; 号</span></span><br><span class="line">            root = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:                              <span class="comment"># 是根节点，它还有孩子节点，所以继续创建Node</span></span><br><span class="line">            root = TreeNode(next_data)     <span class="comment"># 实例化对象（类似于struct）</span></span><br><span class="line">            root.left = self.createTree(root.left)</span><br><span class="line">            root.right = self.createTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 前序遍历 递归&quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            ans.append(root.val)  <span class="comment"># 前序遍历，root -&gt; left -&gt; right</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 中序遍历 递归&quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            helper(root.left)</span><br><span class="line">            ans.append(root.val)    <span class="comment"># 中序遍历，left -&gt; root -&gt; right</span></span><br><span class="line">            helper(root.right)</span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot; 后序遍历 递归&quot;&quot;&quot;</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            helper(root.left)</span><br><span class="line">            helper(root.right)</span><br><span class="line">            ans.append(root.val)   <span class="comment"># 后序遍历，left -&gt; right -&gt; root</span></span><br><span class="line">        helper(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printTree</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 综合打印&quot;&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;递归 前序遍历：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        preOrder = self.preorderTraversal(root)</span><br><span class="line">        <span class="built_in">print</span>(preOrder, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;递归 中序遍历：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        inOrder = self.inorderTraversal(root)</span><br><span class="line">        <span class="built_in">print</span>(inOrder,<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;递归 后序遍历：&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        postOrder = self.postorderTraversal(root)</span><br><span class="line">        <span class="built_in">print</span>(postOrder, <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    data = <span class="string">&#x27;abd#g###ce##fh###&#x27;</span></span><br><span class="line">    <span class="comment">#data = [1,2,&#x27;#&#x27;,&#x27;#&#x27;,3,&#x27;#&#x27;,&#x27;#&#x27;]</span></span><br><span class="line"></span><br><span class="line">    newTree = OperationTree(data)</span><br><span class="line">    root = newTree.createTree()</span><br><span class="line">    newTree.printTree()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">递归 前序遍历： [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;g&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;h&#x27;] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">递归 中序遍历： [&#x27;d&#x27;, &#x27;g&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;h&#x27;, &#x27;f&#x27;] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">递归 后序遍历： [&#x27;g&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;f&#x27;, &#x27;c&#x27;, &#x27;a&#x27;] </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">关于树的知识和算法题总结</summary>
    
    
    
    <category term="算法和数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>线性数据结构</title>
    <link href="http://example.com/2022/02/01/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>http://example.com/2022/02/01/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2022-01-31T16:00:00.000Z</published>
    <updated>2022-02-03T07:38:53.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>&emsp;&emsp;特点是插入删除容易，但查找不容易，因此，在涉及链表查找的题目时，一般用哈希表来实现，哈希表通过哈希函数将一个输入插入到固定位置，因此哈希表有可能出现空间的浪费，因为插入时不是连续的，但是查找时方便，是用空间换时间的一种方法。发生哈希冲突时则是以链表存储的。</p><p>&emsp;&emsp;除此之外，由于链表并不需要初始化长度，因此采用动态内存分配，区别于数组，数组在内存中的空间是连续的，但是链表在内存中不连续。链表属于动态分配，需要申请内存空间(C++中用new)，但是需要手动释放(用delete)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;<span class="comment">/*数据类型 *指针名称 = new 数据类型 </span></span><br><span class="line"><span class="comment">或</span></span><br><span class="line"><span class="comment">数据类型 *指针名称 = new 数据类型（初值）；*/</span></span><br><span class="line"><span class="keyword">delete</span> p<span class="comment">//delete指针名称</span></span><br><span class="line"><span class="comment">//如果分配成功，会返回内存空间起始地址，不成功返回NULL</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/KIKI9731/image/raw/master/QQ截图20220128171114.png" alt="动态内存与静态对比"></p><blockquote><p>使用结构体指针访问变量中成员的两种格式：(*指针变量).成员名  或者  指针变量-&gt;成员名</p></blockquote><p>用C++初始化<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;        <span class="comment">// 节点值</span></span><br><span class="line">    ListNode *next; <span class="comment">// 后继节点引用</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;<span class="comment">//结构体的初始化函数，传入x则自动给val赋值x</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 实例化节点</span></span><br><span class="line">ListNode *n1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>); <span class="comment">// 节点 head</span></span><br><span class="line">ListNode *n2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">ListNode *n3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1-&gt;next = n2;</span><br><span class="line">n2-&gt;next = n3;</span><br></pre></td></tr></table></figure><br>用Python初始化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        self.val = x     <span class="comment"># 节点值</span></span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span> <span class="comment"># 后继节点引用</span></span><br><span class="line"><span class="comment"># 实例化节点</span></span><br><span class="line">n1 = ListNode(<span class="number">4</span>) <span class="comment"># 节点 head</span></span><br><span class="line">n2 = ListNode(<span class="number">5</span>)</span><br><span class="line">n3 = ListNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建引用指向</span></span><br><span class="line">n1.<span class="built_in">next</span> = n2</span><br><span class="line">n2.<span class="built_in">next</span> = n3</span><br></pre></td></tr></table></figure></p><h2 id="链表实现-Python"><a href="#链表实现-Python" class="headerlink" title="链表实现(Python)"></a>链表实现(Python)</h2><blockquote><p>参考自：<a href="https://blog.csdn.net/Blood_Seeker/article/details/78992722">https://blog.csdn.net/Blood_Seeker/article/details/78992722</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="comment">#结点初始化函数, p 即模拟所存放的下一个结点的地址</span></span><br><span class="line">    <span class="comment">#为了方便传参, 设置 p 的默认值为 0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x = <span class="literal">None</span></span>):</span></span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#链表初始化函数, 方法类似于尾插</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">initList</span>(<span class="params">self, dataList</span>):</span></span><br><span class="line">        <span class="comment">#创建头结点</span></span><br><span class="line">        self.head = ListNode(<span class="literal">None</span>) <span class="comment"># 创建节点的时候传一个参数进去    # 创建头结点，里面不包含数据，头结点之后第一个才存放数据,head节点的数据默认None</span></span><br><span class="line">        pTail = self.head              <span class="comment"># 指向头结点的指针</span></span><br><span class="line">        <span class="comment">#逐个为 data 内的数据创建结点, 建立链表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dataList:            <span class="comment"># 遍历列表</span></span><br><span class="line">            newNode = ListNode(i)        <span class="comment"># 生成新的节点</span></span><br><span class="line">            pTail.<span class="built_in">next</span> = newNode      <span class="comment"># 新节点挂在尾结点上，即 上一个节点指针指向新的节点，由于新节点的next被初始化为None，所以pTail的next自然也是None</span></span><br><span class="line">            pTail = newNode          <span class="comment"># 当前新节点成为新的尾结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#链表判空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#取链表长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLength</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        p = self.head.<span class="built_in">next</span></span><br><span class="line">        <span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">len</span> += <span class="number">1</span></span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#遍历链表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traveList</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&#x27;link list traving result:&#x27;</span>)</span><br><span class="line">        p = self.head.<span class="built_in">next</span>   <span class="comment"># 取得表头之后的第一个数据</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            <span class="built_in">print</span> (p.val, end= <span class="string">&quot; &quot;</span>)</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">#链表插入数据函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertElem</span>(<span class="params">self, val, index</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot; 在 第index个节点(p.next)之前插入&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">        p = self.head</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p <span class="keyword">and</span> i &lt; index:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> i &gt; index:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR, 无法插入节点&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        pNew = ListNode(val)    <span class="comment"># 生成新的节点 包含了 pNew.val = key</span></span><br><span class="line">        pNew.<span class="built_in">next</span> = p.<span class="built_in">next</span></span><br><span class="line">        p.<span class="built_in">next</span> = pNew</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteElem</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="string">&quot;删除第index个节点（即删除 p.next节点）&quot;</span></span><br><span class="line"></span><br><span class="line">        p = self.head</span><br><span class="line">        i = <span class="number">1</span>             <span class="comment"># 节点计数</span></span><br><span class="line">        <span class="keyword">while</span> p.<span class="built_in">next</span> <span class="keyword">and</span> i &lt; index:</span><br><span class="line">            p = p.<span class="built_in">next</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> p.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> i &gt; index:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERROR, 该节点不存在&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        delVal = p.<span class="built_in">next</span>.val</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;deleted value:&quot;</span>, delVal)</span><br><span class="line">        p.<span class="built_in">next</span> = p.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#初始化链表与数据</span></span><br><span class="line">    <span class="comment"># data = [1,2,3,4,5]</span></span><br><span class="line">    dataList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    l = LinkList()</span><br><span class="line">    l.initList(dataList)</span><br><span class="line">    l.traveList()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(l.getLength())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#插入结点到索引值为3之后, 值为666</span></span><br><span class="line">    l.insertElem(<span class="number">666</span>, <span class="number">6</span>)</span><br><span class="line">    l.traveList()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#删除索引值为4的结点</span></span><br><span class="line">    l.deleteElem(<span class="number">4</span>)</span><br><span class="line">    l.traveList()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="一些链表相关题目"><a href="#一些链表相关题目" class="headerlink" title="一些链表相关题目"></a>一些链表相关题目</h2><h3 id="L160-相交链表"><a href="#L160-相交链表" class="headerlink" title="L160 相交链表"></a>L160 相交链表</h3><p>   &emsp;&emsp;这道题注意的是不仅仅是值相交，两个链表相交，则相交部分是完全一致的，因此可以用哈希表实现，也可以用<strong>双指针</strong>实现，两个指针分别从链表A(总长a)和链表B(总长b)的头出发，当到达结尾后，转向另一个链表，则如果两个链表有相交(相交部分为c)，此时都运动了a+b-c(a+(b-c)和b+(a-c));</p><h3 id="L141-环形链表"><a href="#L141-环形链表" class="headerlink" title="L141 环形链表"></a>L141 环形链表</h3><p>   &emsp;&emsp;利用<strong>双指针</strong>中的快慢指针，类比跑道上的两个速度不同的人，如果存在环形，则会相遇，但是注意的是两者的速度一定不同，而不能只是起点不同，起点不同不会相遇，会保持固定间隔。当然这种类似于查找是否有重复的，都可以用哈希表</p><blockquote><p>解法1：哈希表，时间复杂度O(n)，空间复杂度O(n)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span>                 </span><br><span class="line">        s = <span class="built_in">set</span>()             <span class="comment"># 定义一个set(集合，内部元素不重复)，然后不断遍历链表</span></span><br><span class="line">        <span class="keyword">while</span> head:<span class="comment"># 如果某个节点在set中，说明遍历到重复元素了，也就是有环</span></span><br><span class="line">            <span class="keyword">if</span> head <span class="keyword">in</span> s:     <span class="comment"># 不能把head.val这个值存在哈希表中，因为有可能只是值相同还不够，还需要指针也相同</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            s.add(head)       <span class="comment"># 如果节点不在哈希表中，说明之前没有相同节点，就存入表中  </span></span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><blockquote><p>解法2：快慢双指针，时间复杂度O(n)，空间复杂度O(1)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:<span class="comment">#链表中是单元素且非循环或链表为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:<span class="comment">#只用考虑更快的指针，因为如果链表有限，则快指针先达到结束条件，必须加上fast.next，因为后面有fast.next.next，如果fast.next为null，则null不会有next变量，会报错</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="L234-回文链表"><a href="#L234-回文链表" class="headerlink" title="L234 回文链表"></a>L234 回文链表</h3><p>&emsp;&emsp;实现时，先利用快慢指针，找到链表的中间节点，可以参考后面的面试问题中有提到，同时在指针移动的过程中，进行反转链表，之后从中间位置往两个方向展开。<br>&emsp;&emsp;需要注意的是，对于奇数，慢指针会停在最中间的元素，因此在展开前需要将其后移一位，偶数，则指在中间靠后的元素，因此不需操作。<br>&emsp;&emsp;关于如何判断元素数是奇还是偶，可以对比跳出循环的条件：对于快指针，依次指向0，2，4，即<strong>fast指向元素的索引始终为偶数</strong>，所以如果有偶数个元素，最后一个元素索引为奇数，则倒数第二次循环后,fast指向倒数第二个元素，fast.next指向最后一个，再次进入循环，此时fast为null,fast.next会报错，但因为是and所以不会,<strong>and前是0，自动忽略后面语句（短路现象），如果改为fast.next and fast则会报错</strong>。如果有奇数个元素，则最后一次循环q指向最后一个元素,q.next=null;<strong>即奇数个元素，fast.next=null,偶数个元素，fast=null,所以if(fast)：在奇数时执行</strong>，而为了反转链表引入的pre和prepre则始终在慢指针前面一位，反转时先将pre后移，然后将prepre赋给pre.next，即pre-&gt;prepre,然后prepre后移，即循环结束时，两者指向同一元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (head <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        slow = head</span><br><span class="line">        fast = head</span><br><span class="line">        pre = head</span><br><span class="line">        prepre = ListNode(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast <span class="keyword">and</span> fast.<span class="built_in">next</span>):</span><br><span class="line">            pre = slow             <span class="comment"># pre 紧跟在slow 后面一步</span></span><br><span class="line"></span><br><span class="line">            slow = slow.<span class="built_in">next</span>       <span class="comment"># 快慢指针用于找到中间节点 </span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            pre.<span class="built_in">next</span> = prepre      <span class="comment"># 用于反转前半部分链表</span></span><br><span class="line">            prepre = pre</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fast):                 <span class="comment"># 如果跳出上一个while循环是 fast.next is None,那么就是奇数个节点，slow需要再走一步</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">while</span>(pre <span class="keyword">and</span> slow):       <span class="comment"># 从中间对称的位置往两边扩展，比对两边的数是否相等 </span></span><br><span class="line">            <span class="keyword">if</span> (pre.val != slow.val):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p><h2 id="链表面试问题"><a href="#链表面试问题" class="headerlink" title="链表面试问题"></a>链表面试问题</h2><p>&emsp;&emsp;无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用<strong>双指针</strong>来解决。</p><blockquote><p>双指针并不是固定的公式，而是一种思维方式~</p></blockquote><p>&emsp;&emsp;先来看”倒数第k个元素的问题”。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head; <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;   <span class="comment">//将 p指针移动 k 次</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;<span class="comment">//同时移动，直到 p == nullptr</span></span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。<strong>fast 和 slow 的距离就会增加一。</strong>设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 指向中间两个结点的靠前一个还是靠后一个，需要调整循环的条件，下述代码是n为偶数的情况，慢指针指向<strong>靠后元素</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *p = head, *q = head;</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            q = q-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于上述代码：</p><blockquote><ol><li>比如n=5(下标0~4),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;4，此时q-&gt;next = null结束循环，p指向2，恰好是中间节点。（0，1，2，3，4）</li><li>比如n=4(下标0~3),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;null(2.next为3，3.next为null)，此时q = null结束循环，p指向2，是中间节点靠后一个。（0，1，2，3）</li><li>将条件改为while(q != nullptr &amp;&amp; q-&gt;next-&gt;next != nullptr)，会指向靠前一个，因为此时不会进行第二轮循环。</li></ol></blockquote><p>&emsp;&emsp;如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。<br>&emsp;&emsp;如何判断环的入口呢？<br><img src="https://gitee.com/KIKI9731/image/raw/master/QQ截图20220203130512.png" alt="环的入口"><br>&emsp;&emsp;由等式可知，相遇时d=x+ns(n为相遇时快指针多转了几圈)，则相遇后把两个指针速度变为一致，一个从起点出发，一个从相遇点出发，则因为<strong>d=x+ns</strong>，必然会在从相遇点出发的指针运动n圈+x后，在环的入口处相遇。(d为起点处出发指针路程，x+ns为从相遇点出发指针路程)，代码实现如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span></span><br><span class="line"></span><br><span class="line">        walker = head</span><br><span class="line">        runner = head</span><br><span class="line">        <span class="keyword">while</span>(runner <span class="keyword">and</span> runner.<span class="built_in">next</span>):</span><br><span class="line">            walker = walker.<span class="built_in">next</span></span><br><span class="line">            runner = runner.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> walker == runner:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> (runner <span class="keyword">is</span> <span class="literal">None</span>) <span class="keyword">or</span> (runner.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>):  <span class="comment"># 如果是因为走到头而退出循环，那就是没有环</span></span><br><span class="line">            <span class="keyword">return</span>                                     <span class="comment"># return False 的话会报错Your returned value is not a ListNode type.</span></span><br><span class="line">        <span class="comment"># 如果是因为break而跳出循环，那就是有环</span></span><br><span class="line">        walker = head             <span class="comment"># 步行者回到起点</span></span><br><span class="line">        <span class="keyword">while</span>(walker != runner):  <span class="comment"># 没相遇</span></span><br><span class="line">            walker = walker.<span class="built_in">next</span></span><br><span class="line">            runner = runner.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> runner</span><br></pre></td></tr></table></figure><br>链表相关链接:</p><blockquote><ol><li><a href="https://zhuanlan.zhihu.com/p/31401474?utm_source=wechat_session&amp;utm_medium=social&amp;from=singlemessage">漫画算法：如何判断链表有环？</a></li><li><a href="https://leetcode-cn.com/problems/linked-list-cycle/">L141环形链表</a></li></ol></blockquote><h1 id="一些刷题小总结"><a href="#一些刷题小总结" class="headerlink" title="一些刷题小总结"></a>一些刷题小总结</h1><h2 id="判断输入是否为None"><a href="#判断输入是否为None" class="headerlink" title="判断输入是否为None"></a>判断输入是否为None</h2><p>if not A 和 if A is None 看起来都是在判断A是否为空，实际上这两者是不同的：<br>（1）if not A 判断的是A是否为空，也就是说里面有东西没？<br>（2） if A is None则判断的是A是否声明并定义了？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:<span class="comment">#这里可以写成if head==None or head.next == None，但是其实是不一样的，因为如果head==None，则head.next会报错，因为Nonetype没有next的索引，即上述中的(2),不适用not则判断是否声明同时判断是否为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        slow = head</span><br><span class="line">        fast = head.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> slow != fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    
    <summary type="html">记录刷题过程中的总结</summary>
    
    
    
    <category term="算法和数据结构" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>C++学习笔记</title>
    <link href="http://example.com/2022/01/13/C++/"/>
    <id>http://example.com/2022/01/13/C++/</id>
    <published>2022-01-12T16:00:00.000Z</published>
    <updated>2022-01-28T09:34:18.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h1><h2 id="前置-和后置-的区别："><a href="#前置-和后置-的区别：" class="headerlink" title="前置++和后置++的区别："></a>前置++和后置++的区别：</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>,m = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a,b,c,d;</span><br><span class="line">a = n++;<span class="comment">//后置++</span></span><br><span class="line">b = m--;</span><br><span class="line">c = ++n;<span class="comment">//前置++</span></span><br><span class="line">d = --m;</span><br><span class="line">cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;<span class="comment">/*输出结果为5，10，7，8。首先对于后置++，可以看到对于a和b是先进行了赋值操作，再进行后置++。执行后a=15,b=10,n=6,m=9。对于前置++，首先进行前置++，再进行赋值操作*/</span></span><br></pre></td></tr></table></figure><p>后置++的优先级&gt;前置++的优先级&gt;乘和除的优先级&gt;…&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，！=&gt;赋值运算，优先级和上述性质无关。用优先性解释上述现象有矛盾，所以，可以按照这个记吧</p><h2 id="强制类型转换："><a href="#强制类型转换：" class="headerlink" title="强制类型转换："></a>强制类型转换：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int (a)</span><br><span class="line">(int) a    //两种方式均可</span><br></pre></td></tr></table></figure><p>其优先级高于乘数法，和逻辑非，按位取反同级。<br>因此  double(n)/2  是先将n转换为double再做除法</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><blockquote><p>双目运算：&amp;&amp; ||<br>单目运算：!</p></blockquote><p>逻辑！负号-&gt;乘除运算等&gt;&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，!=&gt;逻辑&amp;&amp;&gt;逻辑||。<br>为了避免优先级的混乱，多使用圆括号</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><blockquote><p>&amp;，|，^(异或)，&lt;&lt;左移,&gt;&gt;右移,~(按位取反)</p></blockquote><p><strong>按位取反的时候要考虑到数据的字节数，对于一个正数，前面所有的0都要变成1</strong>,左移一位相当于<em>2，右移相当于除2。复合位运算(&amp;=，|=等)的结合顺序是<em>*从右向左</em></em>，除此之外还有(!,~,+,-,前置++/—)也是从右向左结合，比较特殊。</p><h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><ol><li>“=”赋值运算，其结合顺序是从右向左且其左侧(lvalue)不能是表达式，只能是变量，数组等</li><li>?:,比如y=(x&gt;=1?1:0)即可表达一个分段函数:y=1(x&gt;=1),y=0(x&lt;1)</li><li>逗号表达式，依次计算每个表达式的值，整体等于最后一个逗号后式子的值，如y=(1,2,3+5),则y=8</li></ol><hr><h2 id="算法优先级顺序"><a href="#算法优先级顺序" class="headerlink" title="算法优先级顺序"></a>算法优先级顺序</h2><p><img src="https://gitee.com/KIKI9731/image/raw/master/QQ截图20220113205502.png" alt="优先级"></p><h2 id="数据类型转换原则"><a href="#数据类型转换原则" class="headerlink" title="数据类型转换原则"></a>数据类型转换原则</h2><p><img src="https://gitee.com/KIKI9731/image/raw/master/QQ截图20220113210115.png" alt="chenge"></p><h2 id="整型变量和字符变量"><a href="#整型变量和字符变量" class="headerlink" title="整型变量和字符变量"></a>整型变量和字符变量</h2><p>其在内存中存放的都是整数，整数，存放的是二进制格式，字符，存放的是ASCII码值(<128)，因此可以出现以下形式：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">a = c+<span class="number">2</span>;<span class="comment">//将字符变量赋给整型变量</span></span><br><span class="line">c = <span class="number">98</span>; <span class="comment">//将整数常量赋给字符变量</span></span><br></pre></td></tr></table></figure><br>上述输出a=67,因为’A’的ASCII码的值为65<br>c = ‘b’,因为’b’的ASCII码的值为98</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>char name[40] = ‘zhang’;<br>转义字符：\r回车，回到本行开头，\n换行，到下一行开头<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout&lt;&lt;<span class="string">&quot;xjtu\nhello&quot;</span>&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;xjtu123\rhello&quot;</span>&lt;&lt;endl;</span><br></pre></td></tr></table></figure><br>执行得：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xjtu</span><br><span class="line">hello</span><br><span class="line">hello23//第二次cout的xjtu1被\r后的hello覆盖</span><br></pre></td></tr></table></figure></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>字符数组和字符串的区别在于，用字符串定义数组时，末尾是’\0’，如下图所示<br><img src="https://gitee.com/KIKI9731/image/raw/master/QQ截图20220115164804.png" alt="char"><br>实例，将单词中的小写字母转换为大写字母：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;str;</span><br><span class="line">    <span class="keyword">while</span>(str[i]!=<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str[i]=str[i]<span class="number">-32</span>;<span class="comment">//大小写字母的ASCII码差值为32</span></span><br><span class="line">        i = i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>enum &lt;枚举类型名&gt;{枚举常量表}</p>]]></content>
    
    
    <summary type="html">主要总结C++的一些小的概念</summary>
    
    
    
    <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
  </entry>
  
  <entry>
    <title>强化学习（一）时序差分算法</title>
    <link href="http://example.com/2022/01/11/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/01/11/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-01-10T16:00:00.000Z</published>
    <updated>2022-01-11T08:40:32.241Z</updated>
    
    <content type="html"><![CDATA[<p>这是强化学习</p>]]></content>
    
    
    <summary type="html">主要总结两种常用的时序差分算法SARSA和Q-Learning的基本概念和区别</summary>
    
    
    
    <category term="强化学习" scheme="http://example.com/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown的入门级操作</title>
    <link href="http://example.com/2022/01/11/markdown/"/>
    <id>http://example.com/2022/01/11/markdown/</id>
    <published>2022-01-10T16:00:00.000Z</published>
    <updated>2022-01-11T08:41:11.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下：<br><img src="https://raw.githubusercontent.com/KIKI9731/image/main/QQ%E6%88%AA%E5%9B%BE20220111152402.png" alt="image"></p><h1 id="字体效果"><a href="#字体效果" class="headerlink" title="字体效果"></a>字体效果</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*斜体*</span><br><span class="line">~~删除~~</span><br><span class="line">==高亮==</span><br><span class="line"></span><br><span class="line">其他：</span><br><span class="line">加两个空格：&amp;emsp;&amp;emsp;（这个还挺麻烦的）</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下：<br>&emsp;&emsp;<strong>加粗</strong>  &emsp;&emsp;<em>斜体</em>&emsp;&emsp; <del>删除</del>&emsp;&emsp;==高亮==</p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;引用内容</span><br><span class="line">&gt;&gt;增加&gt;数量可以设置多层引用</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下： </p><blockquote><p>引用内容</p><blockquote><p>增加&gt;数量可以设置多层引用</p></blockquote></blockquote><h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***</span><br></pre></td></tr></table></figure><p>上述代码的执行效果如下： </p><hr><h1 id="图片和链接"><a href="#图片和链接" class="headerlink" title="图片和链接"></a>图片和链接</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![图片的名字](网上图片的链接或者本地图片的路径)</span><br><span class="line">[连接名称](链接地址)</span><br><span class="line">如这里：[baidu](www.baidu.com)</span><br></pre></td></tr></table></figure><p><a href="www.baidu.com">baidu</a></p>]]></content>
    
    
    <summary type="html">记录利用Markdown的一些常用命令和步骤</summary>
    
    
    
    <category term="博客和写作" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>如何利用Hexo搭建自己的博客</title>
    <link href="http://example.com/2022/01/10/%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2022/01/10/%E4%BB%A3%E7%A0%81/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-01-11T08:41:09.517Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>&emsp;&emsp;安装的过程可以参考 <a href="https://hexo.io/">Hexo官网</a>。<br>&emsp;&emsp;首先，需要保证安装好了node.js和git，这两个软件的安装也比较简单，直接官网安装就好。然后在命令行窗口中利用以下命令安装hexo，其中g代表对全局安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli-g</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后是新建一个文件夹，这个文件夹将自动生成一些默认的文件,之后的命令行窗口操作都是在该文件夹下进行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init [文件夹名]</span><br><span class="line">cd [文件夹名]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后安装一下需要的依赖（可能就是默认工具包的意思？）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>即可生成本地的预览</p><h1 id="选择一个好看的主题"><a href="#选择一个好看的主题" class="headerlink" title="选择一个好看的主题"></a>选择一个好看的主题</h1><p>&emsp;&emsp;在 <a href="https://hexo.io/">Hexo官网</a>提供了很多主题，选择一个好看的主题后，点击进入主题对应的github中，即可看到相关的命令，仍然在该文件夹下执行命令后即可安装，安装后会在theme文件夹下看到一个对应得主题文件夹，比如这里我选择安装了<a href="https://github.com/jerryc127/hexo-theme-butterfly">butterfly</a>主题，就会生成一个对应的文件夹</p><div style="align:left"><img src=https://gitee.com/KIKI9731/image/raw/master/QQ截图20220110160802.png></div>]]></content>
    
    
    <summary type="html">记录利用Hexo的一些常用命令和步骤</summary>
    
    
    
    <category term="博客和写作" scheme="http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"/>
    
    
  </entry>
  
</feed>
