{"meta":{"title":"KIKI's Blog","subtitle":"分享科研总结和生活琐碎","description":"一只努力减脂的KI","author":"KIKI","url":"http://example.com","root":"/"},"pages":[{"title":"link","date":"2022-01-09T11:44:53.000Z","updated":"2022-01-09T11:45:20.485Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"KIKI的标签页","date":"2022-01-09T11:39:03.000Z","updated":"2022-01-09T11:40:22.946Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"让我来康康这个KI都写了点什么东西","date":"2022-01-09T11:42:22.000Z","updated":"2022-01-11T07:51:17.294Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"线性数据结构","slug":"算法","date":"2022-01-31T16:00:00.000Z","updated":"2022-02-03T03:53:53.290Z","comments":true,"path":"2022/02/01/算法/","link":"","permalink":"http://example.com/2022/02/01/%E7%AE%97%E6%B3%95/","excerpt":"","text":"链表&emsp;&emsp;特点是插入删除容易，但查找不容易，因此，在涉及链表查找的题目时，一般用哈希表来实现，哈希表通过哈希函数将一个输入插入到固定位置，因此哈希表有可能出现空间的浪费，因为插入时不是连续的，但是查找时方便，是用空间换时间的一种方法。发生哈希冲突时则是以链表存储的。 &emsp;&emsp;除此之外，由于链表并不需要初始化长度，因此采用动态内存分配，区别于数组，数组在内存中的空间是连续的，但是链表在内存中不连续。链表属于动态分配，需要申请内存空间(C++中用new)，但是需要手动释放(用delete) 12345int* p = new int;/*数据类型 *指针名称 = new 数据类型 或数据类型 *指针名称 = new 数据类型（初值）；*/delete p//delete指针名称//如果分配成功，会返回内存空间起始地址，不成功返回NULL 使用结构体指针访问变量中成员的两种格式：(*指针变量).成员名 或者 指针变量-&gt;成员名 用C++初始化12345678910111213struct ListNode &#123; int val; // 节点值 ListNode *next; // 后继节点引用 ListNode(int x) : val(x), next(NULL) &#123;&#125;//结构体的初始化函数，传入x则自动给val赋值x&#125;;// 实例化节点ListNode *n1 = new ListNode(4); // 节点 headListNode *n2 = new ListNode(5);ListNode *n3 = new ListNode(1);// 构建引用指向n1-&gt;next = n2;n2-&gt;next = n3;用Python初始化123456789101112class ListNode: def __init__(self, x): self.val = x # 节点值 self.next = None # 后继节点引用# 实例化节点n1 = ListNode(4) # 节点 headn2 = ListNode(5)n3 = ListNode(1)# 构建引用指向n1.next = n2n2.next = n3 链表实现(Python) 参考自：https://blog.csdn.net/Blood_Seeker/article/details/78992722 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class ListNode(object): #结点初始化函数, p 即模拟所存放的下一个结点的地址 #为了方便传参, 设置 p 的默认值为 0 def __init__(self, x = None): self.val = x self.next = Noneclass LinkList(object): def __init__(self): self.head = None #链表初始化函数, 方法类似于尾插 def initList(self, dataList): #创建头结点 self.head = ListNode(None) # 创建节点的时候传一个参数进去 # 创建头结点，里面不包含数据，头结点之后第一个才存放数据,head节点的数据默认None pTail = self.head # 指向头结点的指针 #逐个为 data 内的数据创建结点, 建立链表 for i in dataList: # 遍历列表 newNode = ListNode(i) # 生成新的节点 pTail.next = newNode # 新节点挂在尾结点上，即 上一个节点指针指向新的节点，由于新节点的next被初始化为None，所以pTail的next自然也是None pTail = newNode # 当前新节点成为新的尾结点 #链表判空 def isEmpty(self): return self.head.next is None #取链表长度 def getLength(self): if self.isEmpty(): exit(0) p = self.head.next len = 0 while p: len += 1 p = p.next return len #遍历链表 def traveList(self): if self.isEmpty(): exit(0) print (&#x27;link list traving result:&#x27;) p = self.head.next # 取得表头之后的第一个数据 while p: print (p.val, end= &quot; &quot;) p = p.next #链表插入数据函数 def insertElem(self, val, index): &quot;&quot;&quot; 在 第index个节点(p.next)之前插入&quot;&quot;&quot; p = self.head i = 1 while p and i &lt; index: p = p.next i = i + 1 if p is None or i &gt; index: print(&quot;ERROR, 无法插入节点&quot;) return False pNew = ListNode(val) # 生成新的节点 包含了 pNew.val = key pNew.next = p.next p.next = pNew def deleteElem(self, index): &quot;删除第index个节点（即删除 p.next节点）&quot; p = self.head i = 1 # 节点计数 while p.next and i &lt; index: p = p.next i = i + 1 if p.next is None or i &gt; index: print(&quot;ERROR, 该节点不存在&quot;) return False delVal = p.next.val print(&quot;deleted value:&quot;, delVal) p.next = p.next.nextif __name__ == &#x27;__main__&#x27;: #初始化链表与数据 # data = [1,2,3,4,5] dataList = [1, 2, 3, 4, 5] l = LinkList() l.initList(dataList) l.traveList() print(&#x27;\\n&#x27;) print(l.getLength()) #插入结点到索引值为3之后, 值为666 l.insertElem(666, 6) l.traveList() print(&#x27;\\n&#x27;) #删除索引值为4的结点 l.deleteElem(4) l.traveList() print(&#x27;\\n&#x27;) 一些链表相关题目L160 相交链表 &emsp;&emsp;这道题注意的是不仅仅是值相交，两个链表相交，则相交部分是完全一致的，因此可以用哈希表实现，也可以用双指针实现，两个指针分别从链表A(总长a)和链表B(总长b)的头出发，当到达结尾后，转向另一个链表，则如果两个链表有相交(相交部分为c)，此时都运动了a+b-c(a+(b-c)和b+(a-c)); L141 环形链表 &emsp;&emsp;利用双指针中的快慢指针，类比跑道上的两个速度不同的人，如果存在环形，则会相遇，但是注意的是两者的速度一定不同，而不能只是起点不同，起点不同不会相遇，会保持固定间隔。当然这种类似于查找是否有重复的，都可以用哈希表 解法1：哈希表，时间复杂度O(n)，空间复杂度O(n) 123456789class Solution(object): def hasCycle(self, head): s = set() # 定义一个set(集合，内部元素不重复)，然后不断遍历链表 while head:# 如果某个节点在set中，说明遍历到重复元素了，也就是有环 if head in s: # 不能把head.val这个值存在哈希表中，因为有可能只是值相同还不够，还需要指针也相同 return True s.add(head) # 如果节点不在哈希表中，说明之前没有相同节点，就存入表中 head = head.next return False 解法2：快慢双指针 123456789101112class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if (head is None) or (head.next is None): return False walker = head # 快慢两人起点相同 runner = head while(runner and runner.next): # 用快者当临界 walker = walker.next # 每次走一步 runner = runner.next.next # 每次走两步 if walker == runner: # 能相遇，即有环，同样这里不能用walker.val == runner.val,因为值可能重复，但是指针指向地址不可能重复 return True return False 一些刷题小总结判断输入是否为Noneif not A 和 if A is None 看起来都是在判断A是否为空，实际上这两者是不同的：（1）if not A 判断的是A是否为空，也就是说里面有东西没？（2） if A is None则判断的是A是否声明并定义了？123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next:#这里可以写成if head==None or head.next == None，但是其实是不一样的，因为如果head==None，则head.next会报错，因为Nonetype没有next的索引，即上述中的(2),不适用not则判断是否声明同时判断是否为空 return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"C++学习笔记","slug":"C++","date":"2022-01-12T16:00:00.000Z","updated":"2022-01-28T09:34:18.594Z","comments":true,"path":"2022/01/13/C++/","link":"","permalink":"http://example.com/2022/01/13/C++/","excerpt":"","text":"算术运算前置++和后置++的区别：int n = 5,m = 10;int a,b,c,d;a = n++;//后置++b = m--;c = ++n;//前置++d = --m;cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;/*输出结果为5，10，7，8。首先对于后置++，可以看到对于a和b是先进行了赋值操作，再进行后置++。执行后a=15,b=10,n=6,m=9。对于前置++，首先进行前置++，再进行赋值操作*/ 后置++的优先级&gt;前置++的优先级&gt;乘和除的优先级&gt;…&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，！=&gt;赋值运算，优先级和上述性质无关。用优先性解释上述现象有矛盾，所以，可以按照这个记吧 强制类型转换：int (a)(int) a //两种方式均可 其优先级高于乘数法，和逻辑非，按位取反同级。因此 double(n)/2 是先将n转换为double再做除法 逻辑运算 双目运算：&amp;&amp; ||单目运算：! 逻辑！负号-&gt;乘除运算等&gt;&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，!=&gt;逻辑&amp;&amp;&gt;逻辑||。为了避免优先级的混乱，多使用圆括号 位运算 &amp;，|，^(异或)，&lt;&lt;左移,&gt;&gt;右移,~(按位取反) 按位取反的时候要考虑到数据的字节数，对于一个正数，前面所有的0都要变成1,左移一位相当于2，右移相当于除2。复合位运算(&amp;=，|=等)的结合顺序是*从右向左，除此之外还有(!,~,+,-,前置++/—)也是从右向左结合，比较特殊。 特殊符号 “=”赋值运算，其结合顺序是从右向左且其左侧(lvalue)不能是表达式，只能是变量，数组等 ?:,比如y=(x&gt;=1?1:0)即可表达一个分段函数:y=1(x&gt;=1),y=0(x&lt;1) 逗号表达式，依次计算每个表达式的值，整体等于最后一个逗号后式子的值，如y=(1,2,3+5),则y=8 算法优先级顺序 数据类型转换原则 整型变量和字符变量其在内存中存放的都是整数，整数，存放的是二进制格式，字符，存放的是ASCII码值(","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"强化学习（一）时序差分算法","slug":"强化学习（一）","date":"2022-01-10T16:00:00.000Z","updated":"2022-01-11T08:40:32.241Z","comments":true,"path":"2022/01/11/强化学习（一）/","link":"","permalink":"http://example.com/2022/01/11/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"这是强化学习","categories":[{"name":"强化学习","slug":"强化学习","permalink":"http://example.com/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Markdown的入门级操作","slug":"markdown","date":"2022-01-10T16:00:00.000Z","updated":"2022-01-11T08:41:11.379Z","comments":true,"path":"2022/01/11/markdown/","link":"","permalink":"http://example.com/2022/01/11/markdown/","excerpt":"","text":"标题123# 一级标题## 二级标题...... 上述代码的执行效果如下： 字体效果1234567**加粗***斜体*~~删除~~==高亮==其他：加两个空格：&amp;emsp;&amp;emsp;（这个还挺麻烦的） 上述代码的执行效果如下：&emsp;&emsp;加粗 &emsp;&emsp;斜体&emsp;&emsp; 删除&emsp;&emsp;==高亮== 引用12&gt;引用内容&gt;&gt;增加&gt;数量可以设置多层引用 上述代码的执行效果如下： 引用内容 增加&gt;数量可以设置多层引用 分割线1*** 上述代码的执行效果如下： 图片和链接123![图片的名字](网上图片的链接或者本地图片的路径)[连接名称](链接地址)如这里：[baidu](www.baidu.com) baidu","categories":[{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]},{"title":"如何利用Hexo搭建自己的博客","slug":"代码","date":"2022-01-09T16:00:00.000Z","updated":"2022-01-11T08:41:09.517Z","comments":true,"path":"2022/01/10/代码/","link":"","permalink":"http://example.com/2022/01/10/%E4%BB%A3%E7%A0%81/","excerpt":"","text":"安装Hexo&emsp;&emsp;安装的过程可以参考 Hexo官网。&emsp;&emsp;首先，需要保证安装好了node.js和git，这两个软件的安装也比较简单，直接官网安装就好。然后在命令行窗口中利用以下命令安装hexo，其中g代表对全局安装 1npm install hexo-cli-g &emsp;&emsp;然后是新建一个文件夹，这个文件夹将自动生成一些默认的文件,之后的命令行窗口操作都是在该文件夹下进行 12hexo init [文件夹名]cd [文件夹名] &emsp;&emsp;然后安装一下需要的依赖（可能就是默认工具包的意思？） 1npm install &emsp;&emsp;然后执行 1hexo s 即可生成本地的预览 选择一个好看的主题&emsp;&emsp;在 Hexo官网提供了很多主题，选择一个好看的主题后，点击进入主题对应的github中，即可看到相关的命令，仍然在该文件夹下执行命令后即可安装，安装后会在theme文件夹下看到一个对应得主题文件夹，比如这里我选择安装了butterfly主题，就会生成一个对应的文件夹","categories":[{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]}],"categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"强化学习","slug":"强化学习","permalink":"http://example.com/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]}