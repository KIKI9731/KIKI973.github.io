{"meta":{"title":"KIKI's Blog","subtitle":"分享科研总结和生活琐碎","description":"一只努力减脂的KI","author":"KIKI","url":"http://example.com","root":"/"},"pages":[{"title":"link","date":"2022-01-09T11:44:53.000Z","updated":"2022-01-09T11:45:20.485Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"KIKI的标签页","date":"2022-01-09T11:39:03.000Z","updated":"2022-01-09T11:40:22.946Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"让我来康康这个KI都写了点什么东西","date":"2022-01-09T11:42:22.000Z","updated":"2022-01-11T07:51:17.294Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"随笔","date":"2022-06-29T16:00:00.000Z","updated":"2022-06-30T08:19:31.667Z","comments":true,"path":"随笔.html","permalink":"http://example.com/%E9%9A%8F%E7%AC%94.html","excerpt":"","text":"祝我自己健健康康/2019.9.8，转自QQ空间日志/我也不知道怎么说，也不能说是突然想写一篇日志，其实也想好久了，但是不知道怎么开头，也不知道自己到底要写什么，就连打开写日志这个窗口都感觉要比写说说要复杂很多，只是觉得可能自己有很多话要说，所以就想写一篇长长的东西，时间过得真么快啊，就已经20了，完全没想到当年从九岁变成十岁，如今从19变成20会过得这么快。 其实想写这些的原因就是因为暑假的时候做了人生中的第一次手术，为什么说是第一次，而不是第一个呢？因为一次就做了五个，可能我也没跟很多人说啦，但是就自己身体出现了一些问题，虽然都不是什么特别大的事情，但是就做手术本身也算是件大事，或多或少对自己的心态上会产生一些触动，也因为做了手术之后无所事事的一个暑假，我也有机会开始仔细去想自己的一些事情。 20岁于我而言是一个比较尴尬的年龄吧，很多事情也想不明白，没有到而立之年，但是也永远不可能像一个十岁的孩子一样去拒绝去想一些即将发生的事情，就好比我现在已经大三，但是我似乎对自己的未来没有什么特别明确的规划，当我遇到一件我自己不懂的事情，我还是去想我要不要去问一下别人，然后别人给我的答案，好像总感觉还是那么的模糊，我对许多事情还是得不到一个确切的说法。 就好比虽然已经学了两年的机械，但是我好像还是回答不了“你这个专业将来是做什么的”这个问题。我看到周围的同学都在忙，我不知道他们在忙什么，感觉全世界好像只有自己不知道该干什么，在过去的两年，我体验了自己想去体验的事情，但是总有一些事情就我不知道怎么去下手，我或许想做或不想做我自己也说不清楚，我不再像十几岁的时候那样，对一件事有很高的热情，好像现在所有的事情对我来说就都是那种。嗯，还行，可以吧，没有一个很确切的态度，也没有一个很明确的情绪。 前段时间我去看过一次心理医生，说是中度抑郁，可是我感觉我过的还行，只是好像到了一个也不算成熟，但是总觉得到了一个对什么都没有了好奇心的状态，这可能就是所谓的变老了吧表情我发现我开始很在意我的家人，会好奇自己前两年是怎么做到一个月可以不跟家里打一个电话的那种状态，也因为这种在意，我会在这个暑假里跟他们走的格外的近，我发现其实我弟现在十岁，也是从九岁到十岁这个十位数要发生改变的年龄，他好像还有很多事情是希望被我知道，但是我之前都没有关注到的，我会跟他聊很多，很多之前我可能不太感兴趣的东西，然后我才知道很多事情和我想的也不一样，他也有他自己的问题和烦恼，我就在好奇，十年前我自己是什么样子？我原以为小孩子都是那种没心没肺的，天天很快乐的样子，但是当我弟很严肃的跟我说起一些关于自己的事情的时候，我会发现好像也没我想象的那么简单，我也会跟我妈聊，我发现成年人的世界真的很复杂，好多从理论上来讲，不会发生争执的事情，倒引发了很大很大的问题，好多，我以为那不明摆的事情吗？但是人们就是不愿意那么做，我会在逛超市的时候，留意那些我不认识的人们的一举一动，他们的语言，他们的一些小动作，好像每个人都有自己的故事，我有时候可以什么都不干，一下午在那里胡思乱想，会开始在意自己的身体健康，甚至可以熟练的说出来十几种几年前可能完全没有听说过的病的名字，会开始不着边际的想一些可能十年20年甚至更久之后可能会发生的一些事情，对很多事变得很佛，很养生，反倒越想越迷茫。算了，就这样吧，明天就是新学期的第一天了，虽然自己其实已经搞了两个星期课设了。 嗯，可能也是因为这个原因，对新学期提不起来什么兴趣，总觉得要放假的一样，因为不知道未来要走向何方，所以也没什么动力和方向，只想简简单单，然后emmm祝家人身体健康愿我十年之后，能…… emmm算了，我不想给自己什么承诺 语音转文字的结果，就是没有逻辑也可以写很多东西 2022.6.30注：其实过了三年来看三年前，应该是大二暑假的这个日志的话，还是多少有些心酸吧，那个时候的心境还是会和现在有很大不同，不过突出的一点就是对于未来的迷茫感，我不是那种会计划很长久的人，本着走一步看一步的想法，应该也是因为如此，所以才会迷茫吧，王天磊跟我聊未来的时候，我会羡慕，他想的好远，想的好周全，可是有些事情，尤其是个人对生活的态度这种事，其实很难改变的，只能说，找点事来做吧，热爱可抵岁月漫长，找不到热爱，只能说，那就收集点面包吧。 迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪/2022.6.30/ 一切从研究生开始的时候说起 幻想回不去的过去一年过去了，其实给人最大的感觉就是很迷茫，突然就没了目标一样，好在学校不宜久居，缺乏生活气息的环境帮我果断打消了读博的念头，当然还有一个原因是老师确实没有给出一个切实可行的研究计划，所以，眼下摆在面前的似乎只有毕业工作这条路。迷茫，是因为不知道自己要做什么才能毕业，好像每天都在学些东西，看些论文，但是说实话每天的有效学习时间并不长，印象里自己也不是那种坐不住的人，只是缺少一个明确的任务，所以从这点上来说，或许工作了会好一些吧，我常这样安慰自己。偶尔可能会有一两天，突然觉得未来可期，可能是找到了一段觉得还不错的视频，或者有了一点点想法，然后，努力几天后，就又没了下午，我属于那种情绪来的特别快，去的也特别快的人，当然负面情绪好像去的并不快，所以，三分钟热度算是很确切的一种说法，我常常会在周一定好计划，说自己这周开始要早睡，然后，在某天晚上没有早睡之后，就放弃，更多的时候，当我刻意想要早睡的时候，却总是睡不着，脑子里想的最多的，是假如我能回到过去，诸如：假如我能回到过去，我会毫不犹豫的转专业，学个计算机，或者至少不会来西交假如我能回到过去，我会好好学习语文，不那么看重考试成绩，而是考试的错误假如我能回到过去，我会控制饮食，不让自己变胖，以及不让自己近视等等。。。。。。生活中的很多问题，似乎只要带着现在的大脑回去再来一次，就不会犯错，可是，真的会是这样么，其实也无所谓了，每个人应该都会后悔自己做过的某个选择，即使重来一遍，也，好吧，我其实觉得重来一遍是有用的，可惜，回不去的过去告诉我，把握好现在，才能让未来的自己不后悔 无限放大的负面情绪和得失心之前一位好友邀请我做了人格测试，INFP，她很惊讶，她说，想不到我这么乐观外向的人居然是这个，其实，好像成年之后，人才开始慢慢形成更完善的性格，至少，之前初高中的生活过于单调，而人的性格是在不同的生活经历中培养起来的，所以，其实到了大学之后，或者说，到了自己照顾起自己的生活之后，许多情绪便只能自己消化，然后潜移默化的影响着自己的人格从一位朋友生病住院开始，我开启了漫长的与疑病症对抗的生活，虽然最后证明我确实有病，但是，怎么说，至少我感觉我心理层面的问题会更大一点，生病=花很多很多钱=万一挂了怎么办，以及害怕将来家人生病等一系列情绪，其实核心问题还是怕花钱，我感觉这个问题其实也影响到了我看待很多问题的方式，既然说到这里了，就捋一下关系： 因为怕花钱，所以身体有症状之后很担心，害怕是大病，害怕要花大钱，所以不停的去医院，有病就想赶紧治，稍微不舒服，就想看医生，包括一些小病，没有给自己身体适应的过程，结果是，负面情绪太高往往也不利于病情恢复，而且会很绝望 因为怕花钱，考驾照的时候，导致自己特别特别紧张，说实话，我开车倒是真的没那么怕，怕速度快或者怎么样，我就真的是算了一下，挂科之后要花小一千，我就难受，还有就是长期被指责动手能力不行，导致我不管是学车还是金工实习，都有一个很强的先入为主的想法，觉得自己不行，然后那些平日里动手能力很强的人，我会觉得他一定行，不过傲慢与偏见，也算是人之常情，只是，这种潜移默化对别人的评价，真的会刻在骨子里，影响很多很多时候自己的想法，所以，不要PUA别人 因为怕花钱，所以想赚钱，这个逻辑好像也没什么毛病，所以直接导致，研究生之后，成绩被判的很低之后，总是在担心能不能拿到奖学金，进而各种郁闷，以及对一些不合理规则，不公平竞争的埋怨，只是有时候也觉得，为这点钱不至于，不过好像，得失心太重了，接受不了这种落差，前几天看北大数学学院的小姐姐演讲，说总有人在你专业的领域和你喜欢的领域两方面都比你优秀，我们能做的只有优化自己，今天早上其实自己还在想排名这件事以及其派生物内卷给自己带来了多大的苦恼，其实能专注于自己，规划好自己的未来，比起在意别人的想法或许更重要一点。 写到这里其实心情已经好很多了，INFP嘛，哈哈，只是如果再拿一个“良”的话，应该还是会难受一阵子，不过没有那么快的转变嘛，只能说，要学会在经历挫折中，锻炼自己消化情绪的能力 体重其实好久没变了，就像没有起色的科研，和看不到光的未来一样，可是时间不管你的失落，他公平的近乎冷漠的走啊走啊走，村上喜欢跑步，说不必像其他运动一样那么富有竞争性，可以按照自己的节奏来，我其实也挺烦竞争的，只想安稳地按照自己的节奏来，可是当曾经比你胖的人已经比你瘦了，当你认为不如你的人却拿到比你更高的分数的时候，是不吃一顿晚饭然后不顾身体的去跑个6公里么，或者开始新一轮emo为了一分两分悲伤一晚上，然后幻想回到过去么高考结束的时候，我安慰自己一切都是最好的安排，回看过去，长沙和中南带给我的全是美好的回忆，至少现在看来，当然某些时刻还是会悲伤，不过都熬过来了，此时此刻，在抱怨西安，抱怨科研，抱怨各种琐碎的时候，或许回看现在，也会是美好的，考不过驾照的时候，悲伤，我安慰自己人的快乐都是自己给的，不快乐也是。所以，看淡一点吧，或者我应该劝自己，努力看淡一点吧，我爱猴叔对生活的热情，我也渴望做一个热爱生活的人，琐碎的烦恼既然躲不掉，就面对吧，emo的情绪，如果化解不掉，或许可以仔细分析一下情绪的前因后果，然后理清楚了，就有方法了，起码安慰起自己来也有理有据and有用？对，有用。前段时间复习中特，现在就特别喜欢分条罗列，类似于划重点，hhh，大道至简，党的智慧啊，总结一下： 既然过去回不去，那就抓住现在，渴望被打鸡血 不以物喜，不以己悲，完美概括了自己的得失心和想不开，呜呜呜，范仲淹懂我 学会自我调节，整理心情，分析情绪，乐观，热爱生活，就要接收生活的酸甜苦辣咸以上"}],"posts":[{"title":"计算机网络","slug":"计算机网络","date":"2023-07-11T16:00:00.000Z","updated":"2023-07-15T02:47:43.515Z","comments":true,"path":"2023/07/12/计算机网络/","link":"","permalink":"http://example.com/2023/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"基础知识OSI7层模型及其对应的功能 应用层：各种应用软件 表示层：数据格式标识，基本压缩加密功能 会话层：控制应用程序之间的会话能力，不同软件数据分给不同软件 传输层：实现端到端的传输，TCP/UDP，传输的是TCP报文段或UDP用户数据报 网络层：定义IP编址，定义路由功能，IP，传输的是包 数据链路层：定义数据基本格式，如何传输，网卡MAC地址，传输的是帧 物理层：底层数据传输，网线，网卡标准，传输的是比特流 一次完整的HTTP请求过程解析HTTP请求，从URL中解析出域名—&gt; 域名解析 —&gt; 发起TCP的3次握手 —&gt; 建立TCP连接后发起http请求 —&gt; 服务器响应http请求，浏览器得到html代码 —&gt; 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） —&gt; 浏览器对页面进行渲染呈现给用户。 应用层问题DNS 查询服务器域名对应的 IP 地址，应用层协议，UDP传输，因为快，UDP有限制512字节？但是一般域名解析不会超过512字节 官方解释：DNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。DNS 中的域名都是用句点来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的界限。在域名中，越靠右的位置表示其层级越高。 每次都要这样？ 浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」。本地dns服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动等。 负载均衡 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会崩掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 HTTP缓存问题缓存的好处： 缓解服务器压力； 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 可以通过本地浏览器缓存或代理服务器缓存实现 对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都缓存在本地，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP/1.1 的性能肯定肉眼可见的提升。所以，避免发送 HTTP 请求的方法就是通过缓存技术，HTTP 设计者早在之前就考虑到了这点，因此 HTTP 协议的头部有不少是针对缓存的字段。HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存。 简单来说就是报文中有个过期时间，发送相同请求，没过期就使用本地缓存，如果过期就给服务器发，服务器回复304，也就是比对之后发现没变，那么就可以继续使用缓存 HTTP报文中有一个Cache-Control字段，表示过期时间。当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期，如果没有，则使用该缓存，否则重新请求服务器； 协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求。协商缓存会触发304状态，即缓存重定向，强制缓存不需要问服务器端，直接就可以读本地缓存，也就是本地过期之后，再用协商缓存，问一下服务器，然后根据返回的参数决定是否用本地缓存 HTTP的请求方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。根据 HTTP 标准，HTTP 请求可以使用多种请求方法。HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头，常用来测试链接是否可通HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 是否可以同时发多个HTTP请求1.1不可以HTTP/1.1 存在一个问题，单个 TCP 连接在同一时刻只能处理一个请求，意思是说：两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。 在 HTTP/1.1 存在 Pipelining 技术可以完成这个多个请求同时发送，但是由于浏览器默认关闭，所以可以认为这是不可行的。在 HTTP2 中由于 Multiplexing 特点的存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行。 那么在 HTTP/1.1 时代，浏览器是如何提高页面加载效率的呢？主要有下面两点： 维持和服务器已经建立的 TCP 连接，在同一连接上顺序处理多个请求。 和服务器建立多个 TCP 连接。 关于合并请求的补充说明：HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了队头阻塞的问题。 HTTP/1.1优化改进： 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。仍存在问题： 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分； 发送冗长的首部。每次互相发送相同的首部造成的浪费较多； 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞； 没有请求优先级控制； 请求只能从客户端开始，服务器只能被动响应 还是缓存的问题，通过缓存可以减少请求次数 客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 URL 作为 key，而响应作为 value，两者形成映射关系。这样当后续发起相同的请求时，就可以先在本地磁盘上通过 key 查到对应的 value，也就是响应，本来会有一个过期时间，然后如果过期了会再去访问服务器，但是服务器如果说数据没修改，就会返回304缓存重定向，这样响应的包体就很小这个就是之前的强制缓存和协商缓存 如何减少 HTTP 请求次数？ 减少重定向请求次数；如果客户端和服务端中间有代理服务器，通过代理服务器完成重定向 合并请求；把多个访问小文件的请求合并成一个大的请求，小图片合并为大图片，然后再切分为小图片渲染 延迟发送请求；请求网页的时候，没必要把全部资源都获取到，而是只获取当前用户所看到的页面资源，当用户向下滑动页面的时候，再向服务器获取接下来的资源，这样就达到了延迟发送请求的效果。 HTTPS 加了一个SSL/TLS安全协议 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。 HTTP 默认端口号是 80，HTTPS 默认端口号是 443。 HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。 解决三类风险 信息加密：交互信息无法被窃取 采用混合加密实现在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。具体来看：对称加密，即用同样的密钥加密和解密，但是，公钥怎么安全传输是个问题，明文传输容易被截获，密文传输又需要加密，怎么加密又成了问题非对称加密，公钥公开，客户端把对称加密要是用的「会话秘钥」用公开的密钥加密传给服务器，服务器用自己的私钥解开，不存在密钥分发的问题，但是比对称加密慢很多。之后就用这个「会话秘钥」传输先私钥再公钥（相当于签署）=先公钥再私钥 校验机制：无法篡改通信内容，篡改了就不能正常显示 用摘要算法实现公钥加密，私钥解密。这个目的是为了保证内容传输的安全，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；私钥加密，公钥解密（这个是验证身份的主要一环）。这个目的是为了保证消息不会被冒充，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的 通过「私钥加密，公钥解密」的方式，来确认消息的身份，我们常说的数字签名算法，就是用的是这种方式，不过私钥加密内容不是内容本身，而是对内容的哈希值加密。 身份证书：证明淘宝是真的淘宝网防止上述公钥造假 可以通过哈希算法来保证消息的完整性；可以通过数字签名来保证消息的来源可靠性（能确认消息是由持有私钥的一方发送的）；但是这还远远不够，还缺少身份验证的环节，万一公钥是被伪造的呢？HTTPS加密详解 HTTPS建立连接 客户端向服务器索要并验证服务器的公钥。 双方协商生产「会话秘钥」。 双方采用「会话秘钥」进行加密通信。 数字证书如何验证CA机构对公钥信息进行Hash计算并加密签名首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；最后将 Certificate Signature 添加在文件证书上，形成数字证书； 用户浏览器和操作系统记录了CA的公钥，先计算Hash值，然后解密后再计算Hash值，看是否一致，所以信任的前提是用户选择相信浏览器和操作系统内置的CA首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。 SSL/TLSSSL是最早的安全套接字层（Secure Sockets Layer），后来被标准化后叫做SSL/TLS协议，具体又细分为很多不同的实现，位于会话层不同的密钥交换算法，TLS 的握手过程可能会有一些区别。以最简单的 RSA 密钥交换算法，来看看它的 TLS 握手过程。 在 RSA 密钥协商算法中，客户端会生成随机密钥(后续对称加密传输的密钥)，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。总共需要4次握手 客户端发消息，里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的随机数（Client Random），这个随机数会被服务端保留，它随机数是生成对称加密密钥的材料之一 服务端发信息，从密码套件列表中选择一个密码套件，以及生成随机数（Server Random），接着，返回「Server Hello」消息 通过前两次握手，客户端和服务端就已确认了 TLS 版本和使用的密码套件，而且客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方。除此之外，第二次握手还包括了后续发送服务端证明自己的身份的「Server Certificate」消息，这个消息里含有数字证书。和「Server Hello Done」消息，目的是告诉客户端，我已经把该给你的东西都给你了。两次握手后，客户端要验证数字证书合法性 客户端验证完证书后，认为可信则继续往下走。接着，客户端就会生成一个新的随机数 (pre-master)，用服务器的 RSA 公钥加密该随机数，通过「Client Key Exchange」消息传给服务端。 服务器也是同样的操作，发「Change Cipher Spec」和「Encrypted Handshake Message」消息，如果双方都验证加密和解密没问题，那么握手正式完成。 即用三个随机数生成对称加密的密钥 这个做法的漏洞主要是服务端的私钥可能会泄露，使用 RSA 密钥协商算法的最大问题是不支持前向保密。前向安全指的是长期使用的主密钥泄漏不会导致过去的会话密钥泄漏。 因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解，ECDHE是临时生成私钥，所以即使某次被破解了私钥，以前和以后的会话也是安全的 GET和POST区别 get是获取数据，post是修改数据 get把请求的数据放在url上， 以?分割URL和传输数据，参数之间以&amp;相连，所以get不太安全。而post把数据放在HTTP的包体内（request body 相对安全）这个还挺重要的，再去细看解析的逻辑，POST的第一行是没有url的 get提交的数据最大是2k（ 限制实际上取决于浏览器）， post理论上没有限制。 GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。 GET请求会被浏览器主动缓存，而POST不会，除非手动设置。主要因为：GET是幂等的，而POST不是幂等的 浏览器对同一 Host 建立 TCP 连接到的数量有没有限制？ HTTP/1.1时代，一次只能同时处理一个HTTP请求，多张图片可以通过建立多个TCP 假设我们还处在 HTTP/1.1 时代，那个时候没有多路传输，当浏览器拿到一个有几十张图片的网页该怎么办呢？肯定不能只开一个 TCP 连接顺序下载，那样用户肯定等的很难受，但是如果每个图片都开一个 TCP 连接发 HTTP 请求，那电脑或者服务器都可能受不了，要是有 1000 张图片的话总不能开 1000 个TCP 连接吧，你的电脑同意 NAT 也不一定会同意。 有。Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。 如果图片都是 HTTPS 连接并且在同一个域名下，那么浏览器在 SSL 握手之后会和服务器商量能不能用 HTTP2，如果能的话就使用 Multiplexing 功能在这个连接上进行多路传输。不过也未必会所有挂在这个域名的资源都会使用一个 TCP 连接去获取，但是可以确定的是 Multiplexing 很可能会被用到。 Cookies和Session(1)cookie数据存放在客户的浏览器上，session数据放在服务器上(2)cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session(3)session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE(4)单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。(5)所以：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中 SQL注入攻击攻击者在HTTP请求中注入恶意的SQL代码，服务器使用参数构建数据库SQL命令时，恶意SQL被一起构造，并在数据库中执行。 用户登录，输入用户名 lianggzone，密码 ‘ or ‘1’=’1 ，如果此时使用参数构造的方式，就会出现 select * from user where name = ‘lianggzone’ and password = ‘’ or ‘1’=‘1’ 不管用户名和密码是什么内容，使查询出来的用户列表不为空。如何防范SQL注入攻击使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。Web端： 1）有效性检验。 2）限制字符串输入的长度。服务端： 1）不用拼接SQL字符串。 2）使用预编译的PrepareStatement。 3）有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求) 4）过滤SQL需要的参数中的特殊字符。比如单引号、双引号。 传输层问题关于TCP/UDP的传输 小林关于TCP字节流，UDP报文的解释 说为什么 UDP 是面向报文的协议？当用户消息通过 UDP 协议传输时，操作系统不会对消息进行拆分，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是每个 UDP 报文就是一个用户消息的边界，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。 你可能会问，如果收到了两个 UDP 报文，操作系统是怎么区分开的？操作系统在收到 UDP 报文后，会将其插入到队列里，队列里的每一个元素就是一个 UDP 报文 为什么 TCP 是面向字节流的协议？ 当用户消息通过 TCP 协议传输时，消息可能会被操作系统分组成多个的 TCP 报文，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的，因为用户消息被拆分成多个 TCP 报文后，并不能像 UDP 那样，一个 UDP 报文就能代表一个完整的用户消息。在发送端，当我们调用 send 函数完成数据“发送”以后，数据并没有被真正从网络上发送出去，只是从应用程序拷贝到了操作系统内核协议栈中。至于什么时候真正被发送，取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件。因此，我们不能认为一个用户消息对应一个 TCP 报文，正因为这样，所以 TCP 是面向字节流的协议。 当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。 要解决这个问题，要交给应用程序。 如何解决粘包？ 固定长度的消息；不够灵活 特殊字符作为边界；如HTTP的/r/n 自定义消息结构。比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。1234struct &#123; u_int32_t message_length; char message_data[]; &#125; message; 当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。 服务器在返回数据时，会有 Content-Length 字段，表明本次回应的数据长度。HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题。 补充，MTU和MSSMTU：一个网络包的最大长度，以太网中一般为 1500 字节；Maximum Transmission UnitMSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；Maximum Segment SizeMSS为1460=1500(MTU)- 20(IP Header) -20 (TCP Header)。由于IP层会进行分片，所以为了避免分片，IP层会协商MSS 1.1 常见问题总结计算机网络功能 数据通信（连通性） 资源共享（硬件，软件，数据） 分布式处理（协同hadoop平台） 提高可靠性（替代机） 负载均衡 计算机网络组成 组成部分（硬件，软件，协议） 工作方式（边缘部分：用户直接使用（c/s方式，P2P模式）；核心部分：为边缘部分服务） 功能组成（数据通信，资源共享）通信子网，资源子网 DNS：万维网上作为域名和IP地址相互映射的一个分布式数据库 TelNet： 远程终端协议；远程登录基于TCP协议，进行可靠传输；透明服务—又称“终端仿真协议” 计算机网络，是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统。网络按其分布范围可分为：LAN:局域网,范围小,一般一个公司内MAN(Metropolitan Area Network):城域网,范围较大,一般为电信公司的全城网络WAN:广域网,整个宽带网络,范围大 IP数据报的收发方进行跨网投递时，发送方需利用ARP协议获取哪些信息（发送方本网段路由器对应端口的MAC地址）发送方要知道接收方的IP地址即可，在路由器中可用ARP协议找到接受发的MAC地址。所以发送方不关心接收方的MAC地址，但发送前要填上自己的MAC地址 A类网络地址，前8位是网络号，首位为0，所以是1-126B是128.1-191.255C是192.0.1-223.255.255 2.1 TCP/IP分层模型3.1 HTTP3.1.1 基本概念Hypertext transfer ptotocol超文本传输协议HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」 那「HTTP 是用于从互联网服务器传输超文本到本地浏览器的协议」，这种说法正确吗？ 这种说法是不正确的。因为也可以是「服务器&lt; — &gt;服务器」，所以采用两点之间的描述会更准确。 HTTP 常见的状态码有哪些？ 1xx 提示信息，表示中间状态，还需要后续操作 2xx 成功200 OK204 与200基本相同只是响应头没有body数据206 表示分快下载和断点续传，表示响应返回的body只是一部分 3xx 重定向301 永久重定向302 临时重定向，两者都会给出重定向后的url,浏览器会自动跳转304 缓存重定向，就是说这个东西缓存里有而且没有被改变，直接从缓存里读就OK了，不需要重新访问 4xx 客户端错误400 报文错误，笼统的错误403 禁止访问404 给出的URL有问题，找不到 5xx 服务器错误500 笼统的错误502 Bad Getway 服务器作为网关或代理，访问后端服务器时异常503 服务器正忙3.1.2 HTTP 缓存有哪些实现方式？ 3.1.3 HTTPSHTTP/1.1 /2 /3的 2，是基于HTTPS的，本身就保证了安全 头部压缩 二进制格式 并发传输，解决队头阻塞，一次可以发多个响应message针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，接收端可以通过 Stream ID 有序组装成 HTTP 消息，不同 Stream 的帧是可以乱序发送的，因此可以并发不同的 Stream ，也就是 HTTP/2 可以并行交错地发送请求和响应。 服务器主动推送资源 仍然存在队头阻塞，不过是由于TCP层面造成的，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的所有的 HTTP 请求都必须等待这个丢了的包被重传回来。 3 HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！ DP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 QUIC 协议 可以实现类似 TCP 的可靠性传输。 QUIC 有以下 3 个特点。 无队头阻塞 更快的连接建立 连接迁移 4.4 TCP半连接队列 半连接队列，也称 SYN 队列； 全连接队列，也称 accept 队列；服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。 当服务端并发处理大量请求时，如果 TCP 全连接队列过小，就容易溢出。发生 TCP 全连接队溢出的时候，后续的请求就会被丢弃，这样就会出现服务端请求数量上不去的现象。 实际上，丢弃连接只是 Linux 的默认行为，我们还可以选择向客户端发送 RST 复位报文，告诉客户端连接已经建立失败。tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示： 0 ：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ； 1 ：如果全连接队列满了，server 发送一个 reset 包给 client，表示废掉这个握手过程和这个连接； 推荐设置为0，即满的时候丢弃：设想一下如果是短暂的繁忙造成 accept 队列满，那么当 TCP 全连接队列有空位时，再次接收到的请求报文由于含有 ACK，仍然会触发服务器端成功建立连接。所以，tcp_abort_on_overflow 设为 0 可以提高连接建立的成功率，只有你非常肯定 TCP 全连接队列会长期溢出时，才能设置为 1 以尽快通知客户端。 如何增大全连接队列 TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog) somaxconn 是 Linux 内核的参数，默认值是 128，可以通过 /proc/sys/net/core/somaxconn 来设置其值； backlog 是 listen(int sockfd, int backlog) 函数中的 backlog 大小，Nginx 默认值是 511，可以通过修改配置文件设置其长度； 如果 SYN 半连接队列已满，只能丢弃连接吗？ 并不是这样，开启 syncookies 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，在前面我们源码分析也可以看到这点，当开启了 syncookies 功能就不会丢弃连接。 syncookies 是这么做的：服务器根据当前状态计算出一个值，放在己方发出的 SYN+ACK 报文中发出，当客户端返回 ACK 报文时，取出该值验证，如果合法，就认为连接建立成功。 如何防御 SYN 攻击？ 增大半连接队列；要想增大半连接队列，我们得知不能只单纯增大 tcp_max_syn_backlog 的值，还需一同增大 somaxconn 和 backlog，也就是增大全连接队列。 开启 tcp_syncookies 功能,syncookies = 1 时，半连接队列满后，后续的请求就不会存放到半连接队列了，而是在第二次握手的时候，服务端会计算一个 cookie 值 减少 SYN+ACK 重传次数 4.5 优化TCP握手的优化 客户端的优化 当客户端发起 SYN 包时，可以通过 tcp_syn_retries 控制其重传的次数。第三次握手不会重传，因为ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。所以客户端只设计第一次握手的优化 服务端的优化 当服务端 SYN 半连接队列溢出后，会导致后续连接被丢弃，可以通过 netstat -s 观察半连接队列溢出的情况，如果 SYN 半连接队列溢出情况比较严重，可以通过 tcp_max_syn_backlog、somaxconn、backlog 参数来调整 SYN 半连接队列的大小。 服务端回复 SYN+ACK 的重传次数由 tcp_synack_retries 参数控制。如果遭受 SYN 攻击，应把 tcp_syncookies 参数设置为 1，表示仅在 SYN 队列满后开启 syncookie 功能，可以保证正常的连接成功建立。 服务端收到客户端返回的 ACK，会把连接移入 accpet 队列，等待进行调用 accpet() 函数取出连接。 可以通过 ss -lnt 查看服务端进程的 accept 队列长度，如果 accept 队列溢出，系统默认丢弃 ACK，如果可以把 tcp_abort_on_overflow 设置为 1 ，表示用 RST 通知客户端连接建立失败。 如果 accpet 队列溢出严重，可以通过 listen 函数的 backlog 参数和 somaxconn 系统参数提高队列大小，accept 队列长度取决于 min(backlog, somaxconn)。 绕过三次握手 TCP Fast Open 功能可以绕过三次握手，使得 HTTP 请求减少了 1 个 RTT 的时间，Linux 下可以通过 tcp_fastopen 开启该功能，同时必须保证服务端和客户端同时支持。 挥手的优化 主动方的优化 主动发起 FIN 报文断开连接的一方，如果迟迟没收到对方的 ACK 回复，则会重传 FIN 报文，重传的次数由 tcp_orphan_retries 参数决定。 当主动方收到 ACK 报文后，连接就进入 FIN_WAIT2 状态，根据关闭的方式不同，优化的方式也不同： 如果这是 close 函数关闭的连接，那么它就是孤儿连接。如果 tcp_fin_timeout 秒内没有收到对方的 FIN 报文，连接就直接关闭。同时，为了应对孤儿连接占用太多的资源，tcp_max_orphans 定义了最大孤儿连接的数量，超过时连接就会直接释放。 反之是 shutdown 函数关闭的连接，则不受此参数限制； 当主动方接收到 FIN 报文，并返回 ACK 后，主动方的连接进入 TIME_WAIT 状态。这一状态会持续 1 分钟，为了防止TIME_WAIT 状态占用太多的资源，tcp_max_tw_buckets 定义了最大数量，超过时连接也会直接释放。 当 TIME_WAIT 状态过多时，还可以通过设置 tcp_tw_reuse 和 tcp_timestamps 为 1 ，将 TIME_WAIT 状态的端口复用于作为客户端的新连接，注意该参数只适用于客户端。 被动方的优化 被动关闭的连接方应对非常简单，它在回复 ACK 后就进入了 CLOSE_WAIT 状态，等待进程调用 close 函数关闭连接。因此，出现大量 CLOSE_WAIT 状态的连接时，应当从应用程序中找问题。（即被动关闭一方，在发现没有数据可读时，即read返回0时，要及时close） 当被动方发送 FIN 报文后，连接就进入 LAST_ACK 状态，在未等到 ACK 时，会在 tcp_orphan_retries 参数的控制下重发 FIN 报文。 双方是可以同时关闭的，此时出现了一个新状态CLOSING 4.6 TCP面向字节流4.18 端口问题 客户端已经用了 64992 端口，那么还可以继续使用该端口发起连接吗？ 可以，只要TCP 连接的四元组（源IP地址，源端口，目的IP地址，目的端口）不一样，即客户端完全可以用这个端口去连别的服务器，或同一服务器别的端口，只要4元组不一样就行。 客户端使用bind 客户端其实一般不用bind,而是用connect，使用connect的时候，会自动选择一个端口，当然也可以用，在bind时需要看多个客户端绑定的 IP + PORT 是否都相同，如果都是相同的，那么在执行 bind() 时候就会出错，错误是“Address already in use” TIME_WAIT状态 客户端都是与同一个服务器（目标地址和目标端口一样）建立连接，那么如果客户端 TIME_WAIT 状态的连接过多，当端口资源被耗尽，就无法与这个服务器再建立连接了。 但是，因为只要客户端连接的服务器不同，端口资源可以重复使用的。 所以，如果客户端都是与不同的服务器建立连接，即使客户端端口资源只有几万个， 客户端发起百万级连接也是没问题的（当然这个过程还会受限于其他资源，比如文件描述符、内存、CPU 等）。如果就是完全一致，也是有解决办法的，那就是打开 net.ipv4.tcp_tw_reuse 这个内核参数。 因为开启了这个内核参数后，客户端调用 connect 函数时，如果选择到的端口，已经被相同四元组的连接占用的时候，就会判断该连接是否处于 TIME_WAIT 状态，如果该连接处于 TIME_WAIT 状态并且 TIME_WAIT 状态持续的时间超过了 1 秒，那么就会重用这个连接，然后就可以正常使用该端口了。否则，connect会选择其他端口，都被占用的话，就会失败。 TCP和UDP TCP 和 UDP 传输协议，在内核中是由两个完全独立的软件模块实现的。 当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。 因此， TCP/UDP 各自的端口号也相互独立，互不影响。 服务器端重启与TIME_WAIT 当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。 当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误。 要解决这个问题，我们可以对 socket 设置 SO_REUSEADDR 属性。这样即使存在一个和绑定 IP+PORT 一样的 TIME_WAIT 状态的连接，依然可以正常绑定成功，因此可以正常重启成功。 4.19 服务端没有 listen，客户端发起连接建立，会发生什么？如果没有开启listen的话，客户端会收到一个RST报文connect的底层实现是，函数首先查找连接建立状态的socket（inet_lookup_established），在没有命中的情况下，才会查找监听套接口（inet_lookup_listener）然后根据目的地址和目的端口算出一个哈希值，然后在哈希表找到对应监听该端口的 socket。本次的案例中，服务端是没有调用 listen 函数的，所以自然也是找不到监听该端口的 socket。 那么没有listen，可以建立TCP连接么？ 是可以的，客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。listen 方法时，会创建半连接队列和全连接队列。三次握手的过程中会在这两个队列中暂存连接信息。所以形成连接，前提是你得有个地方存放着，方便握手的时候能根据 IP + 端口等信息找到对应的 socket。在没有listen的情况下，如在 TCP 自连接的情况中，客户端在 connect 方法时，最后会将自己的连接信息放入到这个全局 hash 表中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP + 端口信息，再一次从这个全局 hash 中取出信息。于是握手包一来一回，最后成功建立连接。 4.20 没有 accept，能建立 TCP 连接吗？答案是可以的，accept的功能只不过是从全连接队列中取出一个连接，当第三次握手的时候，服务端就会把半连接队列中的信息移入全连接队列，此时已经完成连接建立了，accept只不过是取一个已经建立好的连接半连接队列（SYN队列），服务端收到第一次握手后，会将sock加入到这个队列中，队列内的sock都处于SYN_RECV 状态。全连接队列（ACCEPT队列），在服务端收到第三次握手后，会将半连接队列的sock取出，放到全连接队列中。队列里的sock都处于 ESTABLISHED状态。这里面的连接，就等着服务端执行accept()后被取出了。 虽然都叫队列，但其实全连接队列（icsk_accept_queue）是个链表，而半连接队列（syn_table）是个哈希表。 全连接队列随便按顺序取就可以了，但是在第三次握手的信息来之后，要快速在半连接队列中找到对应的连接，所以设计成哈希表，更快，可以看一下4.19的问题，就是这样 全连接队列满了怎么办？如果队列满了，服务端还收到客户端的第三次握手ACK，默认当然会丢弃这个ACK。 但除了丢弃之外，还有一些附带行为，这会受tcp_abort_on_overflow 参数的影响。 tcp_abort_on_overflow设置为 0，全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的SYN+ACK，如果重传超过一定限制次数，还会把对应的半连接队列里的连接给删掉。这样客户端会再次执行第三次握手，这段时间如果全连接队列有位置了，就可以连接了 tcp_abort_on_overflow设置为 1，全连接队列满了之后，就直接发RST给客户端，效果上看就是连接断了。类比4.19，服务端端口未监听时，客户端尝试去连接，服务端也会回一个RST。这两个情况长一样，所以客户端这时候收到RST之后，其实无法区分到底是端口未监听，还是全连接队列满了。 半连接队列要是满了会怎么样,SYN攻击 一般是丢弃，但这个行为可以通过 tcp_syncookies 参数去控制。通常半连接队列中元素呆的时间很短，因为只需要第一次握手加入，第三次握手就移除了，那么SYN Flood攻击，可以简单理解为，攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来， 当tcp_syncookies被设置为1的时候，客户端发来第一次握手SYN时，服务端不会将其放入半连接队列中，而是直接生成一个cookies，这个cookies会跟着第二次握手，发回客户端。客户端在发第三次握手的时候带上这个cookies，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。可以看出整个过程不再需要半连接队列的参与 cookies并不会有一个专门的队列保存，它是通过通信双方的IP地址端口、时间戳、MSS等信息进行实时计算的，保存在TCP报头的seq里。 cookies的问题 因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。 编码解码cookies，都是比较耗CPU的，利用这一点，如果此时攻击者构造大量的第三次握手包（ACK包），同时带上各种瞎编的cookies信息，服务端收到ACK包后以为是正经cookies，憨憨地跑去解码（耗CPU），最后发现不是正经数据包后才丢弃。这种通过构造大量ACK包去消耗服务端资源的攻击，叫ACK攻击，受到攻击的服务器可能会因为CPU资源耗尽导致没能响应正经请求。 4.20 TCP丢包数据从发送端到接收端，链路很长，任何一个地方都可能发生丢包，几乎可以说丢包不可避免。平时没事也不用关注丢包，大部分时候TCP的重传机制保证了消息可靠性。当你发现服务异常的时候，比如接口延时很高，总是失败的时候，可以用ping或者mtr命令看下是不是中间链路发生了丢包。TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。 4.21 4次挥手能否改为3次主要指被动关闭一方的FIN和ACK是否可以合并为一次 假设被动关闭的服务端应用程序可能还有数据要发送*，所以并不能马上发送 FIN 报文，而是将发送 FIN 报文的控制权交给服务端应用程序： 如果服务端应用程序有数据要发送的话，就发完数据后，才调用关闭连接的函数； 如果服务端应用程序没有数据要发送的话，可以直接调用关闭连接的函数， 前面介绍 TCP 四次挥手的时候，并没有详细介绍关闭连接的函数，其实关闭的连接的函数有两种函数： close 函数，同时 socket 关闭发送方向和读取方向，也就是 socket 不再有发送和接收数据的能力。如果有多进程/多线程共享同一个 socket，如果有一个进程调用了 close 关闭只是让 socket 引用计数 -1，并不会导致 socket 不可用，同时也不会发出 FIN 报文，其他进程还是可以正常读写该 socket，直到引用计数变为 0，才会发出 FIN 报文。shutdown 函数，可以指定 socket 只关闭发送方向而不关闭读取方向，也就是 socket 不再有发送数据的能力，但是还是具有接收数据的能力。如果有多进程/多线程共享同一个 socket，shutdown 则不管引用计数，直接使得该 socket 不可用，然后发出 FIN 报文，如果有别的进程企图使用该 socket，将会受到影响 如果客户端是用 close 函数来关闭连接，那么在 TCP 四次挥手过程中，如果收到了服务端发送的数据，由于客户端已经不再具有发送和接收数据的能力，所以客户端的内核会回 RST 报文给服务端，然后内核会释放连接，这时就不会经历完成的 TCP 四次挥手，所以我们常说，调用 close 是粗暴的关闭。shutdown 函数因为可以指定只关闭发送方向而不关闭读取方向，所以即使在 TCP 四次挥手过程中，如果收到了服务端发送的数据，客户端也是可以正常读取到该数据的，然后就会经历完整的 TCP 四次挥手，所以我们常说，调用 shutdown 是优雅的关闭。 什么情况下是三次挥手 「没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。 计算机网络TCP4次挥手的时候，如果是close，那么FIN_WAIT2不会持续很久，一般是60s，但如果主动关闭方使用 shutdown 函数关闭连接，指定了只关闭发送方向，而接收方向并没有关闭，那么意味着主动关闭方还是可以接收数据的。那么主动关闭方的连接将会一直处于 FIN_WAIT2 状态 为什么需要 TIME_WAIT 状态？ 主动发起关闭连接的一方，才会有 TIME-WAIT 状态。,需要 TIME-WAIT 状态，主要是两个原因： 防止历史连接中的数据，被后面相同四元组的连接错误的接收； 保证「被动关闭连接」的一方，能被正确的关闭； 当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive，因为任意一方没有开启 HTTP Keep-Alive，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 TIME_WAIT 状态的连接。 TCP 针对数据包丢失的情况，会用重传机制解决。 超时重传RTT（Round-Trip Time 往返时延）指数据自发送时刻到接收到确认之间的间隔RTO （Retransmission Timeout 超时重传时间），太小会频繁重发，太大效率低 超时重传时间 RTO 的值应该略大于报文往返 RTT 的值，会多次采样RTT，然后动态计算RTO，每次触发超时后，会翻倍 快速重传快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"C++学习笔记","slug":"C++","date":"2023-07-10T16:00:00.000Z","updated":"2023-07-15T08:12:07.215Z","comments":true,"path":"2023/07/11/C++/","link":"","permalink":"http://example.com/2023/07/11/C++/","excerpt":"","text":"语言基础智能指针 怕你忘记释放，内存泄露，都是用来管理堆内存的小方的讲解智能指针其作⽤是管理⼀个指针，避免咋们程序员申请的空间在函数结束时忘记释放(也就是说主要是管理堆内存的)，造成内存泄漏这种情况滴发⽣。然后使⽤智能指针可以很⼤程度上的避免这个问题，因为智能指针就是⼀个类，当超出了类的作⽤域是，类会⾃动调⽤析构函数，析构函数会⾃动释放资源。所以智能指针的作⽤原理就是在函数结束时⾃动释放内存空间，不需要⼿动释放内存空间。 auto_ptr（C++98，C++11已抛弃）auto_ptr的出现，主要是为了解决“有异常抛出时发生内存泄漏”的问题；抛出异常，将导致指针p所指向的空间得不到释放而导致内存泄漏；auto_ptr构造时取得某个对象的控制权，在析构时释放该对象。我们实际上是创建一个auto_ptr类型的局部对象，该局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；主要问题在于采用拷贝构造或者赋值时，原指针的所有权被剥夺，这样就存在内存泄露的问题123456auto_ptr&lt;std::string&gt; p1 (new string (&quot;hello&quot;));//std::shared_ptr&lt;int&gt; p4 = new int(1);的写法是错误的auto_ptr&lt;std::string&gt; p2;p2 = p1; //auto_ptr不会报错，但是此时p1已经不指向hello了，auto_ptr&lt;std::string&gt; p3(p2);//拷贝构造和赋值类似，都会剥夺原指针的所有权get()是std::shared_ptr和std::unique_ptr这两个智能指针类的成员函数，它返回指针所持有的对象的原始指针，被剥夺所有权的指针，调用get返回NULL unique_ptrunique_ptr对其持有的堆内存具有唯一拥有权，也就是说引用计数永远是1，std::unique_ptr对象销毁时会释放其持有的堆内存。可以使用以下方式初始化一个std::unique_ptr对象将赋值和拷贝构造均设为=delete，来解决auto_ptr的问题123456789//初始化方式1std::unique_ptr&lt;int&gt; sp1(new int(123));//初始化方式2std::unique_ptr&lt;int&gt; sp2;sp2.reset(new int(123));//初始化方式3,推荐使用，更安全std::unique_ptr&lt;int&gt; sp3 = std::make_unique&lt;int&gt;(123);前述代码在编译时会报错，从而避免了内存泄漏，如需赋值需要用move操作,移动后sp1,sp2为空的智能指针12345678910111213#include &lt;memory&gt;int main()&#123; std::unique_ptr&lt;int&gt; sp1(std::make_unique&lt;int&gt;(123)); std::unique_ptr&lt;int&gt; sp2(std::move(sp1)); std::unique_ptr&lt;int&gt; sp3; sp3 = std::move(sp2); return 0;&#125;shraed_ptrunique_ptr对其持有的资源具有独占性，而std::shared_ptr持有的资源可以在多个std::shared_ptr之间共享，每多一个std::shared_ptr对资源的引用，资源引用计数将增加1，每一个指向该资源的std::shared_ptr对象析构时，资源引用计数减1，最后一个std::shared_ptr对象析构时，发现资源计数为0，将释放其持有的资源。多个线程之间，递增和减少资源的引用计数是安全的。（注意：这不意味着多个线程同时操作std::shared_ptr引用的对象是安全的）。std::shared_ptr提供了一个use_count()方法来获取当前持有资源的引用计数。除了上面描述的，std::shared_ptr用法和std::unique_ptr基本相同。 设置引用计数，利用.use_count()查看有几个指针指向该资源，计数为0时会析构利用reset，放弃对该资源的引用，引用计数-1 12345678910111213141516171819class A &#123;public: std::shared_ptr&lt;B&gt; bPtr;&#125;;class B &#123;public: std::shared_ptr&lt;A&gt; aPtr;&#125;;int main() &#123; std::shared_ptr&lt;A&gt; a = std::make_shared&lt;A&gt;(); std::shared_ptr&lt;B&gt; b = std::make_shared&lt;B&gt;(); a-&gt;bPtr = b; b-&gt;aPtr = a; return 0;&#125; 销毁a,要销毁a的成员变量，也就是b,但是b的引用计数不为0，因为如果要让b的引用计数为0，就要销毁b的成员变量a，形成死循环 智能指针最初设计的目的就是为了管理堆对象的（即那些不会自动释放的资源），主要是看原链接中关于栈变量的设置 weak_ptrweak_ptr是一个不控制资源生命周期的智能指针，是对对象的一种弱引用，只是提供了对其管理的资源的一个访问手段，引入它的目的为协助std::shared_ptr工作。std::weak_ptr可以从一个std::shared_ptr或另一个std::weak_ptr对象构造，std::shared_ptr可以直接赋值给std::weak_ptr,也可以通过std::weak_ptr的lock()函数来获得std::shared_ptr。它的构造和析构不会引起引用计数的增加或减少。std::weak_ptr可用来解决std::shared_ptr相互引用时的死锁问题，即两个std::shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0， 资源永远不会释放。不修改引用计数，两个shared_ptr相互引用，会使各自引用计数为2，在离开作用域析构时，降为1，不会调用析构，所以需要weak_ptr，但是由于/weak_ptr没有重载和-&gt;，*所以不能直接操作资源 weak_ptr提供了一个expired()方法来做这一项检测，返回true，说明其引用的资源已经不存在了；返回false，说明该资源仍然存在;这个时候可以使用std::weak_ptr 的lock()方法得到一个std::shared_ptr对象然后继续操作资源，weak_ptr类没有重写operator-&gt;和operator方法，因此不能像std::shared_ptr或std::unique_ptr一样直接操作对象，同时std::weak_ptr类也没有重写operator bool()操作，因此也不能通过std::weak_ptr*对象直接判断其引用的资源是否存在 12345678910//tmpConn_是一个std::weak_ptr&lt;TcpConnection&gt;对象//tmpConn_引用的TcpConnection已经销毁，直接返回if (tmpConn_.expired()) return;std::shared_ptr&lt;TcpConnection&gt; conn = tmpConn_.lock();if (conn)//只能用shared_ptr操作，因为weak_ptr没有重载*和-&gt;&#123; //对conn进行操作，省略...&#125; 补充：Auto_ptr内部实现，析构函数中删除对象用的是delete而不是delete[]，所以auto_ptr不能管理数组，但智能指针可以一旦一个对象使用智能指针管理后，就不该再使用原始裸指针去操作；除了std::weak_ptr，std::unique_ptr和std::shared_ptr都提供了获取原始指针的方法——get()函数。1234567891011int main()&#123; Subscriber* pSubscriber = new Subscriber(); std::unique_ptr&lt;Subscriber&gt; spSubscriber(pSubscriber); //pTheSameSubscriber和pSubscriber指向同一个对象 Subscriber* pTheSameSubscriber= spSubscriber.get(); return 0;&#125;unique_ptr的指针大小和原始指针一样，64位机占8个字节，但是shared/weak都是16字节通常情况下，如果你的资源不需要在其他地方共享，那么应该优先使用std::unique_ptr，反之使用std::shared_ptr，当然这是在该智能指针需要管理资源的生命周期的情况下；如果不需要管理对象的生命周期，请使用std::weak_ptr C++中内存分配情况堆往上堆，高地址堆，栈往下打，两个中间是未使用区栈：由编译器管理分配和回收，存放局部变⾥和函数参数。堆：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量和静态变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区，在该区定义的变量若没有初始化，则会被自动初始化，例如int型变量自动初始为0常⾥存储区：存储常⾥，⼀般不允许修改。代码区：存放程序的⼆进制代码 static关键字static 作⽤：控制变⾨的存储⽅式和可⻅性。作⽤⼀：修饰局部变量：⽤ static 关键字修饰的话，该变⾥便会存放在静态数据区，其⽣命周期会⼀直延续到整个程序执⾏结束，但其作⽤域并没有改变，作⽤域还是限制在其语句块。作⽤⼆：修饰全部变量：对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被访问(添加 extern进⾏声明即可)。⽤ static 对全局变⾥进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成了本⽂件可⻅。作⽤三：修饰函数：⽤ static 修饰函数，情况和修饰全局变⾥类似，也是改变了函数的作⽤域。仅在本文件可用作⽤四：修饰类：如果 C++ 中对类中的某个函数⽤ static 修饰，则表示该函数属于⼀个类⽽不是属于此类的任何特定对象；如果对类中的某个变⾥进⾏ static 修饰，则表示该变⾥以及所有的对象所有，存储空间中只存在⼀个副本，可以通过；类和对象去调⽤。静态⾮常⾥数据成员，其只能在类外定义和初始化，在类内仅是声明⽽已。且不能被virtual修饰，因为virtual依赖实例调用来实现，也就是this指针，但静态函数没有const 关键字和 static 关键字对于成员函数来说是不能同时使⽤的，因为 static 关键字修饰静态成员函数不含有 this 指针，即不能实例化，const 成员函数⼜必须具体到某⼀个函数。 全局变量和静态变量C++中的全局变量和静态变量有以下区别： 作用域： 全局变量：全局变量在整个程序中都是可见的，可以在任何函数内部访问和使用。 静态变量：静态变量的作用域限制在其定义所在的函数或文件内，只能在其定义所在的函数或文件内部访问和使用。 存储位置和生命周期： 全局变量：全局变量在程序运行期间一直存在，存储在静态存储区（全局数据区），在程序启动时进行初始化，直到程序结束时才被销毁。 静态变量：静态变量在程序执行流程中也一直存在，存储在静态存储区，但其生命周期仅限于其定义所在的函数或文件的生命周期。静态变量在首次使用时初始化，并在程序结束时销毁。 初始化： 全局变量：全局变量可以在定义时进行初始化，如果没有显式初始化，则会被默认初始化为对应类型的零值。 静态变量：静态变量可以在定义时进行初始化，如果没有显式初始化，则会被默认初始化为对应类型的零值。静态变量只会被初始化一次，在其定义所在的函数或文件第一次执行时进行初始化。 可见性： 全局变量：全局变量在整个程序中都是可见的，可以被其他文件中的函数访问，需要使用extern关键字进行声明。 静态变量：静态变量的可见性仅限于其定义所在的函数或文件内部，无法被其他文件中的函数直接访问，只能在其定义所在的函数或文件内部使用。 多次定义： 全局变量：全局变量可以在不同的文件中定义多次，但是这会导致多个定义之间的链接错误。 静态变量：静态变量在其定义所在的函数或文件内部是唯一的，不会出现多次定义的情况。 总之，全局变量具有整个程序可见的特性，而静态变量具有更小的作用域和可见性，并且仅在其定义所在的函数或文件内部可见。全局变量的生命周期和作用域更长，而静态变量的生命周期仅限于其定义所在的函数或文件。 常量的存储在C++中，常量有两种形式：编译时常量（Compile-time constants）和运行时常量（Run-time constants）。 编译时常量： 整型常量、浮点型常量、字符常量等编译时可以确定并被替换的常量，被视为编译时常量。 编译时常量通常直接嵌入到生成的机器代码中，不占用运行时内存。 运行时常量： 运行时常量是在程序运行时确定的常量，例如使用const关键字定义的常量变量。 运行时常量存储在程序运行时的内存中，其具体存储位置取决于其作用域和声明方式。 在内存中，运行时常量可能存储在以下几个区域： 栈（Stack）： 函数内的局部常量变量通常存储在栈上。 栈上的常量在函数调用结束后自动销毁。 静态存储区（Static storage area）： 全局常量和静态常量（通过static关键字修饰的静态变量）存储在静态存储区。 静态存储区的常量在整个程序的生命周期内都存在，直到程序结束才会被销毁。 文字常量区（Text/Code segment）： 字符串常量（例如&quot;Hello, world!&quot;）通常存储在文字常量区。 文字常量区存储了程序中的只读数据，其内容在程序运行时是不能修改的。 需要注意的是，具体的内存区域和常量存储方式可能受到编译器和操作系统的影响，不同的平台可能有不同的实现细节。因此，对于常量的具体存储区域，可以参考编译器和操作系统的文档或规范进行了解。 8. 重载，重写，重定义（隐藏）重写是指子类重写父类的虚函数，虚函数不能是静态的，重写函数的修饰符可以从private改为public，要求参数和返回值的类型都一致重定义是指派生类重新定义父类中的非virtual函数， 参数列表或返回值与基类不同，导致基类方法不能使用，或者说被隐藏 重写必须是虚函数，父类中的虚函数可以没有实现子类在继承父类的时候会完全拷贝一份父类的，在访问同名变量的时候会优先访问，重定义没有必须要求参数列表一样，只要函数名一样就行 10.C++的强制类型转换感觉不是很常用，static_cast\\dynamic_cast\\const_cast\\reinterpret_cast参考链接static_cast：明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换（派⽣类-&gt;基类）安全，下⾏转换（基类-&gt;派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；dynamic_cast：专⻔⽤于派⽣类之间的转换,不用于基本数据类型，type-id 必须是类指针，类引⽤或 void，对于下⾏转换是安全的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题。解决了下行转换的安全问题const_cast：&lt;&gt;里的类型也只能是指针或引用，专⻔⽤于 const 属性的转换，*去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个可以操作常量的转换符。12volatile int num = 10;int&amp; num1 = const_cast&lt;int&amp;&gt;(num);reinterpret_cast：不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏⾦新解释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤之间进⾏肆⽆忌惮的转换 11.引用和指针引用只是个别名，指针是一个实体引用只能在定义的时候进行绑定且不能更改，引用必须初始化，sizeof对于引用，得到绑定变量的大小，而对于指针得到的是指针的大小，64位机指针变量是8字节 指针和引⽤都是⼀种内存地址的概念，区别呢，指针是⼀个实体，引⽤只是⼀个别名。在程序编译的时候，将指针和引⽤添加到符号表中。指针它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将指针变⾥名-指针变量的地址添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有 const 和⾮ const 区别，甚⾄可以为空，sizeof 指针得到的是指针类型的⼤⼩。⽽对于引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将引⽤变⾥名-引⽤对象的地址添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和⾮ const 区别。sizeof 引⽤得到代表对象的⼤⼩。⽽ sizeof 指针得到的是指针本身的⼤⼩。另外在参数传递中，指针需要被解引⽤后才可以对对象进⾏操作，⽽直接对引⽤进⾏的修改会直接作⽤到引⽤对象上。作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引⽤的实质是传地址，传递的是变⾥的地址 12.野指针和悬空指针野指针是指没有初始化的指针，悬空指针是指指向内存被释放了的指针，两者都不安全，避免野指针，就记得初始化 13. const修饰指针 常量指针和指针常量，顶层const顶层 const 是可以来表示任意的常量对象，包括算术类型、类、指针等。底层 const 则与指针和引用等复合类型的基本类型部分有关，但对于指针来说，顶层 const（top-level const）用来描述指针常量本身，底层（low-level）用来描述指针所指向的对象。即简单类型都是顶层，只有指针和引用的时候区分，指向常量的指针这个是底层，描述指针指向的内容，而指针本身是常量（也就是指针常量）这里是顶层即顶层是本身，底层是指向的那个东西1234567891011121314int i = 0;const int ci = 42; //这是一个顶层const，基于顶层const定义+“顶层 const 可以表示任意的对象是常量”const int *p2 = &amp;ci; //这是一个底层const,指向的东西是常量，底层const int *const p3 = p2; //靠右的是顶层，靠右的是说指针本身是常量，本身所以是顶层，靠左的是底层i = ci; //正确，ci是一个顶层，只需要考虑它本身和i类型是否对的上p2 = p3; //正确，对于底层部分，考虑它们所指的对象，p2指向常量，p3指向常量。对于顶层部分，p3是顶层，所以不影响。int *p = p3; //错误，底层部分，p3有底层而p没有，p3指向常量，p指向非常量，那么程序可以试图通过p去改变一个常量，所以是错误的。//不能把常量赋给非常量p2 = p3； //正确, 两个都是底层，即指向的都是常量。p2 = &amp;i; //正确，底层部分：p2指向常量，但是int i是可以转换成常量的。int &amp;r = ci; //错误，因为非常量的引用r会试图改变常量ci的值。const int &amp;r2 =i; //正确，用于声明引用的都是底层const，int i可以转换成常量。 常量指针，指针指向常量，不可以通过指针修改，但是这个变量可以修改，只是说不能通过指针修改12345int x = 5;int y = 10;const int* ptr = &amp;x; // ptr是一个常量指针，指向一个整型常量*ptr = 7; // 错误，不能通过常量指针修改所指向的内容ptr = &amp;y; // 正确，可以修改常量指针的值，使其指向另一个变量 指针常量的指向不可修改，但是指向的内容可以通过该指针修改12345int x = 5;int y = 10;int* const ptr = &amp;x; // ptr是一个指针常量，指向一个整型变量*ptr = 7; // 可以通过指针常量修改所指向的内容ptr = &amp;y; // 错误，不能修改指针常量的值，即不能使其指向其他内存位置 14. 函数指针12345char fun (char *p)//函数fun的返回值是char 类型char (*pf) (char *p)//用(*pf)代替函数名fun,pf就是一个函数指针，一定记得带括号char *pf1 (char *p)//不带括号的话，就会认为pf1是一个函数，返回值是char*类型pf = fun;//函数指针pf指向函数fun,第二行只是一个定义，此时函数指针并没有指向一个具体的函数，这一行才是定义pf(p);//可以用pf调用函数fun 15.堆和栈栈存放局部变量，由编译器管理，注意栈是从高地址向低地址扩展，堆由程序员自己申请，堆是不连续的，实际上系统中有⼀个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存⼤⼩，⽅便 delete 回收空间⼤⼩。补充：栈是连续的内存空间，堆是不连续的，函数调用的时候默认是从右到左如栈的，这样最左边的参数位于栈顶，可以最早出来，也就是和函数定义是一样的 补充：malloc是如何分配内存的 malloc() 源码里默认定义了一个阈值：如果用户分配的内存小于 128 KB，则通过 brk() 申请内存；直接在堆底申请如果用户分配的内存大于 128 KB，则通过 mmap() 申请内存；在文件映射区拿一块内存malloc 通过 brk() 方式申请的内存，free 释放内存的时候，并不会把内存归还给操作系统，而是缓存在 malloc 的内存池中，待下次使用；malloc 通过 mmap() 方式申请的内存，free 释放内存的时候，会把内存归还给操作系统，内存得到真正的释放。 由于malloc需要执行系统调用，所以一般只有在申请内存较大的时候调用，不然很慢，brk调用不需要系统调用，但是如果都用brk的话，上述说过在delete后不会立马归还操作系统，所以如果大的空间也用brk的话，会很浪费，因为用完不还。 16.函数传递参数值传递：形参是实参的拷⻉，函数内部对形参的操作并不会影响到外部的实参。指针传递：也是值传递的⼀种⽅式，形参是指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进⾏操作。引⽤传递：实际上就是把引⽤对象的地址放在了开辟的栈空间中，函数内部对形参的任何操作可以直接映射到外部的实参上⾯。 17.new/deletenew /delete 是操作符，malloc/free 是库函数。 new自动计算要分配的空间大小，malloc需要手工计算，malloc和free返回的是void类型指针（必须进行类型转换） new是类型安全的，malloc不是。比如：12int *p = new float[2]; //编译错误,因为前后的类型不一样int *p = (int*)malloc(2 * sizeof(double));//编译无错误 new调用名为operator new的标准库函数分配足够空间并调用相关对象的构造函数，delete对指针所指对象运行适当的析构函数；然后通过调用名为operator delete的标准库函数释放该对象所用内存。后者均没有相关调用 后者需要库文件支持，前者不用，new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象 执⾏ new 实际上执⾏两个过程： 分配未初始化的内存空间（malloc）； 使⽤对象的构造函数对空间进⾏初始化；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处理函数捕获处理；如果在第⼆步构造对象时出现异常，则⾃动调⽤ delete 释放内存。执⾏ delete 实际上也有两个过程： 使⽤析构函数对对象进⾏析构； 回收内存空间（free）。 为什么有了 malloc／free 还需要 new／delete？因为对于⾮内部数据类型⽽⾔，光⽤ malloc／free ⽆法满⾜动态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。由于 mallo／free 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务强加于malloc／free，所以有了 new／delete 操作符。 18. extern/volatile在 C 语⾔中，修饰符 extern ⽤在变量或者函数的声明前，⽤来说明 “此变量/函数是在别处定义的，要在此处引⽤”。注意 extern 声明的位置对其作⽤域也有关系，如果是在 main 函数中进⾏声明的，则只能在 main 函数中调⽤，在其它函数中不能调⽤。所以如果main函数中想用全局变量，需要把变量定义在main(){}外，这样就是全局变量其实要调⽤其它⽂件中的函数和变量，只需把该⽂件⽤ #include 包含进来即可，为啥要⽤extern？因为⽤ extern 会加速程序的编译过程，这样能节省时间。 volatile提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象 19.define/const对于 define 来说，宏定义实际上是在预编译阶段进⾏处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进⾏字符串的展开，遇到多少次就展开多少次，⽽且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。对于 const 来说，const 是在编译期间进⾏处理的，const 有类型，也有类型检查，程序运⾏时系统会为 const 常量分配内存，⽽且从汇编的⻆度讲，const 常量在出现的地⽅保留的是真正数据的内存地址，只保留了⼀份数据的拷⻉，省去了不必要的内存空间。⽽且，有时编译器不会为普通的 const 常量分配内存，⽽是直接将 const 常量添加到符号表中，省去了读取和写⼊内存的操作，效率更⾼。 20.类的大小计算下⾯⼏个类的⼤⼩12345class A&#123;&#125;; sizeof(A) = 1; //空类在实例化时得到⼀个独⼀⽆⼆的地址，所以为 1. class A&#123;virtual Fun()&#123;&#125; &#125;; sizeof(A) = 4(32bit)/8(64bit) //当 C++ 类中有虚函数的时候，会有⼀个指向虚函数表的指针（vptr）class A&#123;static int a; &#125;; sizeof(A) = 1; //静态变量不占大小class A&#123;int a; &#125;; sizeof(A) = 4; class A&#123;static int a; int b; &#125;; sizeof(A) = 4; 21.封装继承和多态继承的实现方式有两种：实现继承和接口继承，实现继承直接使用基类的属性和方法，接口继承仅使用属性和方法的名称，子类需要提供具体实现多态：多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。 22.多态的实现多态可以分为静态多态（函数重载，编译时就确定了调用哪个函数）和动态多态（继承+虚函数）⼦类继承⽗类时， ⽗类的纯虚函数必须重写，否则⼦类也是⼀个虚类不可实例化。 定义纯虚函数是为了实现⼀个接⼝，起到⼀个规范的作⽤，规范继承这个类的程序员必须实现这个函数。 29.构造顺序优先调用基类构造函数，成员类构造函数，再调用派生类析构相反 补充：继承的实现class A : 继承方式 B; private的都不能访问 public继承的话，public/protected权限不变 其他继承方式，所有权限都变成继承方式的权限 但是还是会被继承下来，只是访问不到，所以B类的大小不管怎么继承都是12 当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？ 访问子类同名成员 直接访问即可访问父类同名成员 需要加作用域12cout &lt;&lt; &quot;Son下的m_A = &quot; &lt;&lt; s.m_A &lt;&lt; endl;cout &lt;&lt; &quot;Base下的m_A = &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数系统并不会判断，比如两个同名函数的参数类型不一样，系统不会帮你选，而是默认调用子类，不匹配就报错，除非加作用域指明用父类的 31.静态绑定和动态绑定静态绑定是指在编译期间完成绑定，所对应的函数或属性依赖于对象的静态类型动态绑定，发生在运行期间，多指虚函数需要注意的是，缺省值，即fun(a,b=2),类似这种某些变量有默认指，可以通过fun(2),只传一个参数就好，这种叫做缺省参数是静态绑定的，派生类如果修改了基类虚函数的缺省参数会失效，因为缺省参数在编译时就已经绑定了，默认绑定基类，所以要避免 32.深拷贝和浅拷贝在没有定义拷贝函数的时候，默认系统会复制每个成员，没有指针的情况下是可行的但是拷贝的时候，有指针，两个指针会指向同一地址，这样会出现野指针，即一个对象析构后，复制的这份对象该指针指向的内容会变为失效地址（野指针），同时，复制后的对象析构时，是对野指针析构会出现内存泄漏或系统崩溃深拷贝会在堆区中另外申请一份空间，解决野指针问题，即复制后的指针指向一个新的地址空间，这个空间的值和原来的一样，只是地址不一样 33.拷贝构造函数调用时机对象以值传递的方式传入函数的时候这也是为什么，力扣刷题写成引用可以缩短时间，因为避免了一次拷贝拷贝构造一个临时变量压入栈中同样，值传递方式的返回值也会是一个拷贝构造的临时对象一个对象通过另一个对象进行初始化 34.拷贝构造必须是引用传递，不然会递归调用，无限递归，值传递会自己调自己35.结构体内存对齐主要是为了提升访问速度，因为CPU都是一块一块读取的，如果先有一个char占0索引，int占1-4索引CPU要先读0-3，再读4-7，然后删除0，5-7，效率很低 36.内存泄漏：申请的内存没有释放LINUX：swap命令 37.平衡二叉树。高度平衡二叉树红黑树：（C++中的 每个节点是红/黑 底层的叶子节点，也就是NULL都是黑的 根节点是黑的 每个红色节点的两个子节点一定是黑的 任意一个节点到每个叶子节点的路径都包含相同数量的黑色节点 map,multimap是红黑树，unordered_map是哈希表，set同理红黑树额增删查时间复杂度都是lonN,哈希表是1，但是哈希表一旦需要扩容，将耗费很长时间两者只是底层的实现不一样，但是对外的接口都是类似的 hashmap有unordered_map，map其实就是很明确的红黑树。map比起unordered_map的优势主要有： map始终保证遍历的时候是按key的大小顺序的，这是一个主要的功能上的差异。（有序无序） 时间复杂度上，红黑树的插入删除查找性能都是O(logN)而哈希表的插入删除查找性能理论上都是O(1)，他是相对于稳定的，最差情况下都是高效的。哈希表的插入删除操作的理论上时间复杂度是常数时间的，这有个前提就是哈希表不发生数据碰撞。在发生碰撞的最坏的情况下，哈希表的插入和删除时间复杂度最坏能达到O(n)。 map可以做范围查找，而unordered_map不可以。 扩容导致迭代器失效。 map的iterator除非指向元素被删除，否则永远不会失效。unordered_map的iterator在对unordered_map修改时有时会失效。 39.说⼀下 define、const、typedef、inline 使⽤⽅法？ const 与 #define 的区别 const 定义的变量带类型，⽽ #define 定义的只是个常数不带类型； define 只在预处理阶段起作⽤，简单的⽂本替换，⽽ const 在编译、链接过程中起作⽤； define 没有类型检查。⽽const是有数据类型的，是要进⾏判断的，可以避免⼀些低级错误； define 预处理后，占⽤代码段空间，const 占⽤数据段空间； const 不能取消定义，⽽ define 可以通过 #undef 取消某个符号的定义，进⾏⾦定义； define 独特功能，⽐如可以⽤来防⽌⽂件重复引⽤。 define 和别名 typedef 的区别 执⾏时间不同，typedef 在编译阶段有效，typedef 有类型检查的功能；#define 是宏定义，发⽣在预处理阶段，不进⾏类型检查； 功能差异，typedef ⽤来定义类型的别名，定义与平台⽆关的数据类型，与 struct 的结合使⽤等。 作⽤域不同，#define 没有作⽤域的限制，只要是之前预定义过的宏，在以后的程序中都可以使⽤。⽽ typedef 有⾃⼰的作⽤域。 define 与 inline 的区别 define是关键字，inline是函数； 宏定义在预处理阶段进⾏⽂本替换，inline 函数在编译阶段进⾏替换； inline 函数有类型检查，相⽐宏定义⽐较安全；inline必须和函数定义体放在一起1234inline int add(int a,int b)&#123; return a+b;&#125;cout&lt;&lt;add(a,b)&lt;&lt;endl; 40. C程序从代码到可执行文件的过程： 预处理，#include文件导入，以及其他的预处理命令—》.i文件 编译，检查语言错误—》.s文件 汇编，生成机器指令—》.o文件 链接，几个不同的相互调用的文件组合在一起—》可执行文件 可变参数宏va_list类型的args变量来迭代访问可变参数列表。使用va_start宏初始化args，并使用va_arg宏在循环中提取参数的值。va_arg宏的第二个参数是要提取的参数的类型。最后，使用va_end宏结束参数列表的访问。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdarg&gt;void printValues(const char* format, ...)&#123; va_list args; va_start(args, format); while (*format != &#x27;\\0&#x27;) &#123; if (*format == &#x27;i&#x27;) &#123; int value = va_arg(args, int); std::cout &lt;&lt; value &lt;&lt; std::endl; &#125; else if (*format == &#x27;d&#x27;) &#123; double value = va_arg(args, double); std::cout &lt;&lt; value &lt;&lt; std::endl; &#125; else if (*format == &#x27;c&#x27;) &#123; char value = va_arg(args, int); // char is promoted to int std::cout &lt;&lt; value &lt;&lt; std::endl; &#125; else if (*format == &#x27;s&#x27;) &#123; char* value = va_arg(args, char*); std::cout &lt;&lt; value &lt;&lt; std::endl; &#125; ++format; &#125; va_end(args);&#125;int main()&#123; printValues(&quot;i&quot;, 42); // 输出: 42 printValues(&quot;ids&quot;, 1, 3.14, &quot;Hello&quot;); // 输出: 1, 3.14, Hello return 0;&#125; 在示例中，格式字符串”i”表示只有一个整数参数。在函数调用中，我们提供了一个整数参数42，它将被打印出来。另一个示例中的格式字符串”ids”表示整数、双精度浮点数和字符串参数的组合。在函数调用中，我们依次提供了整数1、双精度浮点数3.14和字符串”Hello”，它们将被按顺序打印出来。 C++11新特性空指针nullptrnullptr用来代替NULL，其类型为nullptr_t,能够隐式转换为任何指针或成员指针，而在此之前空指针常用0或NULL表示，而0是整形，会导致一些问题12void func(int);void func(char *);如果被定义为0，会导致调用第一个函数，如果之前声明了char ch = NULL,却被赋值0，总之就是有歧义，有的编译器会定义NULL为（void)0,有的则是int 0; Lambda表达式12345678910111213141516171819202122232425262728293031[capture](parameters) -&gt; return_type &#123; body &#125;[capture](parameters)mutable -&gt; return_type &#123; body &#125;//以值传递的方式捕获的变量默认是不可以修改的，加上mutable后就可以修改了，只是说capture的变量[capture](parameters) &#123; body &#125;//可以通过函数体推导出来返回值类型，所以可以不写capture：指定在Lambda表达式中访问的外部变量。可以通过值捕获、引用捕获或混合捕获方式来捕获变量。[=]表示按值的方式捕获，[=,&amp;a]表示a用引用捕获，其他变量用值捕获，[this]成员函数中捕获this指针parameters：Lambda函数的参数列表。return_type：指定返回值类型，可以省略，根据表达式自动推断。body：Lambda函数的函数体，可以包含多条语句。//实例#include &lt;iostream&gt;int main()&#123; int a = 3; int b = 5; // 按值来捕获 auto func1 = [a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;; func1(); // 按值来捕获 auto func2 = [=] &#123; std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl; &#125;; func2(); // 按引用来捕获 auto func3 = [&amp;a] &#123; std::cout &lt;&lt; a &lt;&lt; std::endl; &#125;; func3(); // 按引用来捕获 auto func4 = [&amp;] &#123; std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; std::endl; &#125;; func4();&#125; 12初始化列表：Constructor() : member1(value1), member2(value2), ... &#123;&#125; Lambda表达式相对于传统的函数对象或函数指针有以下几个方面的简洁之处： 语法简洁：Lambda表达式的语法相对简短和紧凑，使得代码更易读、更易编写。Lambda表达式的定义直接内联在需要的地方，不需要单独定义函数或函数对象。 捕获上下文变量：Lambda表达式可以通过捕获上下文变量的方式，访问包围它的作用域内的变量。捕获可以通过值捕获或引用捕获实现，使得Lambda表达式更加灵活和方便。 自动类型推断：Lambda表达式可以省略返回值类型的指定，编译器可以根据表达式的返回值自动推断返回类型，减少了代码的冗余。 内联函数：Lambda表达式通常被编译器内联展开，避免了函数调用的开销，提高了执行效率。 便于在算法函数中使用：由于Lambda表达式的简洁性和内联特性，它在使用STL算法函数（如std::for_each、std::sort等）时更加方便，可以直接将Lambda表达式作为算法函数的参数，避免了编写独立的函数对象或函数指针。实例：12345678910111213141516171819202122232425struct Item&#123; Item(int aa, int bb) : a(aa), b(bb) &#123;&#125; int a; int b;&#125;; int main()&#123; std::vector&lt;Item&gt; vec; vec.push_back(Item(1, 19)); vec.push_back(Item(10, 3)); vec.push_back(Item(3, 7)); vec.push_back(Item(8, 12)); vec.push_back(Item(2, 1)); // 根据Item中成员a升序排序 std::sort(vec.begin(), vec.end(), [] (const Item&amp; v1, const Item&amp; v2) &#123; return v1.a &lt; v2.a; &#125;); // 打印vec中的item成员 std::for_each(vec.begin(), vec.end(), [] (const Item&amp; item) &#123; std::cout &lt;&lt; item.a &lt;&lt; &quot; &quot; &lt;&lt; item.b &lt;&lt; std::endl; &#125;); return 0;&#125; 内联函数：当编译器遇到函数调用语句时，它通常会将当前执行位置保存到堆栈中，跳转到函数的代码位置执行，执行完后再返回到调用点继续执行。这个过程涉及保存和恢复执行现场的开销，特别是在频繁调用的小型函数中，函数调用开销可能成为性能瓶颈。为了避免函数调用的开销，编译器可以选择对函数进行内联展开。内联展开是将函数的代码直接插入到函数调用点处，而不是通过跳转到函数代码的位置执行。这样一来，就省去了函数调用的开销，以及保存和恢复执行现场的开销。 右值引用 可位于赋值号（=）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。 有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。 值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。 12345678int num = 10;int &amp;b = num; //正确int &amp;c = 10; //错误，不能引用右值const int &amp;c = 10;//允许常量左值引用右值，但是常量左值引用就不能对引用值进行修改了//右值引用可以修改int &amp;&amp; a = 10;a = 100;cout &lt;&lt; a &lt;&lt; endl;//输出100 这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。 关于std:move12345678910111213int a = 5; // a是个左值int &amp;ref_a_left = a; // 左值引用指向左值int &amp;&amp;ref_a_right = std::move(a); // 通过std::move将左值转化为右值，可以被右值引用指向cout &lt;&lt; a; // 打印结果：5//右值引用的本质int &amp;&amp;ref_a = 5;ref_a = 6; //等同于以下代码： int temp = 5;int &amp;&amp;ref_a = std::move(temp);ref_a = 6; 但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值，让右值引用可以指向左值。其实现等同于一个类型转换 从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。 应用场景右值引用和std::move被广泛用于在STL和自定义类中实现移动语义，避免拷贝，从而提升程序性能。 在没有右值引用之前，一个简单的数组类通常实现如下，有构造函数、拷贝构造函数、赋值运算符重载、析构函数等。深拷贝/浅拷贝在此不做讲解。123456Array(Array&amp; temp_array, bool move) &#123; data_ = temp_array.data_; size_ = temp_array.size_; // 为防止temp_array析构时delete data，提前置空其data_ temp_array.data_ = nullptr;&#125;参数类型Array&amp; temp_array是一个非常量的引用。这意味着该引用只能绑定到非常量的对象，即只能传递非常量的Array对象作为参数。然而，在实际应用中，常常需要传递一个常量的Array对象作为参数进行复制构造。例如，当你传递一个临时对象或常量对象时，这些对象不能被非常量引用所绑定，因此无法调用上述的复制构造函数。123456789101112131415161718192021222324252627class Array &#123;public: ...... // 优雅 Array(Array&amp;&amp; temp_array) &#123; data_ = temp_array.data_; size_ = temp_array.size_; // 为防止temp_array析构时delete data，提前置空其data_ temp_array.data_ = nullptr; &#125; public: int *data_; int size_;&#125;;// 例1：Array用法int main()&#123; Array a; // 做一些操作 ..... // 左值a，用std::move转化为右值 Array b(std::move(a));&#125;例2：std::vector和std::string的实际例子12345678910111213141516int main() &#123; std::string str1 = &quot;aacasxs&quot;; std::vector&lt;std::string&gt; vec; vec.push_back(str1); // 传统方法，copy vec.push_back(std::move(str1)); // 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串 vec.emplace_back(std::move(str1)); // emplace_back效果相同，str1会失去原有值 vec.emplace_back(&quot;axcsddcas&quot;); // 当然可以直接接右值&#125; // std::vector方法定义void push_back (const value_type&amp; val);void push_back (value_type&amp;&amp; val); void emplace_back (Args&amp;&amp;... args);//emplace_back通过右值引用，避免了拷贝emplace_back和push_back都是向容器的末尾添加元素的方法，但它们在实现和使用上有一些区别。 参数类型： emplace_back接受可变数量的参数作为构造函数的参数，用于在容器的末尾直接构造一个新元素。，如 people.emplace_back(“John”, 25); push_back接受一个已存在的对象作为参数，并将该对象的副本（或移动语义）插入到容器的末尾。 构造方式： emplace_back在容器的末尾直接就地构造一个新元素，避免了额外的拷贝或移动操作。 push_back要求对象已经存在，因此需要通过拷贝构造函数或移动构造函数创建一个新的对象，然后将其插入到容器的末尾。 性能： emplace_back通常比push_back更高效，因为它直接在容器中就地构造新元素，减少了额外的拷贝或移动操作。 push_back需要先创建一个对象，然后再插入到容器中，可能会涉及对象的拷贝构造或移动构造，因此在性能上可能略逊于emplace_back。 综上所述，如果你想直接在容器的末尾构造一个新元素，并且不希望进行额外的拷贝或移动操作，推荐使用emplace_back。如果你已经有一个已存在的对象，并希望将其插入到容器的末尾，可以使用push_back。 因此，可移动对象需要拷贝且被拷贝者之后不再被需要的场景，建议使用std::move触发移动语义，提升性能123456789moveable_objecta = moveable_objectb; 改为： moveable_objecta = std::move(moveable_objectb);//C++智能指针std::unique_ptr&lt;A&gt; ptr_a = std::make_unique&lt;A&gt;();std::unique_ptr&lt;A&gt; ptr_b = std::move(ptr_a); // unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型std::unique_ptr&lt;A&gt; ptr_b = ptr_a; // 编译不通过std::move本身只做类型转换，对性能无影响。 我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。 关于完美转发12345678910111213141516171819202122232425template&lt;typename T&gt;void print(T &amp; t)&#123; std::cout &lt;&lt; &quot;Lvalue ref&quot; &lt;&lt; std::endl;&#125;template&lt;typename T&gt;void print(T &amp;&amp; t)&#123; std::cout &lt;&lt; &quot;Rvalue ref&quot; &lt;&lt; std::endl;&#125;template&lt;typename T&gt;void testForward(T &amp;&amp; v)&#123; print(v);//v此时已经是个左值了,永远调用左值版本的print print(std::forward&lt;T&gt;(v)); //本文的重点 print(std::move(v)); //永远调用右值版本的print std::cout &lt;&lt; &quot;======================&quot; &lt;&lt; std::endl;&#125;int main(int argc, char * argv[])&#123; int x = 1; testForward(x); //实参为左值 testForward(std::move(x)); //实参为右值&#125; 运行结果Lvalue refLvalue ref //完美转发后为左值 Rvalue refLvalue refRvalue ref //完美转发后为右值 Rvalue ref除了第二行的print(std::forward(v)); 会根据左右值调用外，一三行的函数都是只能调用左或者右可惜的是，在testForward中，虽然参数v是右值类型的，但此时v在内存中已经有了位置，所以v其实是个左值！（请仔细阅读这段话，保证你理解了）参考：https://zhuanlan.zhihu.com/p/335994370 作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值。 这同样也符合第一章对左值，右值的判定方式：其实引用和普通变量是一样的，int &amp;&amp;ref = std::move(a)和 int a = 5没有什么区别，等号左边就是左值，右边就是右值。 完美转发，参考：https://zhuanlan.zhihu.com/p/369203981 主要是右值引用可以避免一次拷贝构造，所以在线程池添加任务的时候，通过了右值引用的方式，同时加上完美转发12345void add(int a, int b); // 定义一个加法函数ThreadPool pool(8, 200); // 创建线程池pool.append(std::bind(add, 1, 2)); // 向线程池中添加“任务”threadpool_-&gt;AddTask(std::bind(&amp;WebServer::OnRead_, this, client)); //实际代码中调用 一个进程可以创建多少线程32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制。 /proc/sys/kernel/threads-max，表示系统支持的最大线程数，默认值是 14553；/proc/sys/kernel/pid_max，表示系统全局的 PID 号数值的限制，每一个进程或线程都有 ID，ID 的值超过这个数，进程或线程就会创建失败，默认值是 32768；/proc/sys/vm/max_map_count，表示限制一个进程可以拥有的VMA(虚拟内存区域)的数量，具体什么意思我也没搞清楚，反正如果它的值很小，也会导致创建线程失败，默认值是 65530。 echo 99999 &gt; /proc/sys/kernel/threads-maxecho “Hello, world!” &gt; output.txt ，表示输出或追加到文件 ulimit -a可以查看进程创建线程时默认分配的栈空间大小，可以通过，如ulimit -s 512将数值调整为512k 上下文切换，内核态和用户态切换的时候也要发生CPU 上下文切换就是先把前一个任务的CPU 上下文（CPU 寄存器和程序计数器保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。 系统内核会存储保持下来的上下文信息，当此任务再次被分配给 CPU 运行时，CPU 会重新加载这些上下文，这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。 上面说到所谓的「任务」，主要包含进程、线程和中断。所以，可以根据任务的不同，把 CPU 上下文切换分成：进程上下文切换、线程上下文切换和中断上下文切换。 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据； 零拷贝零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及CPU拷贝的次数。零拷贝实现有多种方式，分别是 mmap+write，两个不同的虚拟内存地址可以指向同一物理地址空间，所以将内核空间和用户空间指向同一物理地址 sendfile，内核态完成拷贝，不走用户态，从内核缓冲区直接拷贝至socket缓冲区，然后走网卡发送 带有DMA收集拷贝功能的sendfile，sendfile的升级，跳过socket缓冲区，直接发网卡DMA，英文全称是Direct Memory Access，即直接内存访问。DMA本质上是一块主板上独立的芯片，允许外设设备和内存存储器之间直接进行IO数据传输，其过程不需要CPU的参与。算术运算前置++和后置++的区别：1234567int n = 5,m = 10;int a,b,c,d;a = n++;//后置++b = m--;c = ++n;//前置++d = --m;cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;/*输出结果为5，10，7，8。首先对于后置++，可以看到对于a和b是先进行了赋值操作，再进行后置++。执行后a=15,b=10,n=6,m=9。对于前置++，首先进行前置++，再进行赋值操作*/ 后置++的优先级&gt;前置++的优先级&gt;乘和除的优先级&gt;…&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，！=&gt;赋值运算，优先级和上述性质无关。用优先性解释上述现象有矛盾，所以，可以按照这个记吧 强制类型转换：12int (a)(int) a //两种方式均可 其优先级高于乘数法，和逻辑非，按位取反同级。因此 double(n)/2 是先将n转换为double再做除法 逻辑运算 双目运算：&amp;&amp; ||单目运算：! 逻辑！负号-&gt;乘除运算等&gt;&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，!=&gt;逻辑&amp;&amp;&gt;逻辑||。为了避免优先级的混乱，多使用圆括号 位运算 &amp;，|，^(异或)，&lt;&lt;左移,&gt;&gt;右移,~(按位取反) 按位取反的时候要考虑到数据的字节数，对于一个正数，前面所有的0都要变成1,左移一位相当于2，右移相当于除2。复合位运算(&amp;=，|=等)的结合顺序是*从右向左，除此之外还有(!,~,+,-,前置++/—)也是从右向左结合，比较特殊。 特殊符号 “=”赋值运算，其结合顺序是从右向左且其左侧(lvalue)不能是表达式，只能是变量，数组等 ?:,比如y=(x&gt;=1?1:0)即可表达一个分段函数:y=1(x&gt;=1),y=0(x&lt;1) 逗号表达式，依次计算每个表达式的值，整体等于最后一个逗号后式子的值，如y=(1,2,3+5),则y=8 算法优先级顺序 数据类型转换原则 整型变量和字符变量其在内存中存放的都是整数，整数，存放的是二进制格式，字符，存放的是ASCII码值(","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"代码随想录","slug":"代码随想录","date":"2023-05-07T16:00:00.000Z","updated":"2023-05-23T06:45:40.939Z","comments":true,"path":"2023/05/08/代码随想录/","link":"","permalink":"http://example.com/2023/05/08/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/","excerpt":"","text":"第一章 数组二分法怎么会有人不知道for循环的执行顺序啊,只要执行完函数体里的内容就会执行increment操作，然后再判断condition！！！ 1234for ( init; condition; increment )&#123; statement(s);&#125; 啊，我怎么会什么都没记录啊，服了前K个高频元素题目链接 优先队列，for循环遍历map，pair操作 遍历map：方式1遍历出的元素是个迭代器，所以要用first和second来分别指向键值和字典值，所以要用箭头方式2auto将被推导为std::map::value_type，所以可以直接用. 1234567891011121314151617// 方式一、迭代器cout &lt;&lt; &quot;方式一、迭代器&quot; &lt;&lt; endl;for (auto it = mp.begin(); it != mp.end(); it++) &#123; cout &lt;&lt; it -&gt; first &lt;&lt; &quot; &quot; &lt;&lt; it -&gt; second &lt;&lt; endl;&#125;// 方式二、range for C++ 11版本及以上cout &lt;&lt; &quot;\\n方法二、 range for&quot; &lt;&lt; endl;for (auto it : mp) &#123; cout &lt;&lt; it.first &lt;&lt; &quot; &quot; &lt;&lt; it.second &lt;&lt; endl;&#125;// 方法三、 C++ 17版本及以上cout &lt;&lt; &quot;\\n方法三&quot; &lt;&lt; endl;for (auto [key, val] : mp) &#123; cout &lt;&lt; key &lt;&lt; &quot; &quot; &lt;&lt; val &lt;&lt; endl;&#125; 二叉树C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。 multimap 在std::multimap中，没有像std::map那样通过键直接访问元素的方式，即没有类似map[键值]的用法。 在std::multimap中，由于一个键可以对应多个值，直接使用map[键值]会产生歧义，无法确定应该返回哪个值。因此，如果你需要按照键值直接访问元素，你可以使用equal_range()函数或者find()函数进行查找操作，然后遍历返回的迭代器范围来处理具有相同键的元素。 以下是使用find()函数进行查找的示例1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;map&gt;int main() &#123; std::multimap&lt;int, std::string&gt; myMultimap; myMultimap.insert(std::make_pair(1, &quot;one&quot;)); myMultimap.insert(std::make_pair(2, &quot;two&quot;)); myMultimap.insert(std::make_pair(3, &quot;three&quot;)); myMultimap.insert(std::make_pair(2, &quot;second&quot;)); // 查找键为2的元素 auto it = myMultimap.find(2); // 如果找到了，遍历具有相同键的元素 if (it != myMultimap.end()) &#123; int key = it-&gt;first; std::string value = it-&gt;second; std::cout &lt;&lt; &quot;Key: &quot; &lt;&lt; key &lt;&lt; &quot;, Value: &quot; &lt;&lt; value &lt;&lt; std::endl; // 继续遍历具有相同键的元素 while (++it != myMultimap.end() &amp;&amp; it-&gt;first == key) &#123; value = it-&gt;second; std::cout &lt;&lt; &quot;Key: &quot; &lt;&lt; key &lt;&lt; &quot;, Value: &quot; &lt;&lt; value &lt;&lt; std::endl; &#125; &#125; return 0;&#125; 迭代法遍历树前序和后序都好说，主要就是入栈和出栈的顺序不一致，所以如果前序，希望中左右，那么入栈需要先如右节点，这样出栈就是先出左节点然后后序，就是先做成中右左，然后整体reverse前序和后序的话，因为一开始就是访问并且处理根节点，所以先入栈12345if (root == NULL) return result;//记得判断 st.push(root); while (!st.empty()) &#123;//判断条件只需要判断是否为空//判断逻辑 &#125;但是中序，第一个打印的是最左边的节点，所以不能先入栈,出栈之后意味着要进行处理了，但是第一个并不处理根节点1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode*&gt; st; TreeNode* cur = root; while (cur != NULL || !st.empty()) &#123; if (cur != NULL) &#123; // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 &#125; else &#123; cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据） st.pop(); result.push_back(cur-&gt;val); // 中 cur = cur-&gt;right; // 右 &#125; &#125; return result; &#125;&#125;;最重要的是：pop函数没有返回值，所以需要用top","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"操作系统","slug":"OS","date":"2023-02-26T16:00:00.000Z","updated":"2023-07-12T07:42:37.007Z","comments":true,"path":"2023/02/27/OS/","link":"","permalink":"http://example.com/2023/02/27/OS/","excerpt":"","text":"问题1：进程线程进程我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个运行中的程序，就被称为「进程」（Process），代码是静态的。 并行与并发：但在 1 秒钟期间，它可能会运行多个进程，这样就产生并行的错觉，实际上这是并发。并行依赖多CPU进程的状态：一个进程的活动期间至少具备三种基本状态，即运行状态、就绪状态、阻塞状态。为了防止阻塞进程太多，占用内存,在虚拟内存管理的操作系统中，通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存。这个没有占用实际的物理内存空间的状态就是挂起状态。这跟阻塞状态是不一样，阻塞状态是等待某个事件的返回。 PCB是进程存在的唯一标识，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。上下文切换:CPU 寄存器是 CPU 内部一个容量小，但是速度极快的内存（缓存）程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。所以说，CPU寄存器和程序计数是CPU在运行任何任务前，所必须依赖的环境，这些环境就叫做 CPU 上下文。进程的上下文开销是很关键的，我们希望它的开销越小越好，这样可以使得进程可以把更多时间花费在执行程序上，而不是耗费在上下文切换。 发生进程上下文切换有哪些场景？ 为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行； 进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行； 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度； 当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行； 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序； 线程 为什么需要线程？ 对于播放视频的进程，需要读取文件，解压文件，播放文件等多个工作 如果采用单进程的方式，各个函数之间不是并发执行，影响资源的使用效率； 如果采用多进程的方式，维护进程的系统开销较大，如创建进程时，分配资源、建立 PCB；终止进程时，回收资源、撤销 PCB；进程切换时，保存当前进程的状态信息； 为此，引入线程( Thread )，线程之间可以并发运行且共享相同的地址空间。 常见面试题： 进程和线程共享的资源 同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。栈是因为不同的线程会有自己的局部变量，寄存器是因为不同的线程在进行上下文切换的时候，需要程序计数器记住执行到哪条指令了，所以线程独享了寄存器和栈 进程和线程的区别 调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。 并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。 系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。 线程是调度的基本单位，而进程则是资源拥有的基本单位。 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃 一个进程可以创建多少个线程？ 这个问题跟两个东西有关系： 进程的虚拟内存空间上限，因为创建一个线程，操作系统需要为其分配一个栈空间，如果线程数量越多，所需的栈空间就要越大，那么虚拟内存就会占用的越多。 系统参数限制，虽然 Linux 并没有内核参数来控制单个进程创建的最大线程个数，但是有系统级别的参数来控制整个系统的最大线程个数。 32 位系统，用户态的虚拟空间只有 3G，如果创建线程时分配的栈空间是 10M，那么一个进程最多只能创建 300 个左右的线程。64 位系统，用户态的虚拟空间大到有 128T，理论上不会受虚拟内存大小的限制，而会受系统的参数或性能限制，比如： 表示系统支持的最大线程数，默认值是 14553； 表示系统全局的 PID 号数值的限制，每个进程或线程都有PID号的 进程调度算法 先来先服务调度算法，适用于 CPU 繁忙型作业的系统，而不适用于 I/O 繁忙型作业的系统，短作业等半天最短作业优先调度算法，长作业被饿死高响应比优先调度算法，无法实现，应为需要服务时间未知时间片轮转调度算法，最公平，时间设置要合理，太短上下文切换浪费资源，太长退化为先来先服务最高优先级调度算法，低优先级被饿死多级反馈队列调度算法，最合适 其中最高优先级：进程的优先级可以分为，静态优先级或动态优先级： 静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化； 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。该算法也有两种处理优先级高的方法，非抢占式和抢占式： 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。 抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。 进程间通信方式 由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。 管道： 无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。 有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。 消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。 信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。 信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。 补充：内存映射，mmap函数和unmap函数，将物理位置映射到内存中,有两种方式，一种是匿名映射，即直接在内存中开辟一块区域，用于通信，但只能用于父子进程，另一种是有名映射，将一个磁盘文件映射到内存中，然后多个进程对同一磁盘文件进行修改实现通信，所以需要内存和磁盘文件进行读写，即有IO和数据拷贝等工作，所以效率不如共享内存高，每个进程在自己的虚拟地址空间中有一个独立的内存。 共享内存和内存映射的区别 共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 共享内存效率更高：共享内存所有的进程操作的是同一块共享内存。内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 数据安全：进程突然退出:共享内存还存在,内存映射区消失运行进程的电脑死机，宕机了:数据存在在共享内存中，没有了,内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 生命周期 内存映射区：进程退出，内存映射区销毁共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机如果一个进程退出，会自动和共享内存进行取消关联。 线程通信间的方式呢？ 同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步： 互斥的方式，可保证任意时刻只有一个线程访问共享资源；同步的方式，可保证线程 A 应在线程 B 之前执行； 关注作者问题2 内存相关 动态分区方法 就是当有一个新进程到来的时候，决定在内存中的空闲分区中哪一块分给该进程，内存中的空闲块是按链表形式存储的（也有的是表的形式） 首次适应算法，从低地址开始查找，第一个大小满足的空闲分区就分出去，（最优也最简单） 最佳适应算法，遍历所有空闲分区，找到满足要求且最小的分区，这样的好处很明显就是为了保留大的分区供大程序用，但是会产生很多特别小且没有办法利用的内部碎片，而且算法开销大 最坏适应算法，与最佳相反，是遍历后取最大的分区给进程，这样避免了特别小的碎片，但是同样就没大空闲区了，而且算法开销也大，因为要遍历，要排序 邻近适应算法，和第一种比，是每次遍历是从上一次的分区开始，而首次适应是从低地址开始，首次适应的话高地址的大片区域会得到保留，但是临近适应的话，高地址的大片分区也可能被分给小进程，就很废 虚拟内存作用 第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。这个其实就是体现了虚拟技术的空间虚拟，时间虚拟指的是多个进程的并发，轮流用时间片，宏观上就好像都在同时运行第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。 分段和分页两种方式对比 分段的两个问题：第一个就是内存碎片的问题。分段的话，每个程序的段其实很大的，有可能会空出来两个128MB,但是由于分段是需要连续的空间，导致256MB的程序装不进来，也就是产生了外部碎片，分段只会有外部碎片，内部没有，但是分页因为固定了每次只分一个页的大小，所以可能有内部碎片第二个就是内存交换的效率低的问题，解决办法就是交换内存，但是段很大的时候效率就很低 分页的话，缺点可能就是页表比较占位置，可以通过多级页表解决 所以现在好多都是两者结合，段页式内存管理实现的方式：先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；这样，地址结构就由段号、段内页号和页内位移三部分组成。 虚拟地址和物理地址如何转换 在分页机制下，虚拟地址分为两部分，页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址，具体步骤如下： 把虚拟内存地址，切分成页号和偏移量； 根据页号，从页表里面，查询对应的物理页号； 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。 在分段机制下，依靠段选择因子和段内偏移量： 段选择子就保存在段寄存器里面。段选择子里面最重要的是段号，用作段表的索引。段表里面保存的是这个段的基地址、段的界限和特权等级等。虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。知道了虚拟地址是通过段表与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址 问题3 中断和异常 外中断和异常有什么区别？ 外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。 而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等 硬件结构CPU是如何执行程序的定义计算机基本结构为 5 个部分，分别是运算器、控制器、存储器、输入设备、输出设备这 5 个部分也被称为冯诺依曼模型。 存储数据的基本单位是字节（byte），1 字节等于 8 位（8 bit）。每一个字节都对应一个内存地址。 CPU 想要操作「内存地址」就需要「地址总线」：如果地址总线只有 1 条，那每次只能表示 「0 或 1」这两种地址，想要 CPU 操作 4G 大的内存，那么就需要 32 条地址总线，表示地址有32位，因为 2 ^ 32 = 4G 程序的执行过程 第一步，CPU 读取「程序计数器」的值，这个值是指令的内存地址，然后 CPU 的「控制单元」操作「地址总线」指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过「数据总线」将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到「指令寄存器」。第二步，「程序计数器」的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此「程序计数器」的值会自增 4；第三步，CPU 分析「指令寄存器」中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给「逻辑运算单元」运算；如果是存储类型的指令，则交由「控制单元」执行； CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令 指令执行过程 CPU 通过程序计数器读取对应内存地址的指令，这个部分称为 Fetch（取得指令）；CPU 对指令进行解码，这个部分称为 Decode（指令译码）；CPU 执行指令，这个部分称为 Execution（执行指令）；CPU 将计算结果存回寄存器或者将寄存器的值存入内存，这个部分称为 Store（数据回写）；上面这 4 个阶段，我们称为指令周期（Instrution Cycle），CPU 的工作就是一个周期接着一个周期，周而复始。 你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？ 64 位和 32 位软件，实际上代表指令是 64 位还是 32 位的：(指令中的每位也都表示了特殊的含义，比如指令类型，操作码等)如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令；操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上。 总之，硬件的 64 位和 32 位指的是 CPU 的位宽（指每次可以读多少位的数据，32位机处理64位数字相加，就要分低32位和高32位计算，但是没有这么大的数的运算的时候，64位机也不比32位机快），软件的 64 位和 32 位指的是指令的位宽。 64 位相比 32 位 CPU 的优势在哪吗？64 位 CPU 的计算性能一定比 32 位 CPU 高很多吗？ 64 位相比 32 位 CPU 的优势主要体现在两个方面： 64 位 CPU 可以一次计算超过 32 位的数字，而 32 位 CPU 如果要计算超过 32 位的数字，要分多步骤进行计算，效率就没那么高，但是大部分应用程序很少会计算那么大的数字，所以只有运算大数字的时候，64 位 CPU 的优势才能体现出来，否则和 32 位 CPU 的计算性能相差不大。通常来说 64 位 CPU 的地址总线是 48 位，而 32 位 CPU 的地址总线是 32 位，所以 64 位 CPU 可以寻址更大的物理内存空间。如果一个 32 位 CPU 的地址总线是 32 位，那么该 CPU 最大寻址能力是 4G，即使你加了 8G 大小的物理内存，也还是只能寻址到 4G 大小的地址，而如果一个 64 位 CPU 的地址总线是 48 位，那么该 CPU 最大寻址能力是 2^48，远超于 32 位 CPU 最大寻址能力。 2.2存储器 CPU（寄存器，L1/L2/L3Cache） CPU 比喻成我们的大脑，大脑正在思考的东西，就好比 CPU 中的寄存器，处理速度是最快的，我们大脑中的记忆，就好比 CPU Cache，中文称为 CPU 高速缓存，处理速度相比寄存器慢了一点，但是能存储的数据也稍微多了一些。 CPU Cache 用的是一种叫 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片。SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。，一个 bit 的数据，通常需要 6 个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。 内存 内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 DRAM （Dynamic Random Access Memory，动态随机存取存储器） 的芯片。只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。 SSD/HDD硬盘SSD（Solid-state disk） 就是我们常说的固体硬盘，结构和内存类似，但是它相比内存的优点是断电后数据还是存在的，而内存、寄存器、高速缓存断电后数据都会丢失。内存的读写速度比 SSD 大概快 10~1000 倍。 机械硬盘（Hard Disk Drive, HDD），它是通过物理读写的方式来访问数据的，因此它访问速度是非常慢的，它的速度比内存慢 10W 倍左右。 2.3 CPU跑的更快写出让 CPU 跑得更快的代码，就需要写出缓存命中率高的代码，CPU L1 Cache 分为数据缓存和指令缓存，因而需要分别提高它们的缓存命中率： 对于数据缓存，我们在遍历数据的时候，应该按照内存布局的顺序操作，这是因为 CPU Cache 是根据 CPU Cache Line 批量操作数据的，所以顺序地操作连续内存数据时，性能能得到有效的提升； 对于指令缓存，有规律的条件分支语句能够让 CPU 的分支预测器发挥作用，进一步提高执行的效率； 对于多核 CPU 系统，线程可能在不同 CPU 核心来回切换，这样各个核心的缓存命中率就会受到影响，于是要想提高线程的缓存命中率，可以考虑把线程绑定 CPU 到某一个 CPU 核心。 2.4 何时把cache写会内存 写直达保持内存与 Cache 一致性最简单的方式是，把数据同时写入内存和 Cache 中，这种方法称为写直达（Write Through）。每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。 写回写回机制中，当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中， 在把数据写入到 Cache 的时候，只有在缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。 缓存一致性问题，多核CPU，每个CPU都有自己的cache 某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为写传播（Write Propagation）； 某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为事务的串行化（Transaction Serialization）。比如两块CPU修改一个变量，按第一条传播的时候，必须有先后顺序，可以依赖锁防止这种情况 写传播的原则就是当某个 CPU 核心更新了 Cache 中的数据，要把该事件广播通知到其他核心。最常见实现的方式是总线嗅探（Bus Snooping）。 总线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串行化。 于是，有一个协议基于总线嗅探机制实现了事务串行化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性。 2.6 中断所以，中断处理程序的上部分和下半部可以理解为： 上半部，对应硬中断，由硬件触发中断，用来快速处理中断； 下半部，对应软中断，由内核触发中断，用来异步处理上半部未完成的工作； 软中断的出现是因为，如果中断处理时间过长，在处理期间，可能无法处理新来的中断，所以分了两个半部，上半部只响应，下半部完成具体的中断业务逻辑硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个软中断内核线程，名字通常为「ksoftirqd/CPU 编号」，比如 0 号 CPU 对应的软中断内核线程的名字是 ksoftirqd/0 3.1 操作系统结构 操作系统功能 进程调度 内存管理 硬件通信 系统调用 4.1 内存分段 内存分段 分段分为堆，栈，代码区和数据段不会产生内部碎片，因为每次都是要多少分配多少但是会产生外部碎片，因为每次分的时候，要看哪一片连续区域大小够才分，所以会有很多外部碎片，如果外部碎片太多导致无法为新进程分配时，就需要内存交换，即先写入硬盘再移位置，如果文件很大，效率就很低。 内存分页 多级页表解决4MB（每个页表项4字节，4GB = 4KB2^20,需要2^20个页,那么4字节2^20 = 4MB，，2^10 = 1024所以2^20 = M）主要是一个二级页表能小很多，把2^20个一级页分成1024个2级页，那么只需要4KB就存下了，然后到时候需要一级页表的时候从硬盘中读就好了 4KB（一级页表） + 20% * 4MB（二级页表）= 0.804MB，这对比单级页表的 4MB 是不是一个巨大的节约序最常访问的页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer）通常称为页表缓存、转址旁路缓存、快表 虚拟内存的用处 内存更大：第一，虚拟内存可以使得进程对运行内存超过物理内存大小，因为程序运行符合局部性原理，CPU 访问内存会有很明显的重复访问的倾向性，对于那些没有被经常使用到的内存，我们可以把它换出到物理内存之外，比如硬盘上的 swap 区域。 进程间隔离： 第二，由于每个进程都有自己的页表，所以每个进程的虚拟内存空间就是相互独立的。进程也没有办法访问其他进程的页表，所以这些页表是私有的，这就解决了多进程之间地址冲突的问题。 读写权限： 第三，页表里的页表项中除了物理地址之外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。 关注作者80386是32位处理器，物理内存地址空间2^32=4G字节BIOS:基本I/O处理系统DISK：存放OSBootloader 6 调度算法进程调度算法也称 CPU 调度算法，毕竟进程是由 CPU 调度的。当 CPU 空闲时，操作系统就选择内存中的某个「就绪状态」的进程，并给其分配 CPU。 什么时候会发生 CPU 调度呢？通常有以下情况： 当进程从运行状态转到等待状态；当进程从运行状态转到就绪状态；当进程从等待状态转到就绪状态；当进程从运行状态转到终止状态；其中发生在 1 和 4 两种情况下的调度称为「非抢占式调度」，2 和 3 两种情况下发生的调度称为「抢占式调度」。非抢占式的意思就是，当进程正在运行时，它就会一直运行，直到该进程完成或发生某个事件而被阻塞时，才会把 CPU 让给其他进程。而抢占式调度，顾名思义就是进程正在运行的时，可以被打断，使其把 CPU 让给其他进程。那抢占的原则一般有三种，分别是时间片原则、优先权原则、短作业优先原则。 页面置换算法 先进先出， 最佳页面置换算法（OPT），未来最长时间不会被使用，理想算法先进先出置换算法（FIFO），没有利用任何额外信息，效果一般，belady现象最近最久未使用的置换算法（LRU），需要在内存中维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。每次都要遍历一遍链表，访问时也要遍历找到该页，再移到链表头，开销大时钟页面置换算法（Lock），还有改进式，优先换出没被修改过的，减少IO写入磁盘次数最不常用置换算法（LFU），LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。 7 文件系统Linux 文件系统会为每个文件分配两个数据结构：索引节点（index node）和目录项（directory entry），它们主要用来记录文件的元信息和目录层次结构。 索引节点，也就是 inode，用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、数据在磁盘的位置等等。索引节点是文件的唯一标识，它们之间一一对应，也同样都会被存储在硬盘中，所以索引节点同样占用磁盘空间。 目录项，也就是 dentry，用来记录文件的名字、索引节点指针以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存。 由于索引节点唯一标识一个文件，而目录项记录着文件的名字，所以目录项和索引节点的关系是多对一，也就是说，一个文件可以有多个别名。比如，硬链接的实现就是多个目录项中的索引节点指向同一个文件。 注意，目录也是文件，也是用索引节点唯一标识，和普通文件不同的是，普通文件在磁盘里面保存的是文件数据，而目录文件在磁盘里面保存子目录或文件。 目录项和目录是一个东西吗？ 虽然名字很相近，但是它们不是一个东西，目录是个文件，持久化存储在磁盘，而目录项是内核一个数据结构，缓存在内存。 如果查询目录频繁从磁盘读，效率会很低，所以内核会把已经读过的目录用目录项这个数据结构缓存在内存，下次再次读到相同的目录时，只需从内存读就可以，大大提高了文件系统的效率。 注意，目录项这个数据结构不只是表示目录，也是可以表示文件的。 那文件数据是如何存储在磁盘的呢？ 磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，很明显，如果每次读写都以这么小为单位，那这读写的效率会非常低。 所以，文件系统把多个扇区组成了一个逻辑块，每次读写的最小单位就是逻辑块（数据块），Linux 中的逻辑块大小为 4KB，也就是一次性读写 8 个扇区，这将大大提高了磁盘的读写的效率。 虚拟文件系统 文件系统的种类众多，而操作系统希望对用户提供一个统一的接口，于是在用户层与文件系统层引入了中间层，这个中间层就称为虚拟文件系统（Virtual File System，VFS）。 我们打开了一个文件后，操作系统会跟踪进程打开的所有文件，所谓的跟踪呢，就是操作系统为每个进程维护一个打开文件表，文件表里的每一项代表「文件描述符」，所以说文件描述符是打开文件的标识。 操作系统在打开文件表中维护着打开文件的状态和信息： 文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的； 文件打开计数器：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件，该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目； 文件磁盘位置：绝大多数文件操作都要求系统修改文件数据，该信息保存在内存中，以免每个操作都从磁盘中读取； 访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等），该信息保存在进程的打开文件表中，以便操作系统能允许或拒绝之后的 I/O 请求； 文件系统的基本操作单位是数据块 当用户进程从文件读取 1 个字节大小的数据时，文件系统则需要获取字节所在的数据块，再返回数据块对应的用户进程所需的数据部分。当用户进程把 1 个字节大小的数据写进文件时，文件系统则找到需要写入数据的数据块的位置，然后修改数据块中对应的部分，最后再把数据块写回磁盘。 文件的存储 文件的数据是要存储在硬盘上面的，数据在磁盘上的存放方式，就像程序在内存中存放的方式那样，有以下两种： 连续空间存放方式读写效率高，但要求文件头里需要指定「起始块的位置」和「长度」，有了这两个信息就可以很好的表示文件存放方式是一块连续的磁盘空间但是有「磁盘空间碎片」和「文件长度不易扩展」的缺陷 非连续空间存放方式分为「链表方式」和「索引方式」隐式链表方式，就是文件分成了几个块，每个块包含了下一块的指针，缺点就是只能按照链表顺序，依次读数据块，同时指针消耗了资源，同时如果指针丢失，会导致文件损坏显式链接,它指把用于链接文件各数据块的指针，显式地存放在内存的一张链接表中，查询在内存中进行更快，但是这个链接表不适合大磁盘 空闲空间管理（有新文件存在哪） 空闲表法，用于上述连续存储，表中记录了空闲连续段的起始位置和大小 空闲链表法，用于非连续存储，空闲空间的链表彼此相连空闲表法和空闲链表法都不适合用于大型文件系统，因为这会使空闲表或空闲链表太大。 位图法用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当值为 0 时，表示对应的盘块空闲，值为 1 时，表示对应的盘块已分配。它形式如下：11111110011111110001110110111111100111 ... 在 Linux 文件系统就采用了位图的方式来管理空闲空间，不仅用于数据空闲块的管理，还用于 inode 空闲块的管理，因为 inode 也是存储在磁盘的，自然也要有对其管理。 软硬链接有时候我们希望给某个文件取个别名，那么在 Linux 中可以通过硬链接（Hard Link） 和软链接（Symbolic Link） 的方式来实现，它们都是比较特殊的文件，但是实现方式也是不相同的。 硬链接是多个目录项中的「索引节点」指向一个文件，也就是指向同一个 inode，但是 inode 是不可能跨越文件系统的，每个文件系统都有各自的 inode 数据结构和列表，所以硬链接是不可用于跨文件系统的。由于多个目录项都是指向一个 inode，那么只有删除文件的所有硬链接以及源文件时，系统才会彻底删除该文件。 硬链接 软链接相当于重新创建一个文件，这个文件有独立的 inode，但是这个文件的内容是另外一个文件的路径，所以访问软链接的时候，实际上相当于访问到了另外一个文件，所以软链接是可以跨文件系统的，甚至目标文件被删除了，链接文件还是在的，只不过指向的文件找不到了而已。 软链接 文件 I/O文件的读写方式各有千秋，对于文件的 I/O 分类也非常多，常见的有 缓冲与非缓冲 I/O直接与非直接 I/O阻塞与非阻塞 I/O VS 同步与异步 I/O接下来，分别对这些分类讨论讨论。 缓冲与非缓冲 I/O文件操作的标准库是可以实现数据的缓存，那么根据「是否利用标准库缓冲」，可以把文件 I/O 分为缓冲 I/O 和非缓冲 I/O： 缓冲 I/O，利用的是标准库的缓存实现文件的加速访问，而标准库再通过系统调用访问文件。非缓冲 I/O，直接通过系统调用访问文件，不经过标准库缓存。这里所说的「缓冲」特指标准库内部实现的缓冲。 比方说，很多程序遇到换行时才真正输出，而换行前的内容，其实就是被标准库暂时缓存了起来，这样做的目的是，减少系统调用的次数，毕竟系统调用是有 CPU 上下文切换的开销的。 直接与非直接 I/O我们都知道磁盘 I/O 是非常慢的，所以 Linux 内核为了减少磁盘 I/O 次数，在系统调用后，会把用户数据拷贝到内核中缓存起来，这个内核缓存空间也就是「页缓存」，只有当缓存满足某些条件的时候，才发起磁盘 I/O 的请求。 那么，根据是「否利用操作系统的缓存」，可以把文件 I/O 分为直接 I/O 与非直接 I/O： 直接 I/O，不会发生内核缓存和用户程序之间数据复制，而是直接经过文件系统访问磁盘。非直接 I/O，读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘。如果你在使用文件操作类的系统调用函数时，指定了 O_DIRECT 标志，则表示使用直接 I/O。如果没有设置过，默认使用的是非直接 I/O。","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"Linux项目补充和扩展","slug":"牛客项目补充","date":"2023-01-26T16:00:00.000Z","updated":"2023-03-09T07:24:18.486Z","comments":true,"path":"2023/01/27/牛客项目补充/","link":"","permalink":"http://example.com/2023/01/27/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE%E8%A1%A5%E5%85%85/","excerpt":"","text":"主从状态机的逻辑问题先来看一下要处理的两种报文格式: GET请求：空行之后没有数据了 GET /signin?next=%2F HTTP/2\\r\\nHost: www.zhihu.com\\r\\nUser-Agent: Mozilla/5.0\\r\\nAccept: /\\r\\nAccept-Language: zh-CN\\r\\nAccept-Encoding: gzip, deflate\\r\\nConnection: keep-alive\\r\\nUpgrade-Insecure-Requests: 1\\r\\nCache-Control: max-age=0\\r\\nTE: trailers\\r\\n\\r\\n POST请求:空行之后是请求传送的数据 POST /login HTTP/1.1\\r\\nHost: 127.0.0.1:8888\\r\\nUser-Agent: Mozilla/5.0\\r\\nAccept: /\\r\\nAccept-Language: zh-CN\\r\\nAccept-Encoding: gzip, deflate\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nContent-Length: 29\\r\\nConnection: keep-alive\\r\\n\\r\\nusername=root&amp;password=123456 两者都包含了三部分：请求行，请求头部和请求数据主状态就对应了这三种状态： CHECK_STATE_REQUESTLINE，解析请求行CHECK_STATE_HEADER，解析请求头CHECK_STATE_CONTENT，解析消息体，仅用于解析POST请求 而从状态机只负责处理每一行，即读完一整行的数据（除了POST的请求数据，其他行都是以\\r\\t结尾），并返回这行数据的状态： LINE_OK，完整读取一行LINE_BAD，报文语法有误LINE_OPEN，读取的行不完整 处理过程中会根据情况，返回4种状态（HTTP_CODE），返回之后，这轮读就结束了？： NO_REQUEST 请求不完整，需要继续读取请求报文数据GET_REQUEST 获得了完整的HTTP请求BAD_REQUEST HTTP请求报文有语法错误INTERNAL_ERROR 服务器内部错误，该结果在主状态机逻辑switch的default下，一般不会触发 首先就是看process_read代码，不断的读每一行的数据，switch主状态m_check_state，执行对应的解析函数parse_request_line.parse_headers,parse_content,这些函数在执行的时候，会自动给相应的http_conn中的类成员赋值，如果错误就返回。 判断条件1while((m_check_state==CHECK_STATE_CONTENT &amp;&amp; line_status==LINE_OK)||((line_status=parse_line())==LINE_OK)) 正常情况下，每一行都是\\r\\n结尾，默认（(line_status=parse_line())==LINE_OK)）就可以了但是POST的请求数据，不是以\\r\\n结尾，如果parse_line这些行，状态就不是LINE_OK，这样就进不了循环了，所以这个时候就用主状态判断，是CHECK_STATE_CONTENT就执行，但是解析完就出不来了，其实解析完可以更改一下主状态？作者的做法是，解析完之后更改了line_status但是这样会不会每次都循环判断呢，不懂不过本来也没啥问题，如果是在处理完请求数据后改了主状态，那么此时就又会去执行parse_line函数了，不过找不到\\r\\n还是会变成LINE_OPEN，返回，也没太大的差别，不改了吧，只能想到这层 这里没有再parse_line去解析请求数据，而只是更改了变量line_status NO_REQUEST还是上面的问题，注意的是parse_line是把每行最后的\\r\\n换成\\0了的，但有时候如果没有找到，就说明数据不完整，返回的line_status就是LINE_OPEN，所以会退出上述循环，此时返回的解析结果是NO_REQUEST表示的是请求报文不完整，要继续接收，而不是出错。所以在处理POST请求数据的时候并没有去调用parse_line这个函数，那么肯定一直是LINE_OK 关于获取每行数据parse_line把每行最后的\\r\\n变成\\0123456789101112131415161718m_read_buf[m_checked_idx++]=&#x27;\\0&#x27;;m_read_buf[m_checked_idx++]=&#x27;\\0&#x27;;//也就是说parse_line后，m_checked_idx指向的是下一行数据开始的位置while((m_check_state==CHECK_STATE_CONTENT &amp;&amp; line_status==LINE_OK)||((line_status=parse_line())==LINE_OK))&#123;text=get_line();m_start_line=m_checked_idx;...&#125;//m_start_line是每一个数据行在m_read_buf中的起始位置//m_checked_idx表示从状态机在m_read_buf中读取的位置//getline的实现，char* get_line()&#123; return m_read_buf+m_start_line;&#125; 执行过程是这样的，刚开始我们建立了一个char[]存储请求报文 首先在while中执行parse_line，把第一行的\\r\\n换为\\0 然后get_line从m_read_buf开始读，此时m_start_line=0,读出第一行数据 然后m_start_line = m_checked_idx，即指向第二行开头，第一行处理完后，进循环，再次get_line的时候，就是从第二行开始了，如此循环。 关于缓冲区大小read_once函数中 m_read_idx表示读取到了多少数据，超过大小的时候是直接false的12345678910111213bool http_conn::read_once()&#123; if (m_read_idx &gt;= READ_BUFFER_SIZE) &#123; return false; &#125; int bytes_read = 0; //LT读取数据 if (0 == m_TRIGMode) &#123; bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, 0); m_read_idx += bytes_read; 关于读POST的请求数据m_checked_idx这个参数，在parse_line的时候，是会定位到行末尾的\\n，并指向下一行开始的，但是在读请求数据的时候就没有进行parse_line了，因为数据每行并不以\\r\\n结尾，所以m_checked_idx一直不会变，就是指向请求数据的开始然后m_content_length是已经从请求头部中读到的，这俩相加，就是在整个缓冲区中，POST的数据结束位置的索引，m_read_idx表示读到了多少数据，所以如果大于等于，表示信息都读进来了（上面代码可以看到，如果超过缓冲区大小是会return false的），此时text指向POST信息开始位置，那么找到结束位置置\\0,就可以把信息读给string了.1234567891011http_conn::HTTP_CODE http_conn::parse_content(char *text)&#123; if (m_read_idx &gt;= (m_content_length + m_checked_idx)) &#123; text[m_content_length] = &#x27;\\0&#x27;; //POST请求中最后为输入的用户名和密码 m_string = text; return GET_REQUEST; &#125; return NO_REQUEST;&#125; process_read补充函数stat函数stat函数用于取得指定文件的文件属性，并将文件属性存储在结构体stat里，这里仅对其中用到的成员进行介绍。mmap函数用于将一个文件或其他对象映射到内存，提高文件的访问速度。 再看主线程的关系主线程调用read_once和http_conn::write来完成数据的读取与发送子线程完成报文的解析和响应也就是说，read_once先是把一长串报文写到缓冲区，然后子线程去解析然后，子线程响应报文，并把响应报文通过write写到发送缓冲区 关于h和cpp文件 include 一个文件(无论.h或是.cpp)，仅仅是将文件中的代码复制一份到你的代码之中，头文件（.h）仅在编译过程中的预处理中起到作用。 知道了这个后我们便可以开始进行一些测试了。 因为函数与变量的声明可以进行任意多次，而定义只能有一次。 所以为了防止某些变量被定义多次，所以将定义和声明分离开 fcntl函数根据参数不同用来获取或更改文件属性设置文件类型为非阻塞123456789#include&lt;unistd.h&gt;#include&lt;fcntl.h&gt;int setnonblocking(int fd)&#123; int old_option = fcntl(fd,F_GETFL);//获取文件描述符状态 int new_option = old_option | O_NONBLOCK ; fcntl(fd,F_SETFL,new_option);//设置文件描述符状态 return old_option;&#125;阻塞与非阻塞是文件（文件描述符）的性质，而不是函数的性质 为什么设置为非阻塞由于是高并发的服务器，所以多进程和多线程来分别处理不同的客户端都会造成资源的开销，而且大多数时候，不是所有的客户端都需要进行处理，因此选择采用IO多路复用，用一个进程检测有哪些链接需要处理，再从线程池中进行分配。 RAII机制RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定 线程池线程池是将若干个随时可以执行任务的线程放在“池子”这种容器中，当我们要使用线程的时候，从线程池中取出即可；使用完成后再将线程归还给线程池，以便下次或者其他用户使用。使用线程池技术的最大好处是服务器可以避免因重复的建立和销毁线程带来的开销，从而提高服务器对客户端的响应速度。 EPOLLReactor和Proactor(异步)区别右值引用和完美转发 参考链接：http://c.biancheng.net/view/2334.htmlhttp://c.biancheng.net/view/7868.html除了上述提到的template模板，还使用了C++11的【右值引用】、【完美转发】、【function】以及【信号量】。右值引用和完美转发一般来说是都会是成对出现的。使用右值引用的原因是为了能够让函数能够接受临时变量作为参数，而完美转发（右值引用，同时调用forward）简单来说是让左值始终是左值，右值始终是右值，不改变变量在这方面的属性。function是一个通用的多态函数包装器。在这可以理解成一种不定类型函数，向队列中添加任何类型的函数都不会发生冲突。 explict关键字 参考：https://blog.csdn.net/k6604125/article/details/126524992 C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式).如下示例中，C++类的初始化其实是不可以直接用赋值这种操作的，比如“CxString string2 = 10”，但如果的构造函数只有一个参数时, 那么在编译的时候就会有一个缺省的转换操作:将该构造函数对应数据类型的数据转换为该类对象.1234567891011121314151617181920212223242526272829303132class CxString // 没有使用explicit关键字的类声明, 即默认为隐式声明 &#123; public: char *_pstr; int _size; CxString(int size) &#123; _size = size; // string的预设大小 _pstr = malloc(size + 1); // 分配string的内存 memset(_pstr, 0, size + 1); &#125; CxString(const char *p) &#123; int size = strlen(p); _pstr = malloc(size + 1); // 分配string的内存 strcpy(_pstr, p); // 复制字符串 _size = strlen(_pstr); &#125; // 析构函数这里不讨论, 省略... &#125;; // 下面是调用: CxString string1(24); // 这样是OK的, 为CxString预分配24字节的大小的内存 CxString string2 = 10; // 这样是OK的, 为CxString预分配10字节的大小的内存 CxString string3; // 这样是不行的, 因为没有默认构造函数, 错误为: “CxString”: 没有合适的默认构造函数可用 CxString string4(&quot;aaaa&quot;); // 这样是OK的 CxString string5 = &quot;bbb&quot;; // 这样也是OK的, 调用的是CxString(const char *p) CxString string6 = &#x27;c&#x27;; // 这样也是OK的, 其实调用的是CxString(int size), 且size等于&#x27;c&#x27;的ascii码 string1 = 2; // 这样也是OK的, 为CxString预分配2字节的大小的内存 string2 = 3; // 这样也是OK的, 为CxString预分配3字节的大小的内存 string3 = string1; // 这样也是OK的, 至少编译是没问题的, 但是如果析构函数里用为了避免这种操作，可以在构造函数前加explict，这样就取消了隐式转换123456789101112131415161718192021222324252627class CxString // 使用关键字explicit的类声明, 显示转换 &#123; public: char *_pstr; int _size; explicit CxString(int size) &#123; _size = size; // 代码同上, 省略... &#125; CxString(const char *p) &#123; // 代码同上, 省略... &#125; &#125;; // 下面是调用: CxString string1(24); // 这样是OK的 CxString string2 = 10; // 这样是不行的, 因为explicit关键字取消了隐式转换 CxString string3; // 这样是不行的, 因为没有默认构造函数 CxString string4(&quot;aaaa&quot;); // 这样是OK的 CxString string5 = &quot;bbb&quot;; // 这样也是OK的, 调用的是CxString(const char *p) CxString string6 = &#x27;c&#x27;; // 这样是不行的, 其实调用的是CxString(int size), 且size等于&#x27;c&#x27;的ascii码, 但explicit关键字取消了隐式转换 string1 = 2; // 这样也是不行的, 因为取消了隐式转换 string2 = 3; // 这样也是不行的, 因为取消了隐式转换 string3 = string1; // 这样也是不行的, 因为取消了隐式转换, 除非类实现操作符&quot;=&quot;的重载 线程池代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#ifndef __THREADPOOLV5_H__#define __THREADPOOLV5_H__#include &lt;queue&gt;#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;vector&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;semaphore.h&gt;#include &quot;locker.h&quot;class ThreadPool&#123;public: // 构造函数 explicit ThreadPool(int t_num, int j_num) :m_threadNum(t_num), m_queMaxSize(j_num), m_resource(0, 0), m_resEmpty(0, m_queMaxSize), m_mtx(0,1), m_stop(false) //采用列表初始化 &#123; for(int i = 0; i &lt; m_threadNum; ++i) &#123; std::thread([this]() &#123; while(!m_stop) &#123; m_resource.wait(); m_mtx.wait(); auto todoTask = m_jobQueue.front(); m_jobQueue.pop(); m_resEmpty.post(); m_mtx.post(); todoTask(); &#125; &#125;).detach(); &#125; &#125; // 析构函数 ~ThreadPool() &#123; m_stop = true; &#125; // 对外接口：向线程池中添加任务 template &lt;class F&gt; void append(F &amp;&amp;task) &#123; m_resEmpty.wait(); m_mtx.wait(); m_jobQueue.emplace(std::forward&lt;F&gt;(task)); m_resource.post(); m_mtx.post(); &#125; // 删除我们不需要的拷贝函数 ThreadPool(const ThreadPool &amp;) = delete; ThreadPool &amp;operator=(const ThreadPool &amp;) = delete;private: int m_threadNum; int m_queMaxSize; Locker m_resource; Locker m_resEmpty; Locker m_mtx; bool m_stop; std::queue&lt;std::function&lt;void()&gt;&gt; m_jobQueue; std::vector&lt;std::thread&gt; m_workThreads;&#125;;#endif GET和POST的区别最直观的区别就是GET把参数包含在URL中，POST通过request body传递参数。GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。GET请求在URL中传送的参数是有长度限制。（大多数）浏览器通常都会限制url长度在2K个字节，而（大多数）服务器最多处理64K大小的url。GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100（指示信息—表示请求已接收，继续处理）continue，浏览器再发送data，服务器响应200 ok（返回数据）。 为了避免将用户名和密码直接暴露在URL中，我们在项目中改用了POST请求，将用户名和密码添加在报文中作为消息体进行了封装。 ifdef endif操作 https://blog.csdn.net/andylanzhiyong/article/details/78575354一般情况下，源程序中所有的行都参加编译。但是有时希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。 条件编译命令最常见的形式为：12345#ifdef 标识符 程序段1 #else 程序段2 #endif它的作用是：当标识符已经被定义过(一般是用#define命令定义)，则对程序段1进行编译，否则编译程序段2 补充函数statstat函数用于取得指定文件的文件属性，并将文件属性存储在结构体stat里，这里仅对其中用到的成员进行介绍。成功返回0，失败返回-1；123456789101112 #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;unistd.h&gt; //获取文件属性，存储在statbuf中 int stat(const char *pathname, struct stat *statbuf); struct stat &#123; mode_t st_mode; /* 文件类型和权限 */ off_t st_size; /* 文件大小，字节数*/&#125;;mmap用于将一个文件或其他对象映射到内存，提高文件的访问速度。 12void* mmap(void* start,size_t length,int prot,int flags,int fd,off_t offset);int munmap(void* start,size_t length); start：映射区的开始地址，设置为0时表示由系统决定映射区的起始地址length：映射区的长度prot：期望的内存保护标志，不能与文件的打开模式冲突 -PROT_READ 表示页内容可以被读取flags：指定映射对象的类型，映射选项和映射页是否可以共享 -MAP_PRIVATE 建立一个写入时拷贝的私有映射，内存区域的写入不会影响到原文件fd：有效的文件描述符，一般是由open()函数返回off_toffset：被映射对象内容的起点 iovec定义了一个向量元素，通常，这个结构用作一个多元素的数组。1234struct iovec &#123; void *iov_base; /* starting address of buffer */ size_t iov_len; /* size of buffer */&#125;;iov_base指向数据的地址iov_len表示数据的长度 原代码中定义了两个iovec，一个是报文内容，一个是报文空行下，用户请求的文件1234567//第一个iovec指针指向响应报文缓冲区，长度指向m_write_idx m_iv[0].iov_base=m_write_buf; m_iv[0].iov_len=m_write_idx;//第二个iovec指针指向mmap返回的文件指针，长度指向文件大小 m_iv[1].iov_base=m_file_address; m_iv[1].iov_len=m_file_stat.st_size; m_iv_count=2; writevwritev函数用于在一次函数调用中写多个非连续缓冲区，有时也将这该函数称为聚集写。12#include &lt;sys/uio.h&gt;ssize_t writev(int filedes, const struct iovec *iov, int iovcnt); filedes表示文件描述符iov为前述io向量机制结构体ioveciovcnt为结构体的个数若成功则返回已写的字节数，若出错则返回-1。writev以顺序iov[0]，iov[1]至iov[iovcnt-1]从缓冲区中聚集输出数据。writev返回输出的字节总数，通常，它应等于所有缓冲区长度之和。 特别注意： 循环调用writev时，需要重新处理iovec中的指针和长度，该函数不会对这两个成员做任何处理。writev的返回值为已写的字节数，但这个返回值“实用性”并不高，因为参数传入的是iovec数组，计量单位是iovcnt，而不是字节数，我们仍然需要通过遍历iovec来计算新的基址，另外写入数据的“结束点”可能位于一个iovec的中间某个位置，因此需要调整临界iovec的io_base和io_len。 定时器补充函数memsetvoid memset(void s, int ch, size_t n);函数解释：将s中当前位置后面的n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。memset：作用是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法 socketpair https://blog.csdn.net/weixin_40039738/article/details/81095013 在linux下，使用socketpair函数能够创建一对套接字进行通信，项目中使用管道通信。1234#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socketpair(int domain, int type, int protocol, int sv[2]);domain表示协议族，PF_UNIX或者AF_UNIXtype表示协议，可以是SOCK_STREAM或者SOCK_DGRAM，SOCK_STREAM基于TCP，SOCK_DGRAM基于UDPprotocol表示类型，只能为0sv[2]表示套节字柄对，该两个句柄作用相同，均能进行读写双向操作，其实就是两个文件描述符sv[0]和sv[1]返回结果， 0为创建成功，-1为创建失败 备注： 这对套接字可以用于全双工通信，每一个套接字既可以读也可以写。例如，可以往sv[0]中写，从sv[1]中读；或者从sv[1]中写，从sv[0]中读； 如果往一个套接字(如sv[0])中写入后，再从该套接字读时会阻塞，只能在另一个套接字中(sv[1])上读成功； 读、写操作可以位于同一个进程，也可以分别位于不同的进程，如父子进程。如果是父子进程时，一般会功能分离，一个进程用来读，一个用来写。因为文件描述副sv[0]和sv[1]是进程共享的，所以读的进程要关闭写描述符, 反之，写的进程关闭读描述符。 日志系统日志:由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。同步和异步：同步日志，日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。异步日志，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。 生产者-消费者模型，并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。 阻塞队列，将生产者-消费者模型进行封装，使用循环数组实现队列，作为两者共享的缓冲区。 单例模式，最简单也是被问到最多的设计模式之一，保证一个类只创建一个实例，同时提供全局访问的方法。 本项目中，使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式。其中异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。日志系统大致可以分成两部分，其一是单例模式与阻塞队列的定义，其二是日志类的定义与使用。 virtual关键字，虚函数虚函数只有虚函数才可以被派生类重写，但是重写时，传入参数和返回值类型要一致。可以在基类中将被重写的成员函数设置为虚函数，其含义是：当通过基类的指针或者引用调用该成员函数时，将根据指针指向的对象类型确定调用的函数，而非指针的类型。如下，是未将test()函数设置为虚函数前的执行结果： 单例设计模式单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法(getinstance)获取该实例。单例模式有两种实现方法，分别是懒汉和饿汉模式。懒汉模式：即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；饿汉模式：即迫不及待，在程序运行时立即初始化。 经典的线程安全懒汉模式单例模式的实现思路如前述所示，其中，经典的线程安全懒汉模式，使用双检测锁模式。 单例设计模式一定要考虑同步问题，如下： 多线程情况下，若是A线程调用getInstance，发现instance为null，那么它会开始创建实例，如果此时CPU发生时间片切换，线程B开始执行，调用getInstance，发现instance也null（因为A并没有创建对象），然后B创建对象，然后切换到A，A因为已经检测过了，不会再检测了，A也会去创建对象，两个对象，单例失败。因此要同步。选择用双重检测的方式进行构造，为什么？如果去掉第一次，在每次调用获取实例的方法时，都需要加锁，再判断是否为null,这将严重影响程序性能。如果去掉第二次的判断是否为null,那么拿到锁后直接新建，释放锁后，其他竞争的程序拿到该锁，会再新建一个，就不是单例了。 1234567891011121314151617181920212223242526272829303132class single&#123;private: //私有静态指针变量指向唯一实例 static single *p; //静态锁，是由于静态函数只能访问静态成员 static pthread_mutex_t lock; //私有化构造函数 single()&#123; pthread_mutex_init(&amp;lock, NULL); &#125; ~single()&#123;&#125;public: //公有静态方法获取实例 static single* getinstance();&#125;;pthread_mutex_t single::lock;//双重检测single* single::p = NULL;single* single::getinstance()&#123; if (NULL == p)&#123; pthread_mutex_lock(&amp;lock); if (NULL == p)&#123; p = new single; &#125; pthread_mutex_unlock(&amp;lock); &#125; return p;&#125; 1234567891011121314151617181920212223242526272829//m_read_idx指向数据末尾的下一个字节//m_checked_idx指向当前字节/*a[i++]=b;等于a[i]=b;i++;*/http_conn::LINE_STATUS http_conn::parse_line()&#123; char temp; for(;m_check_idx&lt;mm_read_idx;m_check_idx++) &#123; temp = m_read_buf[m_check_idx]; if(temp==&#x27;\\r&#x27;) &#123; if(m_read_buf[m_check_idx+1]==&#x27;/n&#x27;) &#123; m_read_buf[m_check_idx++]==&#x27;/0&#x27;; m_read_buf[m_check_idx++]==&#x27;/0&#x27;; return LINE_OK; &#125; else if(m_check_idx+1==m_read_idx) return LINE_OPEN; return LINE_BAD; &#125; else if(temp==&#x27;/n&#x27;) &#125;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"回溯/动态规划/贪心","slug":"回溯算法","date":"2023-01-12T16:00:00.000Z","updated":"2023-05-30T11:22:42.788Z","comments":true,"path":"2023/01/13/回溯算法/","link":"","permalink":"http://example.com/2023/01/13/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","excerpt":"","text":"回溯法算法逻辑框架1234567891011121314void backtracking(参数) &#123; if (终止条件) &#123; 存放结果; return;//这里不一定return,取决于到这里是否已经到了树的叶节点//某些时候，本层的结果是一个结果，但是还可以继续追加，而不是结束 &#125; for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;//树的某层的遍历逻辑 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果//因为上面的backtrack是针对for循环中的某个元素的 //所以，为了下次执行一定要清理现场 &#125;&#125;一般定义两个变量，一个是所有结果的集合，一个是结果，这个是个随时更新的变量，每次更新完要回溯的时候要清理现场回溯法用于解决：组合，排列，子集，切割问题 典型题目77 组合给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。你可以按 任何顺序 返回答案。1234567891011121314151617181920212223class Solution &#123;private: vector&lt;vector&lt;int&gt;&gt; result; // 存放符合条件结果的集合 vector&lt;int&gt; path; // 用来存放符合条件结果 void backtracking(int n, int k, int startIndex) &#123; if (path.size() == k) &#123; result.push_back(path); return; &#125; for (int i = startIndex; i &lt;= n; i++) &#123; path.push_back(i); // 处理节点 backtracking(n, k, i + 1); // 递归 path.pop_back(); // 回溯，撤销处理的节点 &#125; &#125;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; result.clear(); // 可以不写 path.clear(); // 可以不写 backtracking(n, k, 1); return result; &#125;&#125;;优化，问题出现在如果集合中剩下的元素已经不能满足情况，比如n=k=4，那么第一轮n=1之后，会得到2，3，4，但是for循环到2其实是没意义的，因为后面其实个数根本不够，顶多就是遍历完一遍之后return,不会进到if的那个循环里所以，改为 i &lt;= n - (k - path.size()) + 1这个值是什么意思，还是n=k=4这个时候第一次进入for循环，path.size()=0,k=4,n-(k-path.size())+1=1对应i只能取1 +1是因为这里表示的是具体值，并不是从0开始的索引值，所以，最小是要取1，其实理解起来就是这个要加进path里的i不能过大，过大就没有意义了比如n=5,k=4,第一轮for肯定最大只能取2，即倒数第k个[1,2,3,4,5],即n-k+1;5-4+1i = n - (k - path.size()) + 1 ,列表从[i,i+1,i+2…,n]中选，这个集合，一共有n-i+1=(k - path.size()) 个元素，即还需要多少个元素 排列给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以按任意顺序返回答案。示例 1： 输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 其实每层遍历的时候都是把所有元素遍历了一遍，但是不包括path里面已有的元素，所以就用了一个和nums等长的数组来表示该元素是否在path里，这个操作也是需要还原的123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; void backtracking (vector&lt;int&gt;&amp; nums, vector&lt;bool&gt;&amp; used) &#123; // 此时说明找到了一组 if (path.size() == nums.size()) &#123; result.push_back(path); return; &#125; for (int i = 0; i &lt; nums.size(); i++) &#123; if (used[i] == true) continue; // path里已经收录的元素，直接跳过 used[i] = true; path.push_back(nums[i]); backtracking(nums, used); path.pop_back(); used[i] = false; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; result.clear(); path.clear(); vector&lt;bool&gt; used(nums.size(), false); backtracking(nums, used); return result; &#125;&#125;; 贪心算法376.摆动队列如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 正常的逻辑是，之前的差定义为pre,现在要加入的节点定义为cur,那么cur&gt;0&amp;&amp;pre","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"Linux项目5-Web服务器项目","slug":"牛客项目5","date":"2023-01-08T16:00:00.000Z","updated":"2023-03-06T06:04:47.981Z","comments":true,"path":"2023/01/09/牛客项目5/","link":"","permalink":"http://example.com/2023/01/09/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE5/","excerpt":"","text":"预备知识阻塞/非阻塞，同步/异步 同步异步参考2 同步和异步指的是：当前线程是否需要等待方法调用执行完毕。阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起。同步&amp;异步指：当数据还未处理完成时，代码的逻辑处理方式不同。阻塞&amp;非阻塞指：当数据还未处理完成时(未就绪)，线程的状态。所以同步&amp;异步其实是处于框架这种高层次维度来看待的，而阻塞&amp;非阻塞往往针对底层的系统调用方面来抉择，也就是说两者是从不同维度来考虑的。 一次网络IO一般经历两个阶段：数据准备和数据读写数据准备阶段： 阻塞：调用IO方法，数据没有到达时，线程进入阻塞状态被挂起 非阻塞：不会改变线程状态，通过返回值判断 数据读写阶段：同步/异步 同步：效率低，编程简单，应用自己去缓冲区读数据 异步 阻塞和非阻塞都是同步IO Linux的异步IO接口：aio_read()aio_write() 5种IO模型 阻塞 read recv,通过设置socket属性实现阻塞和非阻塞 非阻塞，通过设置socket的属性为非阻塞，在没有数据时，返回-1，而不是阻塞不动，用户自己多次调用，根据返回值判断是否读取到了数据 IO复用()select/poll/epoll默认是阻塞的，一次监测多个IO，等待一个事件到达结束阻塞，再调用read 信号驱动 异步 C++内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变量和静态变量以及常量（全局区中有一部分是常量区） 栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等 堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收类模板12345678910111213template&lt;typename T1, typename T2&gt; //这里不能有分号class Point&#123;public: Point(T1 x, T2 y): m_x(x), m_y(y)&#123; &#125;//构造函数public: T1 getX() const; //获取x坐标 void setX(T1 x); //设置x坐标 T2 getY() const; //获取y坐标 void setY(T2 y); //设置y坐标private: T1 m_x; //x坐标 T2 m_y; //y坐标&#125;; 在类外定义成员函数时仍然需要带上模板头，格式为： template返回值类型 类名&lt;类型参数1 , 类型参数2, …&gt;::函数名(形参列表){ //TODO:} 12345678910111213141516171819template&lt;typename T1, typename T2&gt; //模板头T1 Point&lt;T1, T2&gt;::getX() const /*函数头*/ &#123; return m_x;&#125;template&lt;typename T1, typename T2&gt;void Point&lt;T1, T2&gt;::setX(T1 x)&#123; m_x = x;&#125;template&lt;typename T1, typename T2&gt;T2 Point&lt;T1, T2&gt;::getY() const&#123; return m_y;&#125;template&lt;typename T1, typename T2&gt;void Point&lt;T1, T2&gt;::setY(T2 y)&#123; m_y = y;&#125; 类名 Point 后面也要带上类型参数，只是不加 typename 关键字了。另外需要注意的是，在类外定义成员函数时，template 后面的类型参数要和类声明时的一致。 静态变量使用静态成员变量来实现多个对象共享数据的目标1234567891011class Student&#123;public: Student(char *name, int age, float score); void show();public: static int m_total; //静态成员变量private: char *m_name; int m_age; float m_score;&#125;;static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total 分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了 m_total，也会影响到其他对象。在静态成员函数中无法访问类内的其他普通变量 static 成员变量必须在类声明的外部初始化，具体形式为：12//type class::name = value;int Student::m_total = 0;static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。 类的函数定义在类体中直接定义函数时，不需要在函数名前面加上类。但当成员函数定义在类外时，就必须在函数名前面加上类名予以限定。::被称为域解析符（也称作用域运算符或作用域限定符），用来连接类名和函数名，指明当前函数属于哪个类。123void Student::say()&#123; cout&lt;&lt;name&lt;&lt;&quot;的年龄是&quot;&lt;&lt;age&lt;&lt;&quot;，成绩是&quot;&lt;&lt;score&lt;&lt;endl;&#125;在类体中和类体外定义成员函数是有区别的：在类体中定义的成员函数会自动成为内联函数，在类体外定义的不会。当然，在类体内部定义的函数也可以加 inline 关键字(把函数变成内联函数)，但这是多余的，因为类体内部定义的函数默认就是内联函数。内联函数一般不是我们所期望的，它会将函数调用处用函数体替代，所以我建议在类体内部对成员函数作声明，而在类体外部进行定义，这是一种良好的编程习惯，实际开发中大家也是这样做的。这种在类体外定义 inline 函数的方式，必须将类的定义和成员函数的定义都放在同一个头文件中（或者同一个源文件中），否则编译时无法进行嵌入（将函数代码的嵌入到函数调用出）所以不建议使用。 线程池创建线程池技术的优点有： 提高服务器的响应速度和执行效率 能够减少创建的线程个数 线程池适用的场合： 单位时间内处理任务频繁而且任务处理时间短 对实时性要求比较高 线程池类包含如下三个方法： append:加入任务到线程池worker：每个线程的执行函数，没什么具体功能，负责调用run，执行工作代码run:执行工作代码 需要注意的是worker作为类内线程调用的函数，只能是静态成员函数，因为：其实类的静态函数就跟全局函数是一个样子的, 只是调用的时候要加下个类修饰符而以.至于为什么不能是非静态成员函数呢, 因为非静态成员函数都会在参数列表中加上一个this指针为为参数, 这样的话你写的线程函数就不符合调用规定了123DWORD WINAPI ThreadFun(LPVOID); //该函数是非静态的DWORD WINAPI ThreadFun(LPVOID, CMyClass *this);//实际编译后会自动传入this，相当于有两个参数int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);//但是线程创建时，只能传入一个参数arg，所以线程函数只能是静态的为了解决静态函数不能访问该对象的其他成员，可以直接传this参数，this指向当前对象，也就是我们的线程池1234567template&lt; typename T &gt;void* threadpool&lt; T &gt;::worker( void* arg )&#123; threadpool* pool = ( threadpool* )arg; pool-&gt;run(); return pool;&#125;其实可以将worker和run合并，但是会很复杂，因为后面我们在访问其他成员时，都要加上pool-&gt;,所以干脆分开写 12345678910111213141516171819202122template&lt;typename T&gt;class threadpool &#123;public: /*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/ threadpool(int thread_number = 8, int max_requests = 10000); ~threadpool(); bool append(T* request);private: /*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/ static void* worker(void* arg); void run();private: int m_thread_number; // 线程的数量 pthread_t * m_threads;// 描述线程池的数组，大小为m_thread_number int m_max_requests; // 请求队列中最多允许的、等待处理的请求的数量 std::list&lt; T* &gt; m_workqueue; // 请求队列,T是模板中定义的任务类型 locker m_queuelocker; // 保护请求队列的互斥锁 sem m_queuestat; // 是否有任务需要处理 bool m_stop; // 是否结束线程 &#125;; 代码逻辑 创建一个线程池对象，里面的队列m_workqueue用于存储任务，同时创建m_thread_number个线程，每个线程执行worker,然后接着就执行run,run函数通过信号量m_queuestat阻塞 通过调用append加入任务,首先将该任务加入任务队列m_workqueue，然后post信号量m_queuestat，告诉线程池有一个任务需要处理，此时某个线程的run解除阻塞，从队列中取出该任务（pop_front）,执行其业务代码process 备注1：信号量的操作是原子操作，这个信号量是共享的一个变量，表示有多少个任务需要处理，起始为0，所以所有线程的run函数都会阻塞，然后有一个任务到来后，就post信号量，此时只能有一个线程的wait解除阻塞，因为wait执行后信号量会-1，所以信号量就又变成0了，其他线程继续阻塞直到再有新的任务，信号量本身的原子操作（不会被打断），其实就已经相当于有一个锁的操作，多个线程对同一个信号量进行操作，其实是按顺序的，比如两个线程都想post,本来是1，执行后就是3，他们两个线程不会同时拿到当前的1，执行后变为2，而是有顺序的，某一个先+1，另一个线程取到的时候就变成2了，所以不用担心某个任务会被重复的wait备注2：对于任务队列m_workqueue，因为是多线程共享的，所以需要互斥锁加持，记得操作完之后解锁 run函数12345678910111213141516171819template&lt; typename T &gt;void threadpool&lt; T &gt;::run() &#123; while (!m_stop) &#123; m_queuestat.wait(); m_queuelocker.lock(); if ( m_workqueue.empty() ) &#123; m_queuelocker.unlock(); continue; &#125; T* request = m_workqueue.front(); m_workqueue.pop_front(); m_queuelocker.unlock(); if ( !request ) &#123; continue; &#125; request-&gt;process(); &#125;&#125;append函数当前代码其实是可以改进的，在if ( m_workqueue.size() &gt; m_max_requests ) 时，其实是有问题的，也就是等于的时候还是可以加进去的，比如线程池有8个线程，加满之后，再来一个任务，此时判断是等于，还是会加进去一个任务，但是第10个任务来的时候就返回false，那你第9个任务导致的post其实没有线程去响应，要等某个线程当前process业务代码执行完后重新进入wait，所以这个设定可能是怕加进来太多处理不过来，不过感觉还是改成&gt;=好一点同时，可以用信号量来进行改进，阻塞在这里，1234567891011121314template&lt; typename T &gt;bool threadpool&lt; T &gt;::append( T* request )&#123; // 操作工作队列时一定要加锁，因为它被所有线程共享。 m_queuelocker.lock(); if ( m_workqueue.size() &gt; m_max_requests ) &#123;//线程池都被占用 m_queuelocker.unlock(); return false; &#125; m_workqueue.push_back(request); m_queuelocker.unlock(); m_queuestat.post(); return true;&#125; 主函数signal和sigactionsignal的兼容性不如sigaction好，在跨平台迁移时有问题，两者的功能一样，因此多采用sigaction， signal 函数的使用方法简单，但并不属于 POSIX 标准，在各类 UNIX 平台上的实现不尽相同，因此其用途受返回值：成功0，失败-11234567891011121314151617181920212223#include &lt;signal.h&gt; int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);//signum参数指出要捕获的信号类型，act参数指定新的信号处理方式，oldact参数输出先前信号的处理方式（如果不为NULL的话）。struct sigaction &#123;void (*sa_handler)(int);//代表新的新的信号处理函数void (*sa_sigaction)(int, siginfo_t *, void *);//另一个信号处理函数，可以获得信号更详细的信息sigset_t sa_mask;//指定在信号处理函数执行期间需要被屏蔽的信号，特别是当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间这个信号不会再度发生。int sa_flags;/* 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction，还可以是其他宏值，有不同的含义*/void (*sa_restorer)(void);//已经废弃&#125;;//示例struct sigaction act;act.sa_flags = 0;//使用handler指定的处理函数act.sa_handler = myalarm;sigemptyset(&amp;act.sa_mask); // 清空临时阻塞信号集// 注册信号捕捉sigaction(SIGALRM, &amp;act, NULL); assert函数void assert(scalar expression);assert不算一个函数，是一个宏。这个宏的作用是帮助我们程序员发现程序中的错误。如果expression的返回值为FALSE，那么assert会调用abort()函数终止整个程序，并将错误信息打印到stderr上。 EPOLLEPOLL的两种模式——ET和LT模式ET模式更高效，也叫边缘触发，理解一下就是只有在边缘那一下会触发 边缘触发模式ET：使用该模式时，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。所以，在使用ET模式的时候，为了保证数据都能被读取，一般要搭配 while 循环去读取数据。同时，为了不让读取函数在没有数据可以读时，阻塞住当前进程/线程，一般要将read/write函数设置为非阻塞模式，也即O_NONBLOCK为什么在ET模式具有缺点的情况下，还在强调ET模式的读写，这是因为ET模式一般情况下会比LT模式效率更高。这是因为ET模式避免了多次调用epollwit函数，可以避免epoll上的资源消耗，从而提高了执行效率。水平触发模式LT：使用该模式时，当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，会继续通知你去处理未完成的读写事件。 枚举enum如果一个变量的取值只有几种有限的可能性，我们可以将其定义为枚举类型：如下代码：12345enum enumType&#123; MONDAY, TUESDAY, WENESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;// 匿明枚举enum&#123; MONDAY, TUESDAY, WENESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;枚举类型具有以下几个特点： 不指定具体的数据类型。默认是数值，像上面的代码中，按照枚举中变量的顺序，从0开始依次给每一个赋值 也可以显式的给枚举中的变量赋值，但是必须是整数 枚举类型只有赋值运算，没有算术运算,只能将枚举变量赋值给非枚举变量，例如int today = MONDAY;是合法的，但是反过来就是错误的 枚举的作用域是全局的，在不同的枚举中不能使用相同名字的变量C++11 中出现的enum class 枚举类让变量拥有了自己的作用域，同时可以指定枚举变量的数据类型，是一种更加安全的使用方式。str函数 查找函数strpbrk:char strpbrk(const char s, const char accept);函数功能：在字符串 s 中 查找第一个出现字符串 accept 中任一字符的位置返回值：返回查找到的位置strrchr:char strrchr(const char *str, int c) 在参数 str 所指向的字符串中搜索最后一次出现字符 c（一个无符号字符）的位置。 比较函数strcasecmp用忽略大小写比较字符串，通过strncasecmp函数可以指定每个字符串用于比较的字符数，strcasecmp用来比较参数s1和s2字符串前n个字符，比较时会自动忽略大小写的差异。strspn:size_t strspn(const char str1, const char str2) 检索字符串 str1 中第一个不在字符串 str2 中出现的字符下标。strcpy：char strcpy(char destination,const char source);char destination————-目标字符串的首地址const char source———源地址：被复制的字符串的首地址，用const修饰，避免修改掉被拷贝的字符串函数的返回值类型：char：返回的是目标字符串的首地址 举例说明一下,解析如下的请求行 GET /562f25980001b1b106000338.jpg HTTP/1.11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162http_conn::HTTP_CODE http_conn::parse_request_line(char *text)&#123; m_url = strpbrk(text, &quot; \\t&quot;);//\\t前面还有个空格，所以此时m_url是第一个空格或者\\t出现的下标 if (!m_url)//如果m_url==0，也就是第一个char就是空格或者\\t直接返回错误 &#123; return BAD_REQUEST; &#125; *m_url++ = &#x27;\\0&#x27;;//正常的话，就把这个空格变为\\0,即字符串结束符，同时m_url指向后一个字符/*此时GET 空格 /562f25980001b1b106000338.jpg HTTP/1.1变为GET \\0 /562f25980001b1b106000338.jpg HTTP/1.1同时m_url指向字符：‘/’由于字符串遇到结束符会停止，所以此时text = &#x27;GET&#x27;*/ char *method = text; if (strcasecmp(method, &quot;GET&quot;) == 0) m_method = GET; else if (strcasecmp(method, &quot;POST&quot;) == 0) &#123; m_method = POST; cgi = 1; &#125; else return BAD_REQUEST;//strspn是寻找不是空格和\\t在字符串m_url中出现的第一个位置，所以这一步是为了m_url继续跳过空格和\\t字符，指向请求资源的第一个字符，也就是/562f。。。中的/t//不是很理解，正常的话应该中间没空格了吧 m_url += strspn(m_url, &quot; \\t&quot;);//接着就是读URL了，此时m_url刚好指向URL的开头 m_version = strpbrk(m_url, &quot; \\t&quot;);//此时m_version指向URL的结尾的空格，并把它置为&#x27;\\0&#x27;,那么m_url就指向URL的首字符，即URL字符串 if (!m_version) return BAD_REQUEST; *m_version++ = &#x27;\\0&#x27;;//继续跳过可能出现的多余的共格，此时m_version指向HTTP的开头 m_version += strspn(m_version, &quot; \\t&quot;);//然后就直接判断HTTP版本 if (strcasecmp(m_version, &quot;HTTP/1.1&quot;) != 0) return BAD_REQUEST;//对请求资源前7个字符进行判断//这里主要是有些报文的请求资源中会带有http://，这里需要对这种情况进行单独处理 if (strncasecmp(m_url, &quot;http://&quot;, 7) == 0) &#123; m_url += 7; m_url = strchr(m_url, &#x27;/&#x27;); &#125; if (strncasecmp(m_url, &quot;https://&quot;, 8) == 0) &#123; m_url += 8; m_url = strchr(m_url, &#x27;/&#x27;); &#125; if (!m_url || m_url[0] != &#x27;/&#x27;) return BAD_REQUEST; //当url为/时，显示判断界面 if (strlen(m_url) == 1) strcat(m_url, &quot;judge.html&quot;); m_check_state = CHECK_STATE_HEADER; return NO_REQUEST;&#125; http_conn.cpp\\t水平制表 \\r回车 \\n换行业务代码process 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 由线程池中的工作线程调用，这是处理HTTP请求的入口函数void http_conn::process() &#123; // 解析HTTP请求 HTTP_CODE read_ret = process_read(); if ( read_ret == NO_REQUEST ) &#123; modfd( m_epollfd, m_sockfd, EPOLLIN ); return; &#125; // 生成响应 bool write_ret = process_write( read_ret ); if ( !write_ret ) &#123; close_conn(); &#125; modfd( m_epollfd, m_sockfd, EPOLLOUT);&#125;// 主状态机，解析请求//返回值HTTP_CODE是一个枚举类型，在http_conn.h中定义/*enum HTTP_CODE &#123; NO_REQUEST, GET_REQUEST, BAD_REQUEST, NO_RESOURCE, FORBIDDEN_REQUEST, FILE_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION &#125;; 服务器处理HTTP请求的可能结果，报文解析的结果 NO_REQUEST : 请求不完整，需要继续读取客户数据 GET_REQUEST : 表示获得了一个完成的客户请求 BAD_REQUEST : 表示客户请求语法错误 NO_RESOURCE : 表示服务器没有资源 FORBIDDEN_REQUEST : 表示客户对资源没有足够的访问权限 FILE_REQUEST : 文件请求,获取文件成功 INTERNAL_ERROR : 表示服务器内部错误 CLOSED_CONNECTION : 表示客户端已经关闭连接了*/ http_conn::HTTP_CODE http_conn::process_read() &#123; LINE_STATUS line_status = LINE_OK; HTTP_CODE ret = NO_REQUEST; char* text = 0; while (((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK)) || ((line_status = parse_line()) == LINE_OK)) &#123; // 获取一行数据 text = get_line(); m_start_line = m_checked_idx; printf( &quot;got 1 http line: %s\\n&quot;, text ); switch ( m_check_state ) &#123; case CHECK_STATE_REQUESTLINE: &#123; ret = parse_request_line( text ); if ( ret == BAD_REQUEST ) &#123; return BAD_REQUEST; &#125; break; &#125; case CHECK_STATE_HEADER: &#123; ret = parse_headers( text ); if ( ret == BAD_REQUEST ) &#123; return BAD_REQUEST; &#125; else if ( ret == GET_REQUEST ) &#123; return do_request(); &#125; break; &#125; case CHECK_STATE_CONTENT: &#123; ret = parse_content( text ); if ( ret == GET_REQUEST ) &#123; return do_request(); &#125; line_status = LINE_OPEN; break; &#125; default: &#123; return INTERNAL_ERROR; &#125; &#125; &#125; return NO_REQUEST;&#125;// 当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性，// 如果目标文件存在、对所有用户可读，且不是目录，则使用mmap将其// 映射到内存地址m_file_address处，并告诉调用者获取文件成功","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"Linux项目4-网络编程","slug":"牛客项目4","date":"2022-12-31T16:00:00.000Z","updated":"2023-02-02T06:32:07.609Z","comments":true,"path":"2023/01/01/牛客项目4/","link":"","permalink":"http://example.com/2023/01/01/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE4/","excerpt":"","text":"MAC地址网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网络接口卡NIC。其拥有 MAC 地址，属于 OSI 模型的第 2 层，它使得用户可以通过电缆或无线相互连接。每一个网卡都有一个被称为 MAC 地址的独一无二的 48 位串行号。网卡的主要功能： 数据的封装与解封装 链路管理 数据编码与译码 网卡分为以太网卡（有线网）和无线网卡通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就是一个MAC 地址，其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的某个网络产品（如网卡）的系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性。，每个网卡都需要独一无二的MAC地址，通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就是一个MAC 地址，其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的某个网络产品（如网卡）的系列号。只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性。 IP地址32位二进制数，分4组A类地址：1字节网络+3字节本机号码 ARP协议：根据IP查找MAC地址 Socket由IP地址和端口结合，提供向应用层进程传送数据包的机制。socket类似于一个文件描述符，通过读写缓冲区实现主机间通信客户端：主动向服务器发起连接服务器段：被动接受链接 Socket编程字节序转换函数字节序：大端字节序：高位字节排放在内存的低地址端。这里举例的是32位机，即一次装载4字节时的存储结果网络字节序与CPU和操作系统无关，采用大端排序，保证了不同主机之间传输可以被正确解释。网络通信时，需要将主机字节序转换成网络字节序（大端），另外一段获取到数据以后根据情况将网络字节序转换成主机字节序。C++中的int 可以分为short int, long int, long long int，分别占2，4，8个字节，对应的有各自的unsigned，由于端口是16位，也就是2字节，所以用short int,IP地址是32位，所以用int型（long int和int是一回事）INADDR_ANY转换过来就是0.0.0.0，泛指本机的意思，也就是表示本机的所有IP，因为有些机子不止一块网卡，多网卡的情况下，这个就表示所有网卡ip地址的意思。比如一台电脑有3块网卡，分别连接三个网络，那么这台电脑就有3个ip地址了，如果某个应用程序需要监听某个端口，那他要监听哪个网卡地址的端口呢？如果绑定某个具体的ip地址，你只能监听你所设置的ip地址所在的网卡的端口，其它两块网卡无法监听端口，如果我需要三个网卡都监听，那就需要绑定3个ip，也就等于需要管理3个套接字进行数据交换，这样岂不是很繁琐？所以出现INADDR_ANY，你只需绑定INADDR_ANY，管理一个套接字就行，不管数据是从哪个网卡过来的，只要是绑定的端口号过来的数据，都可以接收到。 h - host，主机，主机字节序to - 转换n - network，网络字节序s - short unsigned shortl - long unsigned int 12345678910//变量类型uint16_t：unsigned short intuint32_t：unsigned int// 转换端口，2个字节 uint16_t htons(uint16_t hostshort); uint16_t ntohs(uint16_t netshort); // 转IP,4个字节 uint32_t htonl(uint32_t hostlong); uint32_t ntohl(uint32_t netlong); //这些函数仅涉及字节序的转换，所以输入输出的数据类型都是一样的，最后的s和l区分了是转换IP还是转换端口 Scoket地址12345678910111213#include &lt;bits/socket.h&gt;struct sockaddr &#123;sa_family_t sa_family;char sa_data[14];&#125;;typedef unsigned short int sa_family_t;#include &lt;sys/un.h&gt;struct sockaddr_un&#123;sa_family_t sin_family;char sun_path[108];&#125;; 一般不使用sockaddr，而是使用sockaddr_in再进行强制类型转换 IPv4的sockaddr_in关键信息就是协议类型，端口号，IP，分别如下：1234struct sockaddr_in saddr;-协议:saddr.sin_family-IP:saddr.sin_addr.s_addr -端口：saddr.sin_port12345678910111213#include &lt;netinet/in.h&gt;struct sockaddr_in&#123;sa_family_t sin_family; in_port_t sin_port; //unit16_t类型，端口地址struct in_addr sin_addr; //结构体，只有一个元素s_addr,存放IP/* Pad to size of `struct sockaddr&#x27;. */unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE -sizeof (in_port_t) - sizeof (struct in_addr)];&#125;;struct in_addr&#123;in_addr_t s_addr;//unit32_t类型，存放IP地址&#125;;IPv6的sockaddr_in612345678910111213struct sockaddr_in6&#123;sa_family_t sin6_family;in_port_t sin6_port; /* Transport layer port # */uint32_t sin6_flowinfo; /* IPv6 flow information */struct in6_addr sin6_addr; /* IPv6 address */uint32_t sin6_scope_id; /* IPv6 scope-id */&#125;;typedef unsigned short uint16_t;typedef unsigned int uint32_t;typedef uint16_t in_port_t;typedef uint32_t in_addr_t;#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int)) IP地址转换函数 p:点分十进制的IP字符串n:表示network，网络字节序的整数 1234567891011121314151617181920# include &lt;arpa/inet.h&gt;in_addr_t inet_addr(const char *cp);int inet_aton(const char *cp, struct in_addr *inp);char *inet_ntoa(struct in_addr in);//主要用到以下两个，他们能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：int inet_pton(int af, const char *src, void *dst);/*af:地址族： AF_INET AF_INET6src:需要转换的点分十进制的IP字符串dst:转换后的结果保存在这个里面*/// 将网络字节序的整数，转换成点分十进制的IP地址字符串const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);/*af:地址族： AF_INET AF_INET6src: 要转换的ip的整数的地址dst: 转换成IP地址字符串保存的地方size：第三个参数的大小（数组的大小）返回值：返回转换后的数据的地址（字符串），和 dst 是一样的*/ 实例需要注意void 可以指向任何类型的地址，但是带类型的指针不能指向void 的地址，所以可以直接传入&amp;num，即一个unsigned int的值给void ,但只有强制类型转换后才可以使用当void* 指针作为函数的输入和输出时，表示可以接受任意类型的输入指针和输出任意类型的指针1234567891011121314151617181920212223242526// 创建一个ip字符串,点分十进制的IP地址字符串，总共有32位分为4组，即每组有8位，可以用unsigned char(1字节，8位)来表示 char buf[] = &quot;192.168.1.4&quot;; unsigned int num = 0; // 将点分十进制的IP字符串转换成网络字节序的整数 inet_pton(AF_INET, buf, &amp;num); unsigned char * p = (unsigned char *)&amp;num; printf(&quot;%d %d %d %d\\n&quot;, *p, *(p+1), *(p+2), *(p+3));//结果：192 168 1 4，此时num = 67217600(0000 0100 0000 0001 1010 1000 1100 0000)/*可以看到字节序和char类型的显示是不太一样的 1100 0000 -&gt;192 1010 1000 -&gt;168 0000 0001 -&gt;1 0000 0100 -&gt;4*/ // 将网络字节序的IP整数转换成点分十进制的IP字符串 char ip[16] = &quot;&quot;; const char * str = inet_ntop(AF_INET, &amp;num, ip, 16); printf(&quot;str : %s\\n&quot;, str); printf(&quot;ip : %s\\n&quot;, ip); printf(&quot;%d\\n&quot;, ip == str);/*结果：str:192.168.1.4ip:198.168.1.41*/ TCP通信TCP通信需要用到的函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt; // 包含了这个头文件，上面两个就可以省略int socket(int domain, int type, int protocol);- 功能：创建一个套接字- 参数：- domain: 协议族 AF_INET : ipv4 AF_INET6 : ipv6 AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）- type: 通信过程中使用的协议类型 SOCK_STREAM : 流式协议 SOCK_DGRAM : 报式协议- protocol : 具体的一个协议。一般写0，因为一个协议族有很多，这个数字表示用族里的哪一个协议 SOCK_STREAM : 流式协议默认使用 TCP SOCK_DGRAM : 报式协议默认使用 UDP- 返回值： 成功：返回文件描述符，操作的就是内核缓冲区。 失败：-1int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命名- 功能：绑定，将fd 和本地的IP + 端口进行绑定- 参数：- sockfd : 通过socket函数得到的文件描述符- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息- addrlen : 第二个参数结构体占的内存大小int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn- 功能：监听这个socket上的连接- 参数：- sockfd : 通过socket()函数得到的文件描述符- backlog : 未连接的和已经连接的和的最大值， 5int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接- 参数：- sockfd : 用于监听的文件描述符- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）- addrlen : 指定第二个参数的对应的内存大小- 返回值：- 成功 ：用于通信的文件描述符- -1 ： 失败int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);- 功能： 客户端连接服务器- 参数：- sockfd : 用于通信的文件描述符- addr : 客户端要连接的服务器的地址信息- addrlen : 第二个参数的内存大小- 返回值：成功 0， 失败 -1 TCP服务器端代码12345678910// 创建socketint listenfd = socket(AF_INET, SOCK_STREAM, 0);// 绑定bind(listenfd, (struct sockaddr*)&amp;my_addr, sizeof(my_addr));// 监听listen(listenfd, 5);// 接受客户端连接int socketFd = accept(listenfd, (struct sockaddr*) &amp;clientaddr, &amp;clientaddrlen) ​// 接收客户端数据recv(socketFd, buf, 256, 0); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// TCP 通信的服务器端#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.创建socket(用于监听的套接字) int lfd = socket(AF_INET, SOCK_STREAM, 0); if(lfd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.绑定 struct sockaddr_in saddr;//IPv4的socket地址，需要给定端口，协议，IP三个信息 saddr.sin_family = AF_INET; //可以通过如下函数指定IP地址，即将给定的点分10进制IP传入saddr.sin_addr.s_addr // inet_pton(AF_INET, &quot;192.168.193.128&quot;, saddr.sin_addr.s_addr); saddr.sin_addr.s_addr = INADDR_ANY; // 0.0.0.0 saddr.sin_port = htons(9999); int ret = bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr)); if(ret == -1) &#123; perror(&quot;bind&quot;); exit(-1); &#125; // 3.监听 ret = listen(lfd, 8); if(ret == -1) &#123; perror(&quot;listen&quot;); exit(-1); &#125; // 4.接收客户端连接 struct sockaddr_in clientaddr; int len = sizeof(clientaddr); int cfd = accept(lfd, (struct sockaddr *)&amp;clientaddr, &amp;len); if(cfd == -1) &#123; perror(&quot;accept&quot;); exit(-1); &#125; // 输出客户端的信息 char clientIP[16]; inet_ntop(AF_INET, &amp;clientaddr.sin_addr.s_addr, clientIP, sizeof(clientIP)); unsigned short clientPort = ntohs(clientaddr.sin_port); printf(&quot;client ip is %s, port is %d\\n&quot;, clientIP, clientPort); // 5.通信 char recvBuf[1024] = &#123;0&#125;; while(1) &#123; // 获取客户端的数据 int num = read(cfd, recvBuf, sizeof(recvBuf)); if(num == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(num &gt; 0) &#123; printf(&quot;recv client data : %s\\n&quot;, recvBuf); &#125; else if(num == 0) &#123; // 表示客户端断开连接 printf(&quot;clinet closed...&quot;); break; &#125; char * data = &quot;hello,i am server&quot;; // 给客户端发送数据 write(cfd, data, strlen(data)); &#125; // 关闭文件描述符 close(cfd); close(lfd); return 0;&#125; TCP客户端 创建socket 链接connect 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// TCP通信的客户端#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main() &#123; // 1.创建套接字 int fd = socket(AF_INET, SOCK_STREAM, 0); if(fd == -1) &#123; perror(&quot;socket&quot;); exit(-1); &#125; // 2.连接服务器端 struct sockaddr_in serveraddr; serveraddr.sin_family = AF_INET; inet_pton(AF_INET, &quot;192.168.193.128&quot;, &amp;serveraddr.sin_addr.s_addr); serveraddr.sin_port = htons(9999); int ret = connect(fd, (struct sockaddr *)&amp;serveraddr, sizeof(serveraddr)); if(ret == -1) &#123; perror(&quot;connect&quot;); exit(-1); &#125; // 3. 通信 char recvBuf[1024] = &#123;0&#125;; while(1) &#123; char * data = &quot;hello,i am client&quot;; // 给客户端发送数据 write(fd, data , strlen(data)); sleep(1); int len = read(fd, recvBuf, sizeof(recvBuf)); if(len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(len &gt; 0) &#123; printf(&quot;recv server data : %s\\n&quot;, recvBuf); &#125; else if(len == 0) &#123; // 表示服务器端断开连接 printf(&quot;server closed...&quot;); break; &#125; &#125; // 关闭连接 close(fd); return 0;&#125; 半关闭，端口复用TCP关闭时经过前2次挥手后，客户端不能再主动发送数据，处于半关闭状态，如果需要某一方只接收不发送可以考虑采用半关闭，通过shutdown实现12345678910#include &lt;sys/socket.h&gt;int shutdown(int sockfd, int how);sockfd: 需要关闭的socket的描述符how: 允许为shutdown操作选择以下几种方式:SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。注意: 如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。 在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信。但如果一个进程 close(sfd) 将不会影响到其它进程。 查看网络相关信息的命令：netstat参数：-a 所有的socket-p 显示正在使用socket的程序名称-n 直接使用IP地址，而不是显示域名netstat -anp|grep 9999端口复用发生在TCP的4次挥手阶段，主动关闭一方进入FIN_WAIT2或TIME_WAIT后，都要等60s左右才可以切换到下一个状态，因此如果服务端重启或其他情况，导致该端口不能立马使用，所以需要端口复用。参考这个需要在bind前设置好1234567#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen)//sockfd 需要操作的socket//level和optname都需要查表，后面分别是修改后的值的地址以及数据长度，当设置SO_REUSEADDR为1时表示允许端口复用int optval = 1;setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval)); IO多路复用同步阻塞： 优点： 开发简单，由于accept()、recv()都是阻塞的，为了服务于多个客户端请求，新的连接创建一个线程去处理即可 阻塞的时候，线程挂起，不消耗CPU资源 缺点： 每新来一个IO请求，都需要新建一个线程对应，高并发下系统开销大，多线程上下文切换频繁 创建线程太多，内存消耗大 同步非阻塞：1234567891011121314151617181920// 创建socketint listenfd = socket(AF_INET, SOCK_STREAM, 0);// 绑定bind(listenfd, (struct sockaddr*)&amp;my_addr, sizeof(my_addr));// 监听listen(listenfd, 5);// 设置为非阻塞ioctl(listenfd, FIONBIO, 1);// 接受客户端连接int socketFd = accept(listenfd, (struct sockaddr*) &amp;clientaddr, &amp;clientaddrlen);// 设置为非阻塞ioctl(socketFd, FIONBIO, 1);while (1) &#123; int fd; // 循环遍历 for (fd : fds) &#123; // 接收客户端数据 recv(fd, buf, 256, 0); &#125;&#125; 优点： 非阻塞， accept()、recv()均不阻塞，用户线程立即返回 规避了同步阻塞模式的多线程问题，如上，通过遍历即可避免创建多线程 缺点： 假如现在有1万个客户端连接，但只有1个客户端发送数据过来，为了获取这个1个客户端发送的消息，我需要循环向内核发送1万遍recv()系统调用，而这其中有9999次是无效的请求，浪费CPU资源 针对同步非阻塞IO的缺点，设想如果内核提供一个方法，可以一次性把1万个客户端socket连接传入，在内核中去遍历，如果没有数据这个方法就一直阻塞，一但有数据这个方法解除阻塞并把所有有数据的socket返回，把这个遍历的过程交给内核去处理，是不是就可以避免空跑，避免1万次用户态到内核态的切换呢？ 由此引出IO多路复用 参考链接，写的很好IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题，即一次性将N个客户端socket连接传入内核然后阻塞，交由内核去轮询，当某一个或多个socket连接有事件发生时，解除阻塞并返回事件列表，用户进程在循环遍历处理有事件的socket连接。这样就避免了多次调用recv()系统调用，避免了用户态到内核态的切换。 select select函数仅仅知道有几个I/O事件发生了，但并不知道具体是哪几个socket连接有I/O事件，还需要轮询去查找，时间复杂度为O(n)，处理的请求数越多，所消耗的时间越长。 主旨思想： 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。 调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行I/O操作时，该函数才返回。a.这个函数是阻塞b.函数对文件描述符的检测的操作是由内核完成的 在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344// sizeof(fd_set) = 128 1024#include &lt;sys/time.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/select.h&gt;int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);- 参数：- nfds : 委托内核检测的最大文件描述符的值 + 1- readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性- 一般检测读操作- 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区- 是一个传入传出参数- writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性- 委托内核检测写缓冲区是不是还可以写数据（不满的就可以写）- exceptfds : 检测发生异常的文件描述符的集合- timeout : 设置的超时时间1、timeout传入NULL，则select为阻塞状态，即需要等到监视文件描述符集合中某个文件描述符发生变化才会返回；-相当于无穷大的时间，一直等2、timeout置为0秒、0微秒，则select为非阻塞状态，不管文件描述符是否有变化，都立刻返回继续执行，文件无变化返回0，有变化返回一个正值；3、timeout置为大于0的值，即等待的超时时间，select在timeout时间内阻塞，超时时间之内有事件到来就返回，否则在超时后不管怎样一定返回，返回值同上述。 select函数在使用的时候，我们一般都会设置timeout时间，比如为3s，此时的select函数最多阻塞timeout时长的时间。在select函数的使用中，我们一般都会设置阻塞时长，使其在一定时间内处于阻塞状态。ps:阻塞是指调用select函数的线程或进程处于sleep状态，此时不占用CPU。struct timeval &#123;long tv_sec; /* seconds */long tv_usec; /* microseconds */&#125;;- NULL : 永久阻塞，直到检测到了文件描述符有变化- tv_sec = 0 tv_usec = 0， 不阻塞- tv_sec &gt; 0 tv_usec &gt; 0， 阻塞对应的时间- 返回值 :- -1 : 失败- &gt;0(n) : 检测的集合中有n个文件描述符发生了变化// 将参数文件描述符fd对应的标志位设置为0void FD_CLR(int fd, fd_set *set);// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1int FD_ISSET(int fd, fd_set *set);// 将参数文件描述符fd 对应的标志位，设置为1void FD_SET(int fd, fd_set *set);// fd_set一共有1024 bit, 全部初始化为0void FD_ZERO(fd_set *set); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/select.h&gt;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr)); // 监听 listen(lfd, 8); // 创建一个fd_set的集合，存放的是需要检测的文件描述符 fd_set rdset, tmp; FD_ZERO(&amp;rdset); FD_SET(lfd, &amp;rdset); int maxfd = lfd; while(1) &#123; tmp = rdset; // 调用select系统函数，让内核帮检测哪些文件描述符有数据 int ret = select(maxfd + 1, &amp;tmp, NULL, NULL, NULL); if(ret == -1) &#123; perror(&quot;select&quot;); exit(-1); &#125; else if(ret == 0) &#123; continue; &#125; else if(ret &gt; 0) &#123; // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变 if(FD_ISSET(lfd, &amp;tmp)) &#123; // 表示有新的客户端连接进来了 struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len); // 将新的文件描述符加入到集合中 FD_SET(cfd, &amp;rdset); // 更新最大的文件描述符 maxfd = maxfd &gt; cfd ? maxfd : cfd; &#125; for(int i = lfd + 1; i &lt;= maxfd; i++) &#123; if(FD_ISSET(i, &amp;tmp)) &#123; // 说明这个文件描述符对应的客户端发来了数据 char buf[1024] = &#123;0&#125;; int len = read(i, buf, sizeof(buf)); if(len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(len == 0) &#123; printf(&quot;client closed...\\n&quot;); close(i); FD_CLR(i, &amp;rdset); &#125; else if(len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(i, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; &#125; close(lfd); return 0;&#125; select函数的缺点: 单个进程所打开的FD是有限制的，通过 FD_SETSIZE 设置，默认1024 每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大 每次调用select都需要将进程加入到所有监视socket的等待队列，每次唤醒都需要从每个队列中移除 select函数在每次调用之前都要对参数进行重新设定，这样做比较麻烦，而且会降低性能 进程被唤醒后，程序并不知道哪些socket收到数据，还需要遍历一次 poll poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的 1234567891011121314151617181920#include &lt;poll.h&gt;struct pollfd &#123;int fd; /* 委托内核检测的文件描述符 */short events; /* 委托内核检测文件描述符的什么事件 */short revents; /* 文件描述符实际发生的事件 */&#125;;struct pollfd myfd;myfd.fd = 5;myfd.events = POLLIN | POLLOUT;int poll(struct pollfd *fds, nfds_t nfds, int timeout);- 参数：- fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合- nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1- timeout : 阻塞时长0 : 不阻塞-1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞&gt;0 : 阻塞的时长- 返回值：-1 : 失败&gt;0（n） : 成功,n表示检测到集合中有n个文件描述符发生变化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;poll.h&gt;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr)); // 监听 listen(lfd, 8); // 初始化检测的文件描述符数组 struct pollfd fds[1024]; for(int i = 0; i &lt; 1024; i++) &#123; fds[i].fd = -1; fds[i].events = POLLIN; &#125; fds[0].fd = lfd; int nfds = 0; while(1) &#123; // 调用poll系统函数，让内核帮检测哪些文件描述符有数据 int ret = poll(fds, nfds + 1, -1); if(ret == -1) &#123; perror(&quot;poll&quot;); exit(-1); &#125; else if(ret == 0) &#123; continue; &#125; else if(ret &gt; 0) &#123; // 说明检测到了有文件描述符的对应的缓冲区的数据发生了改变 if(fds[0].revents &amp; POLLIN) &#123; // 表示有新的客户端连接进来了 struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len); // 将新的文件描述符加入到集合中 for(int i = 1; i &lt; 1024; i++) &#123; if(fds[i].fd == -1) &#123; fds[i].fd = cfd; fds[i].events = POLLIN; break; &#125; &#125; // 更新最大的文件描述符的索引 nfds = nfds &gt; cfd ? nfds : cfd; &#125; for(int i = 1; i &lt;= nfds; i++) &#123; if(fds[i].revents &amp; POLLIN) &#123; // 说明这个文件描述符对应的客户端发来了数据 char buf[1024] = &#123;0&#125;; int len = read(fds[i].fd, buf, sizeof(buf)); if(len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(len == 0) &#123; printf(&quot;client closed...\\n&quot;); close(fds[i].fd); fds[i].fd = -1; &#125; else if(len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(fds[i].fd, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; &#125; close(lfd); return 0;&#125; epollselect和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。select和poll都只能工作在相对低效的LT模式下，而epoll同时支持LT和ET模式。当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能。epoll则将整个文件描述符集合维护在内核态，每次添加文件描述符的时候都需要执行一个系统调用。系统调用的开销是很大的，而且在有很多短期活跃连接的情况下，epoll可能会慢于select和poll由于这些大量的系统调用开销。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;sys/epoll.h&gt;/* 数据结构每一个epoll对象都有一个独立的eventpoll结构体用于存放通过epoll_ctl方法向epoll对象中添加进来的事件epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可*/struct eventpoll &#123; //红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件 struct rb_root rbr; //双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件 struct list_head rdlist;&#125;;​// API// 内核中间加一个 ep 对象，把所有需要监听的socket都放到ep对象中int epoll_create(int size); // epoll_ctl 负责把 socket 增加、删除到内核红黑树int epoll_ctl(int epfd, // 创建的ep对象 int op, // 操作类型 新增、删除等//操作类型：EPOLL_CTL_ADD：添加/EPOLL_CTL_MOD：修改/EPOLL_CTL_DEL：删除 int fd, // 要操作的对象 struct epoll_event *event // 事件 ); // epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程int epoll_wait( int epfd, //epoll实例对应的文件描述符 struct epoll_event * events, //传出参数，保存了发生了变化的文件描述符的信息 int maxevents, //第二个参数结构体数组的大小 int timeout //阻塞时间:0不阻塞;-1 : 阻塞，直到检测到fd数据发生变化，解除阻塞;&gt; 0 : 阻塞的时长（毫秒）);//返回值：成功，返回发送变化的文件描述符的个数 &gt; 0;失败 -1//一些变量类型的定义struct epoll_event &#123;uint32_t events; //Epoll events ，常见的Epoll检测事件：EPOLLIN/EPOLLOUT/EPOLLERR/EPOLLETepoll_data_t data; //一般只用到fd,内部结构如下&#125;;typedef union epoll_data &#123;void *ptr;int fd;uint32_t u32;uint64_t u64;&#125; epoll_data_t; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/epoll.h&gt;int main() &#123; // 创建socket int lfd = socket(PF_INET, SOCK_STREAM, 0); struct sockaddr_in saddr; saddr.sin_port = htons(9999); saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; // 绑定 bind(lfd, (struct sockaddr *)&amp;saddr, sizeof(saddr)); // 监听 listen(lfd, 8); // 调用epoll_create()创建一个epoll实例 int epfd = epoll_create(100); // 将监听的文件描述符相关的检测信息添加到epoll实例中 struct epoll_event epev; epev.events = EPOLLIN; epev.data.fd = lfd; epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;epev); struct epoll_event epevs[1024]; while(1) &#123; int ret = epoll_wait(epfd, epevs, 1024, -1); if(ret == -1) &#123; perror(&quot;epoll_wait&quot;); exit(-1); &#125; printf(&quot;ret = %d\\n&quot;, ret); for(int i = 0; i &lt; ret; i++) &#123; int curfd = epevs[i].data.fd; if(curfd == lfd) &#123; // 监听的文件描述符有数据达到，有客户端连接 struct sockaddr_in cliaddr; int len = sizeof(cliaddr); int cfd = accept(lfd, (struct sockaddr *)&amp;cliaddr, &amp;len); //重用了一下，没有再新建一个 epev.events = EPOLLIN; epev.data.fd = cfd; epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;epev); &#125; else &#123; if(epevs[i].events &amp; EPOLLOUT) &#123; continue; &#125; // 有数据到达，需要通信 char buf[1024] = &#123;0&#125;; int len = read(curfd, buf, sizeof(buf)); if(len == -1) &#123; perror(&quot;read&quot;); exit(-1); &#125; else if(len == 0) &#123; printf(&quot;client closed...\\n&quot;); epoll_ctl(epfd, EPOLL_CTL_DEL, curfd, NULL); close(curfd); &#125; else if(len &gt; 0) &#123; printf(&quot;read buf = %s\\n&quot;, buf); write(curfd, buf, strlen(buf) + 1); &#125; &#125; &#125; &#125; close(lfd); close(epfd); return 0;&#125; 补充EPOLL事件EPOLLRDHUP (since Linux 2.6.17)挂起事件 Stream socket peer closed connection, or shut down writing half of connection. (This flag is especially useful for writing simple code to detect peer shutdown when using Edge Triggered monitoring.) 这是在Linux2.6.17之后新加入的一个特性。在之前的版本中，epoll监听的socket对端如果调用close主动关闭连接，epoll在这条连接上会检测到一个EPOLLIN事件，并交给上层程序去执行读。但是读一个关闭了写入端的socket通信来说，调用read函数会返回一个错误号。一般情况下我们是通过if( read(fd, readbuff, sizeof(readbuff) &lt; 0)来判断read函数调用是否会发生错误,为了进一步提高程序的效率，我们可以在底层就将对端关闭连接这种情况处理了，所以自Linux2.6.17之后新加入了一个EPOLLRDHUP 宏，通过将epoll事件设置为event.events = EPOLLIN | EPOLLRDHUP便能在底层进行处理也就是说这样可以减少一次系统调用，当客户端发起close之后，服务器端不需要再调用read来判断是否close，可以根据发生了EPOLLRDHUP直接closeread/write send/recv http://c.biancheng.net/view/2346.html read/recv以及write/send的区别在于,recv和send多了一个参数，可以实现读写控制，多的那个参数为0，就和read/write一样 123#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;ssize_t send(int sockfd, const void *buf, size_t len, int flags); 当套接字发送缓冲区变满时，send通常会阻塞，除非套接字设置为非阻塞模式，当缓冲区变满时，返回EAGAIN或者EWOULDBLOCK错误，此时可以调用select函数来监视何时可以发送数据。 EPOLLONESHOT设置EPOLLONESHOT可以保证一个socket只被一个线程占用，避免了多个线程收到了一个socket在前后时间发来的不同数据，造成数据混乱，程序运行出错的情况。EPOLLONESHOT的作用是对加入到epollfd中的socket，该socket日后接收到数据后，只会响应一次，无论日后有多少数据再次发来，在epoll_wait中都不再对这个socket作出响应，相当于说，某次循环中epoll_wait唤醒该事件fd后，就会从注册中删除该fd,也就是说以后不会epollfd的表格中将不会再有这个fd,也就不会出现多个线程同时处理一个fd的情况。读出数据只是工作的一半，还需要将处理后的数据写到对端，但由于注册了EPOLLONESHOT，EPOLLIN的事件被唤醒后该fd已经从epollfd中删去，所以对于尚未完成的工作，要重新注册，比如这里，重新注册fd为EPOLL|EPOLLET|EPOLLONESHOT。EPOLLONESHOT是必须的，因为要保证向对端写入时只有一个线程在该fd上工作。","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"非线性数据结构（树）","slug":"非线性数据结构(树)","date":"2022-12-28T16:00:00.000Z","updated":"2023-01-06T12:25:00.849Z","comments":true,"path":"2022/12/29/非线性数据结构(树)/","link":"","permalink":"http://example.com/2022/12/29/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%A0%91)/","excerpt":"","text":"刷题备注注意区分几种常见容器的操作vectorqueue单端队列 queueq；创建一个int型空队列qq.empty（）；判断队列是否为空，为空返回trueq.push（s）；将变量s从队尾入队q.pop（）；将队头元素弹出q.front（）；只返回队头元素q.back（）；只返回队尾元素q.size（）返回队列中元素个数queue从队首弹出，先入先出 deque双端队列的操作（可以在队头队尾进行入队出队操作） deque dq；创建一个数双端队列dqdq.empty（）；判断队列是否为空，为空返回truedq.push_front（s）；将s从队头入队dq.push_back（s）；将s从队尾入队，和普通队列方式一样dq.front（）；只返回队头元素dq.back（）；只返回队尾元素dq.pop_front（）；将队头元素弹出dq.pop_back；将队尾元素弹出dq.clear（）；将队列清空 相关知识&emsp;&emsp;如果数据是固定不动的，则查找数据称为静态查找（没有插入和删除操作，只有查找），如果数据会发生变化，则是动态查找。对于静态查找，可以是顺序查找，则时间复杂度为O(N)，或者二分查找，元素本身是有序排列的，时间复杂度为O(logN)，二分查找时，定义了pre,end,mid。每次查找后，end = mid - 1,或者pre = mid +1;不能直接等于mid，这样会出现死循环。根据二分查找的想法，构造了与之类似的数据结构————树，因此查找次数不会超过数的层数，也即是O(logN)。&emsp;&emsp;实现时，可以通过链表实现，但如果链表指向子树，对于大部分比较稀疏或者度数较大的树，会造成很大的浪费，因此可以将链表设置为2个指针，分别指向兄弟节点和子节点（下图左）。对于二叉树，则可以直接将两个指针分别指向其左右子节点（下图右）。 定义与实现&emsp;&emsp;树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。&emsp;&emsp;一棵有n个节点的树，一共有n-1条边，根节点没有，其中节点的子树个数称为结点的度，一个树的度是节点中最大的度数，二叉树的度数为2，叶结点的度数为0。假设定义$n_2$为度数为2的结点数，$n_0$为叶结点树，则$n_2+1=n_0$，因为$2n_2+n_1(每个结点下的边数)=n_0+n_1+n_2-1(节点数-1)$。&emsp;&emsp;二叉树第$i$层，最多有$2^{i-1}$个结点，层数为i的二叉树，最多有$2^i-1$个结点。&emsp;&emsp;完美二叉树（满二叉树），是指每层都是满的二叉树，仅最后一层不满的且缺少的结点连续，都在右侧时为完全二叉树，其结点的标号和完美二叉树一致。平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。 1234567891011121314151617class TreeNode: def __init__(self, x): self.val = x # 节点值 self.left = None # 左子节点 self.right = None # 右子节点# 初始化节点 n1 = TreeNode(3) # 根节点 root n2 = TreeNode(4) n3 = TreeNode(5) n4 = TreeNode(1) n5 = TreeNode(2) # 构建引用指向 n1.left = n2 n1.right = n3 n2.left = n4 n2.right = n5 123456struct TreeNode&#123;int val;TreeNode *left;TreeNode *right;TreeNode(int x): val(x),left(NULL),right(NULL) &#123;&#125;&#125; 树的遍历&emsp;&emsp;根据遍历根节点的顺序，分为前序，中序和后续遍历三种。通常使用递归实现，三种遍历的路径其实是一致的，区别在于每个节点输出的时刻，前序在第一次遇到该节点时即输出，中序在第二次，后序在第三次。除此之外，还有层次遍历，即从上到下，从左到右。 前中后序遍历迭代法-中序遍历，访问的顺序和处理的顺序不一样，先定义指针cur代表遍历访问的结点，当没有左结点的时候，开始处理，即if和else判断是继续向左遍历，还是开始处理，开始处理的时候，栈顶的元素就是要处理的元素。1234567891011121314151617181920212223242526272829303132333435363738//迭代法class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode *&gt; st; TreeNode *cur = root; while(cur!=NULL || !st.empty())&#123; if(cur)&#123; st.push(cur); cur = cur-&gt;left; &#125; else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return result; &#125;&#125;;//递归法，比较简单，注意引用格式class Solution &#123;public: void zhongxu(TreeNode *root,vector&lt;int&gt; &amp;res)&#123; if(root==NULL) return; zhongxu(root-&gt;left,res); res.push_back(root-&gt;val); zhongxu(root-&gt;right,res); &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; zhongxu(root,result); return result; &#125;&#125;;后序遍历的迭代法，注意输出结果反转加入顺序中-&gt;右-&gt;左，（入栈顺序是左右），反转reverse(左右中)前序遍历，输出顺序中-&gt;左-&gt;右，（入栈顺序是右左）123456789101112131415161718192021222324252627282930313233343536373839//前序，先右后左class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） &#125; return result; &#125;&#125;;//后序，先左后右，输出反转class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 &#125; reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; &#125;&#125;; 二叉搜索树&emsp;&emsp;根据二分法的启示，建立一种二叉搜索树，其非空左子树的所有键值小于其根结点的键值，右子树相反，且左右子树都是二叉搜索树。应该实现插入，删除和查找这些基本操作。由于其内部顺序，其最小值为最左侧的结点，最大值为最右侧的结点。&emsp;&emsp;原因是，对于完全二叉树，如果有右结点，则一定有左结点，但是可以仅有左结点，没有右结点，所以，最小值一定是叶节点，因为如果不是，必有左结点，即必有更小的值，但最大值不一定，其可以是有左结点的一个结点。 L98 验证二叉搜索树递归判断的时候注意，要求是所有右子树的节点值都大于父结点，但是递归判断的时候，只是满足当前节点，并不能保证子树往下的节点，所以会出问题。二叉搜索树的中序遍历是递增的，结合这个特点，可以采用递归法，也就是中序遍历的递归的时候，可以在每次往res增加，即遍历时进行判断，因为中序遍历是递增的，所以每次push_back的数，都是递增的，那么可以把这一句改为一个判断语句123456789101112131415class Solution &#123;public: void zhongxu(TreeNode *root,vector&lt;int&gt; &amp;res)&#123; if(root==NULL) return; zhongxu(root-&gt;left,res); res.push_back(root-&gt;val);//这一句，每次都是递增的 zhongxu(root-&gt;right,res); &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; zhongxu(root,result); return result; &#125;&#125;;即，用一个变量保存每次增加的值，起始化为一个特别小的数，longlong类型,每次push_back的时候，如果比原来的大，就是符合题意得，否则，证明不是递增的，就返回false，只是把递归代码改了一下哈。 123456789101112131415class Solution &#123;public: long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值 bool isValidBST(TreeNode* root) &#123; if (root == NULL) return true; bool left = isValidBST(root-&gt;left); // 中序遍历，验证遍历的元素是不是从小到大 if (maxVal &lt; root-&gt;val) maxVal = root-&gt;val; else return false; bool right = isValidBST(root-&gt;right); return left &amp;&amp; right; &#125;&#125;; 剑指 Offer 33. 二叉搜索树的后序遍历序列&emsp;&emsp;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。&emsp;&emsp;假如是一个二叉搜索树，则根据左结点-右结点-根节点的后序遍历顺序，最后一个元素为根节点，且小于所有的右结点，因此从数组最左边开始遍历，一旦找到大于根结点的值（代码中用q表示），则从当前位置到根节点之前（postorder[q,j-1]），应该都大于根结点，同时其左右子树（postorder[i,q-1]，postorder[q,j-1]）再进行递归。 方法1：递归：时间复杂度$O(N^2)$ ,每次递归的时候减去一个根节点，因此递归占用$O(N)$ ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用$O(N)$。空间复杂度$O(N)$:最差情况下（即当树退化为链表），递归深度将达到N。 12345678910111213141516class Solution: def verifyPostorder(self, postorder: List[int]) -&gt; bool: def judge(i,j): if i&gt;=j: return True p = i while postorder[p]&lt;postorder[j]: p+=1 q = p while postorder[p]&gt;postorder[j]: p+=1 if p==j: return judge(i,q-1) and judge(q,j-1) else: return False return judge(0,len(postorder)-1) 方法2：辅助栈，时间复杂度降到O(N)&emsp;&emsp;在后序遍历时，在遍历完右结点后会访问根节点，所以如果是完全二叉树，必然会出现一个数值减小的过程，但是必须从后往前看，因为从前往后看，树的结构不清楚，会比较乱，那么从后往前看，每次数值增大都是从根节点到右结点的过程，设计一个栈进行该操作，当出现数值减小时，说明遇到了左结点，12345678910111213141516171819202122232425262728```## 层序遍历for循环是精髓，保证了每次是处理一层，类似的变种有[很多题](https://www.programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)，都大差不差，注意往队列中添加元素前，判断是否为空。```cppclass Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) &#123; TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(vec); &#125; return result; &#125;&#125;; 翻转二叉树这个题，其实就是对于每个节点，交换一下他的左右节点，所以其实不管是深度优先还是广度优先都可以，但是不要用中序遍历，因为有的节点会被遍历两次为什么深度遍历用栈不用队列，因为栈是先进后出，需要一次性走到头123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//递归实现,注意那个交换要写class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if (root == NULL) return root; swap(root-&gt;left, root-&gt;right); // 中 invertTree(root-&gt;left); // 左 invertTree(root-&gt;right); // 右 return root; &#125;&#125;;//层序遍历实现，这个和上面的区别就是没有for循环，因为不需要按层处理class Solution &#123; public:TreeNode* invertTree(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); while (!que.empty()) &#123; int size = que.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode* node = que.front(); que.pop(); swap(node-&gt;left, node-&gt;right); // 节点处理 if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;；//深度遍历，用栈class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(root==NULL) return root; stack &lt;TreeNode *&gt; st; TreeNode *cur = root; if(root) st.push(cur); while(!st.empty())&#123; cur = st.top(); st.pop(); swap(cur-&gt;left,cur-&gt;right); if(cur-&gt;right) st.push(cur-&gt;right); if(cur-&gt;left) st.push(cur-&gt;left); &#125; return root; &#125;&#125;; 对称二叉树递归啊，递归1234567891011121314151617181920212223242526272829class Solution &#123;public: bool compare(TreeNode* left,TreeNode* right)&#123; if(left==NULL &amp;&amp; right==NULL) return true; if(left!=NULL &amp;&amp; right==NULL) return false; if(left==NULL &amp;&amp; right!=NULL) return false; if(left-&gt;val!=right-&gt;val) return false; return compare(left-&gt;left,right-&gt;right)&amp;&amp;compare(left-&gt;right,right-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; if(root==NULL) return true; return compare(root-&gt;left,root-&gt;right); &#125;&#125;;//或者更简洁一点class Solution &#123;public: bool check(TreeNode *p, TreeNode *q) &#123; if (!p &amp;&amp; !q) return true; if (!p || !q) return false; return p-&gt;val == q-&gt;val &amp;&amp; check(p-&gt;left, q-&gt;right) &amp;&amp; check(p-&gt;right, q-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; return check(root, root); &#125;&#125;; int 和char转换(参考博客)[https://blog.csdn.net/zou_albert/article/details/107138404]char只有一个字节，int有4个，所以直接转换肯定会出问题,int转char，只能是0-9范围内，转换方法：char c = i+’0’;这个表示相对于’0’的ASCII码（80）增加了多少，比如i=2,那么c就是将’0’的ASCII这个int+2的结果（82）转换为字符，自然就是’2’,但是如果大于9，那么就超过了数字的范围，会变成其他字符。int不可以强制类型转换为string; vector初始化(参考1)[https://blog.csdn.net/qq_53914247/article/details/122757045](参考2)[https://blog.csdn.net/zimojiang/article/details/125060384]12345vector&lt;int&gt; v1(10); //v1有10个元素，每个数的值都是0vector&lt;int&gt; v2&#123;10&#125;; //v2有1个元素，值是10 vector&lt;int&gt; v3(10,1); //v3有10个元素，每个数的值都是1vector&lt;int&gt; v4&#123;10,1&#125;; //v4有2个元素，值分别是10和1利用迭代器进行切片迭代器的值需要取值符号 *a.begin() 误区1：12345678//这种做法以及类似的做法都是错误的。刚开始我也犯过这种错误，后来发现，下标只能用于获取已存在的元素，而现在的a[i]还是空的对象vector&lt;int&gt; a;for(int i=0;i&lt;10;i++) a[i]=i;//不能用等号，即a=(b.begin(),b.begin+3)，这样是不对的vector&lt;int&gt; a(b.begin(),b.begin()+3);//或者用assigna.assign(b.begin(),b.begin()+3)","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"Linux项目3","slug":"牛客项目3","date":"2022-12-28T16:00:00.000Z","updated":"2023-01-17T06:40:00.033Z","comments":true,"path":"2022/12/29/牛客项目3/","link":"","permalink":"http://example.com/2022/12/29/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE3/","excerpt":"","text":"重点 线程创建，分离，终止 线程与进程的区别，线程同步，互斥锁，读写锁 条件变量，信号量，生产者消费者模型 线程概述与进程（process）类似，线程（thread）是允许应用程序并发执行多个任务的一种机制。一个进程可以包含多个线程。同一个程序中的所有线程均会独立执行相同程序，且共享同一份全局内存区域，其中包括初始化数据段、未初始化数据段，以及堆内存段。（传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程）进程是 CPU 分配资源的最小单位，线程是操作系统调度执行的最小单位。线程是轻量级的进程（LWP：Light Weight Process），在 Linux 环境下线程的本质仍是进程。查看指定进程的 LWP 号：ps –Lf pid 线程和进程的区别： 进程间的信息难以共享。由于除去只读代码段外，父子进程并未共享内存，因此必须采用一些进程间通信方式，在进程间进行信息交换。 调用 fork() 来创建进程的代价相对较高，即便利用写时复制技术，仍然需要复制诸如内存页表和文件描述符表之类的多种进程属性，这意味着 fork() 调用在时间上的开销依然不菲。 线程之间能够方便、快速地共享信息。只需将数据复制到共享（全局或堆）变量中即可。 创建线程比创建进程通常要快 10 倍甚至更多。线程间是共享虚拟地址空间的，（每个线程被分配各自独有的空间）无需采用写时复制来复制内存，也无需复制页表。 共享资源 进程 ID 和父进程 ID 进程组 ID 和会话 ID 用户 ID 和 用户组 ID 文件描述符表 信号处置 文件系统的相关信息：文件权限掩码（umask）、当前工作目录 虚拟地址空间（除栈、.text，这些每个线程自己有自己的独有空间） 非共享资源 线程 ID 信号掩码 线程特有数据 error 变量 实时调度策略和优先级 栈，本地变量和函数的调用链接信息 系统调用一般情况下,main函数所在的线程我们称之为主线程（main线程），其余创建的线程为子线程。程序中默认只有一个进程，fork()函数调用，产生2个进程。程序中默认只有一个线程，pthread_create()函数调用，产生2个线程。编译时需要加 -pthread 线程操作12345678910//创建线程int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);//终止线程void pthread_exit(void *retval);//链接已终止线程int pthread_join(pthread_t thread, void **retval);//分离线程int pthread_detach(pthread_t thread);//取消线程int pthread_cancel(pthread_t thread); 创建线程1int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); 功能：创建一个子线程参数： thread：传出参数，线程创建成功后，子线程的线程ID被写到该变量中。attr : 设置线程的属性，一般使用默认值，NULLstart_routine : 函数指针，这个函数是子线程需要处理的逻辑代码,返回值和参数列表都是void *类型arg : 给第三个参数使用，传参 返回值：成功返回0；失败返回错误号。这个错误号和之前errno不太一样。获取错误号的信息： char * strerror(int errnum); 123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void * callback(void * arg) &#123; printf(&quot;child thread...\\n&quot;); printf(&quot;arg value: %d\\n&quot;, *(int *)arg); return NULL;&#125;int main() &#123; pthread_t tid; int num = 10; // 创建一个子线程 int ret = pthread_create(&amp;tid, NULL, callback, (void *)&amp;num); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; sleep(1); return 0; // exit(0);&#125; 终止线程12345678910void pthread_exit(void *retval);//功能：终止一个线程，在哪个线程中调用，就表示终止哪个线程//参数：retval需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到。pthread_t pthread_self(void);//功能：获取当前的线程的线程IDint pthread_equal(pthread_t t1, pthread_t t2);//功能：比较两个线程ID是否相等//不同的操作系统，pthread_t类型的实现不一样，有的是无符号的长整型，有的是使用结构体去实现的。 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;void * callback(void * arg) &#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); return NULL; // pthread_exit(NULL);&#125; int main() &#123; // 创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; // 主线程 for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid ,pthread_self()); // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。 pthread_exit(NULL); printf(&quot;main thread exit\\n&quot;); return 0; // exit(0);&#125; 链接已终止的线程1int pthread_join(pthread_t thread, void **retval); 功能：和一个已经终止的线程进行连接用来回收子线程的资源，这个函数是阻塞函数，调用一次只能回收一个子线程，一般在主线程中使用参数： thread：需要回收的子线程的IDretval: 接收子线程退出时的返回值 返回值：成功返回0, 失败返回错误号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;int value = 10;void * callback(void * arg) &#123; printf(&quot;child thread id : %ld\\n&quot;, pthread_self()); // sleep(3); // return NULL; // int value = 10; // 局部变量 pthread_exit((void *)&amp;value); // return (void *)&amp;value;&#125; int main() &#123; // 创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; // 主线程 for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid ,pthread_self()); // 主线程调用pthread_join()回收子线程的资源 int * thread_retval; ret = pthread_join(tid, (void **)&amp;thread_retval); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error : %s\\n&quot;, errstr); &#125; printf(&quot;exit data : %d\\n&quot;, *thread_retval); printf(&quot;回收子线程资源成功！\\n&quot;); // 让主线程退出,当主线程退出时，不会影响其他正常运行的线程。 pthread_exit(NULL); return 0; &#125; 分离线程1int pthread_detach(pthread_t thread); 功能：分离一个线程。被分离的线程在终止的时候，会自动释放资源返回给系统。 不能多次分离，会产生不可预料的行为。 不能去连接一个已经分离的线程，会报错。 参数：需要分离的线程的ID返回值：成功：0,失败：返回错误号 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void * callback(void * arg) &#123; printf(&quot;chid thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main() &#123; // 创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; // 输出主线程和子线程的id printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); // 设置子线程分离,子线程分离后，子线程结束时对应的资源就不需要主线程释放 ret = pthread_detach(tid); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error2 : %s\\n&quot;, errstr); &#125; // 设置分离后，对分离的子线程进行连接 pthread_join() // ret = pthread_join(tid, NULL); // if(ret != 0) &#123; // char * errstr = strerror(ret); // printf(&quot;error3 : %s\\n&quot;, errstr); // &#125; pthread_exit(NULL); return 0;&#125; 区别 线程的分离属性(detach属性):资源释放操作。在线程结束后，由系统释放资源;线程的连接属性(join属性):资源释放操作。由一个线程监督该执行线程，结束后释放资源。 线程取消1int pthread_cancel(pthread_t thread); 功能：取消线程（让线程终止）取消某个线程，可以终止某个线程的运行，但是并不是立马终止，而是当子线程执行到一个取消点，线程才会终止。取消点：系统规定好的一些系统调用，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void * callback(void * arg) &#123; printf(&quot;chid thread id : %ld\\n&quot;, pthread_self()); for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;child : %d\\n&quot;, i); &#125; return NULL;&#125;int main() &#123; // 创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, NULL, callback, NULL); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); //这个printf就是一个系统调用，执行到这一步会取消 &#125; // 取消线程 pthread_cancel(tid); for(int i = 0; i &lt; 5; i++) &#123; printf(&quot;%d\\n&quot;, i); &#125; // 输出主线程和子线程的id printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); pthread_exit(NULL); return 0;&#125; 线程属性12345678int pthread_attr_init(pthread_attr_t *attr);//初始化线程属性变量int pthread_attr_destroy(pthread_attr_t *attr);//释放线程属性的资源int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);//获取线程分离的状态属性int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);//设置线程分离的状态属性 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;void * callback(void * arg) &#123; printf(&quot;chid thread id : %ld\\n&quot;, pthread_self()); return NULL;&#125;int main() &#123; // 创建一个线程属性变量 pthread_attr_t attr; // 初始化属性变量 pthread_attr_init(&amp;attr); // 设置属性 pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED); // 创建一个子线程 pthread_t tid; int ret = pthread_create(&amp;tid, &amp;attr, callback, NULL); if(ret != 0) &#123; char * errstr = strerror(ret); printf(&quot;error1 : %s\\n&quot;, errstr); &#125; // 获取线程的栈的大小 size_t size; pthread_attr_getstacksize(&amp;attr, &amp;size); printf(&quot;thread stack size : %ld\\n&quot;, size); // 输出主线程和子线程的id printf(&quot;tid : %ld, main thread id : %ld\\n&quot;, tid, pthread_self()); // 释放线程属性资源 pthread_attr_destroy(&amp;attr); pthread_exit(NULL); return 0;&#125; 线程同步线程的主要优势在于，能够通过全局变量来共享信息。不过，这种便捷的共享是有代价的：必须确保多个线程不会同时修改同一变量，或者某一线程不会读取正在由其他线程修改的变量。临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作(不可以被分割执行的操作，必须执行完)，也就是同时访问同一共享资源的其他线程不应中断该片段的执行。线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。这样会降低效率（只针对操作临界区的代码，不是所有代码），但是可以保证数据安全性。 互斥量为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。互斥量有两种状态：已锁定（locked）和未锁定（unlocked）。任何时候，至多只有一个线程可以锁定该互斥量。试图对已经锁定的某一互斥量再次加锁，将可能阻塞线程或者报错失败，具体取决于加锁时使用的方法。一旦线程锁定互斥量，随即成为该互斥量的所有者，只有所有者才能给互斥量解锁。一般情况下，对每一共享资源（可能由多个相关变量组成）会使用不同的互斥量，每一线程在访问同一资源时将采用如下协议： 针对共享资源锁定互斥量 访问共享资源 对互斥量解锁 如果多个线程试图执行这一块代码（一个临界区），事实上只有一个线程能够持有该互斥量（其他线程将遭到阻塞），即同时只有一个线程能够进入这段代码区域，1234567//互斥量的类型 pthread_mutex_tint pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);//初始化互斥量int pthread_mutex_destroy(pthread_mutex_t *mutex);//释放互斥量的资源int pthread_mutex_lock(pthread_mutex_t *mutex);//加锁，阻塞的，如果有一个线程加锁了，那么其他的线程只能阻塞等待，直到加锁成功int pthread_mutex_trylock(pthread_mutex_t *mutex);//尝试加锁，如果加锁失败，不会阻塞，会直接返回。int pthread_mutex_unlock(pthread_mutex_t *mutex);//解锁 参数 ： mutex ： 需要初始化的互斥量变量attr ： 互斥量相关的属性，NULLrestrict : C语言的修饰符，被修饰的指针，不能由另外的一个指针进行操作。pthread_mutex_t restrict mutex = xxx;pthread_mutex_t mutex1 = mutex;//用mutex1指向mutex,不可以执行操作，因为被restrict限制 返回值：成功返回0，失败返回错误号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;// 全局变量，所有的线程都共享这一份资源。int tickets = 1000;// 创建一个互斥量pthread_mutex_t mutex;void * sellticket(void * arg) &#123; // 卖票 while(1) &#123; // 加锁 pthread_mutex_lock(&amp;mutex); if(tickets &gt; 0) &#123; usleep(6000); printf(&quot;%ld 正在卖第 %d 张门票\\n&quot;, pthread_self(), tickets); tickets--; &#125;else &#123; // 解锁 pthread_mutex_unlock(&amp;mutex); break; &#125; // 解锁 pthread_mutex_unlock(&amp;mutex); &#125; return NULL;&#125;int main() &#123; // 初始化互斥量 pthread_mutex_init(&amp;mutex, NULL); // 创建3个子线程 pthread_t tid1, tid2, tid3; pthread_create(&amp;tid1, NULL, sellticket, NULL); pthread_create(&amp;tid2, NULL, sellticket, NULL); pthread_create(&amp;tid3, NULL, sellticket, NULL); // 回收子线程的资源,阻塞 pthread_join(tid1, NULL); pthread_join(tid2, NULL); pthread_join(tid3, NULL); pthread_exit(NULL); // 退出主线程 // 释放互斥量资源 pthread_mutex_destroy(&amp;mutex); return 0;&#125; 死锁有时，一个线程需要同时访问两个或更多不同的共享资源，而每个资源又都由不同的互斥量管理。当超过一个线程加锁同一组互斥量时，就有可能发生死锁。两个或两个以上的进程在执行过程中，因争夺共享资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。 死锁的几种场景： 忘记释放锁 重复加锁 多线程多锁，抢占锁资源 读写锁当有一个线程已经持有互斥锁时，互斥锁将所有试图进入临界区的线程都阻塞住。但是考虑一种情形，当前持有互斥锁的线程只是要读访问共享资源，而同时有其它几个线程也想读取这个共享资源，但是由于互斥锁的排它性，所有其它线程都无法获取锁，也就无法读访问共享资源了，但是实际上多个线程同时读访问共享资源并不会导致问题。在对数据的读写操作中，更多的是读操作，写操作较少，例如对数据库数据的读写应用。为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。 读写锁的特点： 如果有其它线程读数据，则允许其它线程执行读操作，但不允许写操作。 如果有其它线程写数据，则其它线程都不允许读、写操作。 写是独占的，写的优先级高 12345678读写锁的类型 pthread_rwlock_tint pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); 生产者消费者模型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// 创建一个互斥量pthread_mutex_t mutex;struct Node&#123; int num; struct Node *next;&#125;;// 头结点struct Node * head = NULL;void * producer(void * arg) &#123; // 不断的创建新的节点，添加到链表中 while(1) &#123; pthread_mutex_lock(&amp;mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node, num : %d, tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void * customer(void * arg) &#123; while(1) &#123; pthread_mutex_lock(&amp;mutex); // 保存头结点的指针 struct Node * tmp = head; // 判断是否有数据 if(head != NULL) &#123; // 有数据 head = head-&gt;next; printf(&quot;del node, num : %d, tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; else &#123; // 没有数据 pthread_mutex_unlock(&amp;mutex); &#125; &#125; return NULL;&#125;int main() &#123; pthread_mutex_init(&amp;mutex, NULL); // 创建5个生产者线程，和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i &lt; 5; i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for(int i = 0; i &lt; 5; i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while(1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_exit(NULL); return 0;&#125; 条件变量条件变量的类型 pthread_cond_t不是锁，可以控制线程的阻塞和非阻塞 1234567891011int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr);//初始化int pthread_cond_destroy(pthread_cond_t *cond);//释放int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);//等待，调用了该函数，线程会阻塞。//第二个参数传入一个互斥锁，当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);//等待多长时间，调用了这个函数，线程会阻塞，直到指定的时间结束。int pthread_cond_signal(pthread_cond_t *cond);// 唤醒一个或者多个等待的线程int pthread_cond_broadcast(pthread_cond_t *cond);//唤醒所有的等待的线程 pthread_cond_wait传入一个互斥锁目的是：因为条件变量也是临界变量，两个线程都是会去操作的。为了保证线程安全，我们对于临界变量的访问的时候，就是需要先加锁的。 调用条件变量通知函数唤醒所有的等待线程的话，很有可能导致临界资源被多个线程重复处理，甚至导致错误的发生，因此为了方便，每个线程被唤醒返回pthread_cond_wait()函数时，一般会对互斥锁加锁，这样其他被唤醒的线程只能阻塞等待此线程释放该互斥锁，从而实现互斥的对于临界资源的访问。 当此线程处理完临界资源后会在此调用pthread_cond_wait()函数，将该线程挂起至等待条件变量队列，然后释放互斥锁，让其他线程被唤醒继续处理该临界资源。即调用wait时解锁，让其他线程可以使用临界资源，返回wait后，加锁，防止被重复处理。 互斥锁和条件量a) 如果对一个共享变量需要多线程操作的时候，我们就需要用到锁。如果我们对这个共享变量不仅仅是需要简单的数值计算（例如加法和减法），而是需要这个共享变量达到某种状态之后我们进行才能进行别的操作。此时如果完成这个需求的话，我们就需要使用条件变量。当然，你使用锁也是可以完成的，但是效率不高。因为你要么不断的轮询来查看这个共享变量的状态是否达到要求，但这显然就白白耗费了CPU资源；要么采用先睡眠一段时间，然后查看该变量的状态。但是显然这个睡眠的时间是不好确定的。所以对于这种情况，我们需要的就是：进程直接阻塞，但是这个变量的状态出现我想要的之后，别人来将我唤醒。这样子就可以最大的节省CPU资源和进程效率的最大化。这点上面的例子可以说明这点了。 b) 因为条件变量所关心的状态必然也是一个共享变量所引起的。因为如果这个状态不是由共享变量引起的，那么说明这个变量只有你这个线程可以访问。那么我就不需要对他进行互斥访问了，那么我就不需要轮询了。因为这个变量只有我自己一个线程能够改动，那我肯定知道什么时候他达到要求了。 c) 正因为这个条件变量所关心的也是一个共享变量，所以在访问它之前肯定要加锁。而我们肯定是先while()访问，发现没有达到状态，所以要进入阻塞。而在while之前，我们就需要加锁。所以，也就是说，因为在采用pthread_cond_wait()之前，都是需要对一个状态量进行判断的，而这个状态量肯定又是一个共享变量。而对共享变量的访问是需要加锁的，所以形成了我们必须要在调用pthread_cond_wait()之前给互斥锁加锁。如果你还是有疑惑，你可以看看你自己之前写的需要使用条件变量的代码上，是不是调用pthread_cond_wait()之前，都需要判断一个状态量，而这个状态量又肯定是一个共享变量。通过你自己写的代码来验证自己的猜想，肯定是具有说服力的。 pthread_cond_wait()的分解1）pthread_cond_wait所做的第一件事就是同时对传入的互斥对象mymutex解锁(这样其它线程就可以修改共享对象了，不然一直wait不到操作之前不要忘记加锁哦)。2）阻塞该线程3）调用pthread_cond_wait的线程被叫醒之后,将重新给mymutex加锁之后才返回 个人理解就是，条件量是一个共享变量，所以我们访问前一定要先加锁，不然会被其他线程修改，进入wait后会先释放锁，这样其他线程才能访问修改这个条件量，并唤醒该wait，等wait被唤醒后，重新加锁继续执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;// 创建一个互斥量pthread_mutex_t mutex;// 创建条件变量pthread_cond_t cond;struct Node&#123; int num; struct Node *next;&#125;;// 头结点struct Node * head = NULL;void * producer(void * arg) &#123; // 不断的创建新的节点，添加到链表中 while(1) &#123; pthread_mutex_lock(&amp;mutex); struct Node * newNode = (struct Node *)malloc(sizeof(struct Node)); newNode-&gt;next = head; head = newNode; newNode-&gt;num = rand() % 1000; printf(&quot;add node, num : %d, tid : %ld\\n&quot;, newNode-&gt;num, pthread_self()); // 只要生产了一个，就通知消费者消费 pthread_cond_signal(&amp;cond); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; return NULL;&#125;void * customer(void * arg) &#123; while(1) &#123; pthread_mutex_lock(&amp;mutex); // 保存头结点的指针 struct Node * tmp = head; // 判断是否有数据 if(head != NULL) &#123; // 有数据 head = head-&gt;next; printf(&quot;del node, num : %d, tid : %ld\\n&quot;, tmp-&gt;num, pthread_self()); free(tmp); pthread_mutex_unlock(&amp;mutex); usleep(100); &#125; else &#123; // 没有数据，需要等待 // 当这个函数调用阻塞的时候，会对互斥锁进行解锁，当不阻塞的，继续向下执行，会重新加锁。 pthread_cond_wait(&amp;cond, &amp;mutex); pthread_mutex_unlock(&amp;mutex); &#125; &#125; return NULL;&#125;int main() &#123; pthread_mutex_init(&amp;mutex, NULL); pthread_cond_init(&amp;cond, NULL); // 创建5个生产者线程，和5个消费者线程 pthread_t ptids[5], ctids[5]; for(int i = 0; i &lt; 5; i++) &#123; pthread_create(&amp;ptids[i], NULL, producer, NULL); pthread_create(&amp;ctids[i], NULL, customer, NULL); &#125; for(int i = 0; i &lt; 5; i++) &#123; pthread_detach(ptids[i]); pthread_detach(ctids[i]); &#125; while(1) &#123; sleep(10); &#125; pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond); pthread_exit(NULL); return 0;&#125; 信号量n&gt;0：当前有可用资源，可用资源数量为nn=0：资源都被占用，可用资源数量为0n","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"Linux项目2","slug":"牛客项目2","date":"2022-12-15T16:00:00.000Z","updated":"2023-01-01T05:32:34.254Z","comments":true,"path":"2022/12/16/牛客项目2/","link":"","permalink":"http://example.com/2022/12/16/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE2/","excerpt":"","text":"重点 进程状态转换 进程创建fork，exec函数族 孤儿进程，僵尸进程，解决方法：wait,waitpid 进程间通信方式：管道，内存映射，信号 守护进程进程概述程序程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程： 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） 机器语言指令：对程序算法进行编码。 程序入口地址：标识程序开始执行时的起始指令位置。 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。 进程进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。程序不占用系统CPU，内存等资源，进程需要占用 可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。 单道&amp;多道程序设计单道程序，即在计算机内存中只允许一个的程序运行。多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行（宏观上是同时进行的，但实际上每个时刻只能有一个程序在执行），两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 进程的状态进程状态反映执行过的变化。 这些随着和外界条件而转换进程状态反映执行过的变化。三态模型：就绪态，运行态，阻塞态。五态模型：新建态、就绪态，运行态，阻塞态，终止态。 阻塞态不能直接转换到就绪态，和其他进程抢夺资源再进入运行态 图中没有画出，但就绪态和阻塞态可以直接到达终止态，进入终止态之后就不能再执行了，会释放用户区的数据 查看进程信息命令： ps ajx/auxPID进程ID,PPID父进程ID，PGID组ID，SID会话ID 创建进程进程可以创建新进程，形成进程树打开的终端自身也是一个进程，父进程和子进程是交替运行的子进程会复制父进程的虚拟地址空间，实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*pid_t fork(void);作用：创建一个子进程返回值：返回两次，一次在父进程，一次在子进程在父进程中，成功：返回子进程的ID，失败：返回-1，设置errno为EAGAIN（进程数达到上限）或ENOME（没有内存）在子进程中，成功：返回0*/#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main() &#123; int num = 10; // 创建子进程 pid_t pid = fork(); //子进程仅执行该行代码之后的代码 // 判断是父进程还是子进程 if(pid &gt; 0) &#123; // printf(&quot;pid : %d\\n&quot;, pid); // 如果大于0，返回的是创建的子进程的进程号，当前是父进程 printf(&quot;i am parent process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); printf(&quot;parent num : %d\\n&quot;, num); num += 10; printf(&quot;parent num += 10 : %d\\n&quot;, num); &#125; else if(pid == 0) &#123; // 当前是子进程 printf(&quot;i am child process, pid : %d, ppid : %d\\n&quot;, getpid(),getppid()); printf(&quot;child num : %d\\n&quot;, num); num += 100; printf(&quot;child num += 100 : %d\\n&quot;, num); &#125; // for循环 for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d , pid : %d\\n&quot;, i , getpid()); sleep(1); &#125; return 0;&#125; 父子进程之间的关系区别： 1.fork()函数的返回值不同 父进程中: &gt;0 返回的子进程的ID 子进程中: =0 2.pcb中的一些数据 当前的进程的id pid 当前的进程的父进程的id ppid 信号集 共同点： 某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作 - 用户区的数据 - 文件描述符表 父子进程对变量是不是共享的？ - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。 - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。 有名管道（FIFO）匿名管道由于没有名字，因此只能用于亲缘关系的进程间通信 内存映射将硬件中的物理位置映射到内存中，实现通信12#include&lt;sys/mman.h&gt;mmap,munmapvoid mmap(void addr, size_t length, int prot, int flags,int fd, off_t offset);功能：将一个文件或者设备的数据映射到内存中参数： void *addr: NULL, 由内核指定，指映射到内核中的地址length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。（获取文件的长度：stat lseek）prot : 对申请的内存映射区的操作权限 PROT_EXEC ：可执行的权限 PROT_READ ：读权限 PROT_WRITE ：写权限 PROT_NONE ：没有权限要操作映射内存，必须要有读的权限。PROT_READ（读）、PROT_READ|PROT_WRITE（读写） flags : MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项 MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建 fd: 需要映射的那个文件的文件描述符，通过open得到，open的是一个磁盘文件注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。prot的权限必须小于open的权限，且必须有read权限prot: PROT_READ, open:只读/读写prot: PROT_READ | PROT_WRITE, open:读写 offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移。 返回值： 返回创建的内存的首地址失败返回MAP_FAILED，(void *) -1 int munmap(void *addr, size_t length);功能：释放内存映射参数： addr : 要释放的内存的首地址length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。 使用内存映射实现进程间通信： 有关系的进程（父子进程）还没有子进程的时候：通过唯一的父进程，先创建内存映射区有了内存映射区以后，创建子进程：父子进程共享创建的内存映射区 没有关系的进程间通信准备一个大小不是0的磁盘文件进程1 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针进程2 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针，使用内存映射区通信 注意：内存映射区通信，是非阻塞。 设置定时器setitimer12include &lt;sys/time.h&gt;int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value); 功能： 设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时参数：which : 定时器以什么时间计时 ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM 常用 ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF new_value: 设置定时器的属性12345678struct itimerval &#123; // 定时器的结构体struct timeval it_interval; // 每个阶段的时间，间隔时间struct timeval it_value; // 延迟多长时间执行定时器&#125;;struct timeval &#123; // 时间的结构体 time_t tv_sec; // 秒数 suseconds_t tv_usec; // 微秒 &#125;;过10秒后，每个2秒定时一次old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL 返回值： 成功 0失败 -1 并设置错误号 捕捉信号123#include &lt;signal.h&gt; typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 功能：设置某个信号的捕捉行为，SIGKILL SIGSTOP不能被捕捉，不能被忽略。参数： signum: 要捕捉的信号,一般使用宏值handler: 捕捉到信号要如何处理 SIG_IGN ： 忽略信号 SIG_DFL ： 使用信号默认的行为 回调函数 : 这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义 不是程序员调用，而是当信号产生，由内核调用 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。 返回值： 成功，返回上一次注册的信号处理函数的地址。（sighandler_t）类型第一次调用返回NULL失败，返回SIG_ERR，设置错误号 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;sys/time.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;void myalarm(int num) &#123; printf(&quot;捕捉到了信号的编号是：%d\\n&quot;, num); printf(&quot;xxxxxxx\\n&quot;);&#125;// 过3秒以后，每隔2秒钟定时一次int main() &#123; // 注册信号捕捉 // signal(SIGALRM, SIG_IGN); // signal(SIGALRM, SIG_DFL); // void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。 signal(SIGALRM, myalarm); struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间,3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); // 非阻塞的 printf(&quot;定时器开始了...\\n&quot;); if(ret == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar(); return 0;&#125; 信号集和相关函数定义 用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 信号产生但是没有被处理 （未决）在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）SIGINT信号状态被存储在第二个标志位上这个标志位的值为0， 说明信号不是未决状态这个标志位的值为1， 说明信号处于未决状态 这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较阻塞信号集默认不阻塞任何的信号，如果想要阻塞某些信号需要用户调用系统的API 在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了如果没有阻塞，这个信号就被处理如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理 函数以下信号集相关的函数都是对自定义的信号集进行操作。 int sigemptyset(sigset_t set);int sigfillset(sigset_t set); 功能：将信号集中的所有的标志位置为0(sigemptyset)将信号集中的所有的标志位置为1(sigfillset)参数：set, 传出参数，需要操作的信号集返回值：成功返回0， 失败返回-1 int sigaddset(sigset_t set, int signum);int sigdelset(sigset_t set, int signum); 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号参数：set：传出参数，需要操作的信号集signum：需要设置阻塞的那个信号(sigaddset)需要设置不阻塞的那个信号(sigdelset)返回值：成功返回0， 失败返回-1 int sigismember(const sigset_t *set, int signum); 功能：判断某个信号是否阻塞参数：set：需要操作的信号集signum：需要判断的那个信号返回值： 1 ： signum被阻塞 0 ： signum不阻塞 -1 ： 失败 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;signal.h&gt;#include &lt;stdio.h&gt;int main() &#123; // 创建一个信号集 sigset_t set; // 清空信号集的内容 sigemptyset(&amp;set); // 判断 SIGINT 是否在信号集 set 里 int ret = sigismember(&amp;set, SIGINT); if(ret == 0) &#123; printf(&quot;SIGINT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGINT 阻塞\\n&quot;); &#125; // 添加几个信号到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); // 判断SIGINT是否在信号集中 ret = sigismember(&amp;set, SIGINT); if(ret == 0) &#123; printf(&quot;SIGINT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGINT 阻塞\\n&quot;); &#125; // 判断SIGQUIT是否在信号集中 ret = sigismember(&amp;set, SIGQUIT); if(ret == 0) &#123; printf(&quot;SIGQUIT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGQUIT 阻塞\\n&quot;); &#125; // 从信号集中删除一个信号 sigdelset(&amp;set, SIGQUIT); // 判断SIGQUIT是否在信号集中 ret = sigismember(&amp;set, SIGQUIT); if(ret == 0) &#123; printf(&quot;SIGQUIT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGQUIT 阻塞\\n&quot;); &#125; return 0;&#125; int sigprocmask(int how, const sigset_t set, sigset_t oldset); 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）参数：how : 如何对内核阻塞信号集进行处理 SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变 假设内核中默认的阻塞信号集是mask， 这个操作相当于 mask = mask | set(set中需要设置阻塞的信号位设置为1) SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞，相当于mask = mask &amp;= ~set(set中需要设置解除阻塞的信号位设置为1) SIG_SETMASK:覆盖内核中原来的值 set ：已经初始化好的用户自定义的信号集oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL返回值：成功：0,失败：-1,设置错误号：EFAULT、EINVAL int sigpending(sigset_t *set); 功能：获取内核中的未决信号集参数：set,传出参数，保存的是内核中的未决信号集中的信息。 sigaction12#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact); 功能：检查或者改变信号的处理。信号捕捉参数： signum : 需要捕捉的信号的编号或者宏值（信号的名称）act ：捕捉到信号之后的处理动作oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL 返回值：成功 0, 失败 -1 12345678910111213 struct sigaction &#123; // 函数指针，指向的函数就是信号捕捉到之后的处理函数 void (*sa_handler)(int); // 不常用 void (*sa_sigaction)(int, siginfo_t *, void *); // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。 sigset_t sa_mask; // 使用哪一个信号处理对捕捉到的信号进行处理 // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction int sa_flags; // 被废弃掉了 void (*sa_restorer)(void);&#125;; SIGCHLD信号SIGCHLD信号产生的3个条件： 子进程结束 子进程暂停了 子进程继续运行都会给父进程发送该信号，父进程默认忽略该信号。使用SIGCHLD信号解决僵尸进程的问题 共享内存允许两个或多个进程共享物理内存中同一块区域，只需内核介入，效率更高，和管道，内存映射比更快。因为管道和内存映射都需要用户和内核之间的切换和数据拷贝。 使用步骤： 调用shmget()创建一个新的共享内存段或取得一个现有的共享内存段的标识符。这个调用返回需要用到的共享内存标识符。 使用shmat()来附上共享内存段，使该段成为调用进程的虚拟内存的一部分。即，将上述共享内存段与进程绑定，可以通过进程的虚拟内存访问该共享内存段。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。 操作函数shmgetshmget(key_t key, size_t size, int shmflg);功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。新创建的内存段中的数据都会被初始化为0参数： key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。一般使用16进制表示，非0值size: 共享内存的大小shmflg: 属性 访问权限 附加属性：创建/判断共享内存是不是存在 创建：IPC_CREAT 判断共享内存是否存在：IPC_EXCL , 需要和IPC_CREAT一起使用(IPC_CREAT | IPC_EXCL | 0664）即先判断，不存在的时候创建 返回值：失败：-1 并设置错误号, 成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。 shmatvoid shmat(int shmid, const void shmaddr, int shmflg);功能：和当前的进程进行关联参数： shmid : 共享内存的标识（ID）,由shmget返回值获取shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定shmflg : 对共享内存的操作 读 ： SHM_RDONLY, 必须要有读权限 读写： 0，即默认有读写权限 返回值：成功：返回共享内存的首（起始）地址。 失败(void *) -1 shmdtint shmdt(const void *shmaddr); 功能：解除当前进程和共享内存的关联参数：shmaddr：共享内存的首地址返回值：成功 0， 失败 -1 shmctlint shmctl(int shmid, int cmd, struct shmid_ds *buf);功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。参数： shmid: 共享内存的IDcmd : 要做的操作 IPC_STAT : 获取共享内存的当前的状态 IPC_SET : 设置共享内存的状态 IPC_RMID: 标记共享内存被销毁 buf：需要设置或者获取的共享内存的属性信息 IPC_STAT : buf存储数据 IPC_SET : buf中需要初始化数据，设置到内核中 IPC_RMID : 没有用，NULL key_t ftokkey_t ftok(const char *pathname, int proj_id);功能：根据指定的路径名，和int值，生成一个共享内存的key参数： pathname:指定一个存在的路径:/home/nowcoder/Linux/a.txt/proj_id: int类型的值，但是这系统调用只会使用其中的1个字节范围 ： 0-255 一般指定一个字符 ‘a’ read.c12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.获取一个共享内存,第二个参数可以写0，表示是获取而不是创建一个 int shmid = shmget(100, 0, IPC_CREAT); printf(&quot;shmid : %d\\n&quot;, shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); // 3.读数据 printf(&quot;%s\\n&quot;, (char *)ptr); printf(&quot;按任意键继续\\n&quot;); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0;&#125;write.c123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.创建一个共享内存 int shmid = shmget(100, 4096, IPC_CREAT|0664); printf(&quot;shmid : %d\\n&quot;, shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); char * str = &quot;helloworld&quot;; // 3.写数据,+1是拷贝字符串结束符 memcpy(ptr, str, strlen(str) + 1); printf(&quot;按任意键继续\\n&quot;); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0;&#125; 相关问题问题1：操作系统如何知道一块共享内存被多少个进程关联？ 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattchshm_nattach 记录了关联的进程个数 问题2：可不可以对共享内存进行多次删除 shmctl 可以的因为shmctl 标记删除共享内存，不是直接删除什么时候真正删除呢?当和共享内存关联的进程数为0的时候，就真正被删除当共享内存的key为0的时候，表示共享内存被标记删除了如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。 共享内存和内存映射的区别 共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 共享内存效果更高 内存所有的进程操作的是同一块共享内存。内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 数据安全进程突然退出:共享内存还存在,内存映射区消失运行进程的电脑死机，宕机了:数据存在在共享内存中，没有了,内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 生命周期内存映射区：进程退出，内存映射区销毁共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机如果一个进程退出，会自动和共享内存进行取消关联。 守护进程","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"Linux项目","slug":"牛客项目","date":"2022-12-13T16:00:00.000Z","updated":"2023-01-01T05:28:14.787Z","comments":true,"path":"2022/12/14/牛客项目/","link":"","permalink":"http://example.com/2022/12/14/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"重点 静态库和动态库的区别，使用 GDB多进程，多线程调试，Makefile 虚拟地址空间，文件描述符 系统API，open,read,lseek等 dup,dup2,fcntlLinux命令cp file1 path 复制文件到指定路径，如果是目录，不能直接复制，要加上 -rmkdir生成文件夹rm删除，可以通过*实现条件删除mv 移动文件或重命名文件GCC工作流程 从源代码生成可执行程序的过程，需经历 4 个过程，分别是预处理、编译、汇编和链接。 预处理包括导入头文件，并对相应函数进行复制，宏定义等进行替换，去掉注释 编译生成汇编代码 汇编后生成机器可识别的代码，其本质为二进制文件，但由于尚未经过链接操作，所以无法直接运行。 连接就是将同一项目中各源文件生成的目标文件以及程序中用到的库文件整合为一个可执行文件。通过使用以下命令实现每个过程。但是可以跳过一些步骤，如可以直接通过-c，实现预处理，编译和汇编，直接从源代码生成目标代码。实际使用时并不关心这些流程，因此可以直接通过gcc或g++,从源代码生成可执行程序（用gcc编译C，g++编译C++程序）如果不通过-o指定输出文件名，默认生成a.out。指定宏，可以用于控制调试时输出，发布时不输出某些信息。库静态库在连接阶段被复制到程序中动态库在运行时由系统动态加载到内存中供程序调用。优势：代码保密（C++程序反编译之后，还原程度很低），方便部署和分发。静态库的制作 首先将源文件通过gcc -c 生成.o文件 将.o文件打包，使用ar工具Linux：libxxx.a前缀lib和后缀.a是固定的，Windows的后缀是lib,一定记得加.a和.o的后缀1ar rcs libxxx.a xxx.o xxx.o 注意静态库的名称是xxx，不需要包含lib3.编译用到静态库的代码，注意静态库需要有一个头文件.h（指明了静态库中的函数名称和参数类型）配合使用。假设现有如下文件结构 ├── include│ └── head.h├── lib│ └── libjisuan├── main.c└── src ├── add.c ├── add.o ├── div.c ├── div.o ├── libjisuan.a ├── mult.c ├── mult.o ├── sub.c └── sub.o 我们需要编译main.c使用如下指令，其中-I指明了头文件head.h位于./include目录下，-L指定了搜索库的路径为./src -l指定库的名称，是jisuan而不是libjisuan1gcc main.c -I ./include -L ./src -l jisuan然后执行即可，执行的时候不需要用gcc 动态库的制作Linux：libxxx.so前缀lib和后缀.so是固定的，Windows的后缀是dll12gcc -c -fpic/-fPIC a.c b.c //得到和位置无关的代码gcc - shared a.o b.o -o libcalc.so //得到动态库 Makefile自定义变量：变量名= 变量值，用$（变量名）获取变量值预定义变量：AR 归档维护程序的名称，默认值arCC C编译器的名称，默认值ccCXX：C++编辑器的名称$@:目标的完整名称$&lt;:第一个依赖文件$^:所有依赖文件 $(wildcard PATTERN…)如 $(wildcard .c ./sub/ .c)获取当前目录下的.c文件和sub目录下 的.c文件都返回，多个目录用空格隔开 $(patsubst &lt; pattern &gt;, &lt; replacement &gt;, &lt; &gt;) GDB测试通常，在为调试而编译时，我们会(）关掉编译器的优化选项（-o)，并打开调试选项(-g)。另外， ‘-wall`在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的 BUG。输出时加上-g调试，在可执行文件中加入源代码信息 gcc -g -wall program.c -o program ‘-g’选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。 启动与退出gdb 可执行程序quit 给程序设置参数/获取设置参数set args 10 20show args 使用帮助help 查看文件set nu 显示代码行号 查看当前文件 list/简写l 显示代码，一次显示10行，如果有main函数，main函数在中间 list/l 行号/函数名 显示该行/该函数上下几行的代码 查看非当前文件 list/l 文件名：行号 list/l 文件名：函数名 查看并设置每次查看多少代码 查看 show list/listsize 设置set list/listsize 行数 设置断点 调试命令 n 不会进入函数体,s/step会进入函数体 文件IO从内存角度来看：输入：从文件中读入数据，输出：将内存中数据写入文件标准C库是可以跨平台使用的，库在封装的时候针对不同平台采用不用平台各自的API即标准C库通过调用LINUX的API实现调用 fopen返回FILE *fp 文件指针包含3个部分： 文件描述符（整形） 文件读写指针位置 I/O缓冲区（内存地址），提高执行效率，修改先保存到缓冲区，通过缓冲区（默认8192byte）写入磁盘，避免频繁写入磁盘，而LINUX本身的API没有缓冲区，效率低，但实时性高。 文件描述符表是一个数组，用于管理打开的多个文件大小默认是1024，每个进程都有一个文件描述符表，即一个进程最多可以同时打开1021个文件，其前3个位置是被占用的（标准输入，输出，错误），对应当前设备终端同一文件可以被打开多次，如果不释放，再打开，则同一个文件会占用不同的文件描述符LINUX会把所有东西都变成一个文件，包括设备等也会虚拟为一个文件， Linux系统IO函数int open(const char pathname, int flags);int open(const char pathname, int flags,mode_t mode);参数： pathname：要打开的文件路径flags: O_RDONLY（只读），O_WRONLY（只写），O_RDWR（可读写） 返回值： 成功：返回实际读取到的字节数，&gt;0表示实际读取到的字节数，=0表示文件读取完了失败：返回-1，设置errnoint close(int fd); ssize_t read(int fd,void *buf,size_t count);参数： fd：文件描述符，open得到buf：缓冲区，存放读取到的数据的地方，数组的地址count: 指定的数组的大小 返回值： 成功：返回实际读取到的字节数，&gt;0表示实际读取到的字节数，=0表示文件读取完了失败：返回-1，设置errno ssize_t write(int fd,const void *buf,size_t count);参数： fd：文件描述符，open得到buf：要写入的数据count: 要写的数据的实际大小 返回值： 成功：写入字节数失败：返回-1，设置errno 1234567891011121314151617181920212223242526272829303132#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; //打开源文件 int srcfd = open(&quot;english.txt&quot;,O_RDONLY); if(srcfd==-1)&#123; perror(&quot;open&quot;); return -1; &#125; //创建目标文件并打开 int desfd = open(&quot;cpy.txt&quot;,O_WRONLY|O_CREAT ,0664); if(srcfd==-1)&#123; perror(&quot;open&quot;);//只是人为定义的描述 return -1; &#125; //读取源文件，存放在buf数组中 char buf[1024]=&#123;0&#125;; int len = 0; while((len = read(srcfd,buf,sizeof(buf)))&gt;0)&#123; //将buf中的内容写入目标文件，当len=0表示读取完了 write(desfd,buf,len); &#125; close(desfd); close(srcfd); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"剑指Offer(1)——算法和数据结构基础","slug":"剑指Offer","date":"2022-06-05T16:00:00.000Z","updated":"2023-05-08T10:41:36.977Z","comments":true,"path":"2022/06/06/剑指Offer/","link":"","permalink":"http://example.com/2022/06/06/%E5%89%91%E6%8C%87Offer/","excerpt":"","text":"数据结构__数组和字符串03 数组中重复的数字 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例：输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 方法1：原地交换利用题目信息：即在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内。说明数组元素的索引和值是一对多的关系。每个元素最多被交换两次就被送到了对应的位置，所以时间复杂度是O(N)，原地交换，所以空间复杂度是O(1).12345678910class Solution: def findRepeatNumber(self, nums: [int]) -&gt; int: i = 0 while i &lt; len(nums): if nums[i] == i: i += 1 continue if nums[nums[i]] == nums[i]: return nums[i] nums[nums[i]], nums[i] = nums[i], nums[nums[i]] return -1注意最后一行交换两个数时的a,b = c,d赋值语句：Python操作的原理是先暂存元组 (c, d)，然后 “按左右顺序” 赋值给 a 和 b 。因此，若写为 nums[i], nums[nums[i]] = nums[nums[i]],nums[i]，则 nums[i] 会先被赋值nums[nums[i]]，之后赋值时 nums[nums[i]] ，元素索引会出现错误，因为这个时候nums[i]已经被改变1234567nums = [1,2,3,4,5]i = 2 #交换位置2和位置3（nums[2]=3）nums[i],nums[nums[i]]=nums[nums[i]],nums[i]print(nums)#[1,2,4,4,5]发生错误nums = [1,2,3,4,5]nums[nums[i]],nums[i]=nums[i],nums[nums[i]]print(nums)#[1,2,4,3,5]正确 方法2：哈希表没啥好说的，注意哈希表的添加是add就好，然后就是空间复杂度比方法一高。1234567class Solution: def findRepeatNumber(self, nums: [int]) -&gt; int: dic = set() for num in nums: if num in dic: return num dic.add(num) return -1 题目拓展书上给出了进一步的要求，数组长度n+1,包含的数字在1~n范围内，要求不改变原数组的情况下找出重复元素。思路1：新建一个辅助数组，长度也为n+1,然后从原数组往辅助数组拷贝，每次拷贝保证索引和值对应，由于数字是1开始，所以应该保证nums[i]=i+1，然后如果重复的话，直接返回，缺点是空间复杂度。思路2：避免额外空间，二分法，由于1~n共有n个数，而数组长度n+1，所以必然有重复，可以把范围分为1~m和m+1~n，然后分别统计两个范围的数的个数，二分缩小范围。时间复杂度O(nlogn),每次计数复杂度是O（n）,所以是拿时间换空间。这个改进不能拿原题跑了，因为原题长度是n,可取的数也有n个，计数不一定满足。12345678910111213141516171819202122class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: def countrange(nums,a,b): count = 0 for i in nums: if a&lt;=i and i&lt;=b: count +=1 return count a = 0 b = len(nums) while b&gt;a: mid = (a+b)//2 res = countrange(nums,a,mid) print(a,mid) if res&gt;mid-a+1: b = mid else: a = mid+1 if b==a: return a 04 二维数组中的查找 在一个 n m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。*示例:现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。 常规想法可能是先找到在哪一行，然后再找哪一列，但这样其实比较浪费，没有很好的利用本来有序的信息，试想如果其小于某一列的最后一个元素，则必然小于该行下所有行最后一列的元素，这样一次就可以缩小一行或一列了。时间复杂度就降为O(M+N),当然从左下角开始也是一样的，K神的代码相比于从右上角开始j=len(matrix[0])-1，这样写直接省下了判断matrix[0]是否是None12345678class Solution: def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -&gt; bool: i, j = len(matrix) - 1, 0 while i &gt;= 0 and j &lt; len(matrix[0]): if matrix[i][j] &gt; target: i -= 1 elif matrix[i][j] &lt; target: j += 1 else: return True return False 05 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。示例：输入：s = “We are happy.”输出：”We%20are%20happy.” 在 Python 和 Java 等语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。实现也比较容易。主要难点在于使用C++时，需要改变长度，因此采用倒序遍历，双指针的做法，具体可参考题解。1234567class Solution: def replaceSpace(self, s: str) -&gt; str: res = [] for c in s: if c == &#x27; &#x27;: res.append(&quot;%20&quot;) else: res.append(c) return &quot;&quot;.join(res)补充材料： Python字符串操作字符串用到的join函数 感觉Python字符串很好用的一个操作就是可以直接相加，并且按位索引，很像列表，比如旋转字符串的题可以直接s[n:]+s[:n]，如果不允许用切片的话，就是用列表写了，然后用join函数转换为字符串 还有一个哈希表的事，现在Python3.6之后的字典默认是有序的，也就不需要再定义OrderedDict 数据结构__链表06 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。示例 1：输入：head = [1,3,2]输出：[2,3,1] 两种方法的时间复杂度和空间复杂度都是O(N) 方法1：辅助栈比较容易就想到了，先进后出的做法。书中指到可以采用反转链表的方式，在面试时，需要与面试官沟通是否可以改变原始输入数据。1234567class Solution: def reversePrint(self, head: ListNode) -&gt; List[int]: stack = [] while head: stack.append(head.val) head = head.next return stack[::-1]方法2：递归12345678910111213141516class Solution:#大佬的简易版 def reversePrint(self, head: ListNode) -&gt; List[int]: return self.reversePrint(head.next) + [head.val] if head else []#自己写的 def reversePrint(self, head: ListNode) -&gt; List[int]: stack = [] def digui(head): if not head: return digui(head.next) stack.append(head.val) digui(head) return stack 数据结构__树07 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。示例：Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7] 感觉切片的方法还是很直观且好理解的12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 切片class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if preorder: root = TreeNode(preorder[0]) index = inorder.index(preorder[0]) root.left = self.buildTree(preorder[1:index+1],inorder[:index]) root.right = self.buildTree(preorder[index+1:],inorder[index+1:]) return root else: return 大佬写的效率会更高一点，至少不用切片，递归函数三个参数recur(root,left,right)其中第一个参数表示在前序遍历中根节点的索引，后面的left和right对应在中序遍历时，该子树的范围，所以每次先寻找根节点的位置i，然后建立范围，很明显：左子树的根节点在前序遍历中，就在当前根节点下一个位置即root+1左子树本身在中序遍历中，就是left到i的左边，即left~i-1右子树的根节点在前序遍历中，就在左子树的下一个，而左子树的长度，由左子树的范围可知，为i-1-left+1,为i-left，而左子树的起点是root+1,所以右子树根节点就是i-left+root+1右子树本身在中序遍历中，就是i的右边到结尾，即i+1~right 1234567891011121314class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: def recur(root, left, right): if left &gt; right: return # 递归终止 node = TreeNode(preorder[root]) # 建立根节点 i = dic[preorder[root]] # 划分根节点、左子树、右子树 node.left = recur(root + 1, left, i - 1) # 开启左子树递归 node.right = recur(i - left + root + 1, i + 1, right) # 开启右子树递归 return node # 回溯返回根节点 dic, preorder = &#123;&#125;, preorder for i in range(len(inorder)): dic[inorder[i]] = i return recur(0, 0, len(inorder) - 1) 08 二叉树的下一个节点(力扣题名中序后继)数据结构__栈与队列09 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 做法：辅助栈，每次需要删除的时候，从A栈里pop出所有元素到B栈中，这样A的栈底元素会变到B的栈顶，所以当需要删除栈顶元素时，总是从B开始，当B为空时，从A栈pop出所有元素，比较简单。 时间复杂度：appendTail()函数为 O(1) ；deleteHead() 函数在N次队首元素删除操作中总共需完成N个元素的倒序。空间复杂度O(N)： 最差情况下，栈 A 和 B 共保存N个元素。题解 Python删除元素方法 12345678910111213class CQueue: def __init__(self): self.A, self.B = [], [] def appendTail(self, value: int) -&gt; None: self.A.append(value) def deleteHead(self) -&gt; int: if self.B: return self.B.pop() if not self.A: return -1 while self.A: self.B.append(self.A.pop()) return self.B.pop() 算法操作__递归和循环通常递归代码比较简洁，但是性能不如基于循环的代码，每次调用都需要在内存栈中分配空间以保存参数，返回地址及临时变量，所以效率低。但是在树的遍历的时候，递归比较常用，在没有要求的情况下，尽可能的用递归。还有在比如斐波那契数列这种问题下，使用递归会造成大量的重复计算。递归：函数调用自身如果面试的时候告诉了动态规划的思路后，面试官提醒说在分解子问题的时候，是不是存在特殊的选择，如果采用这个特殊的选择将一定能得到最优解，这个可能在提示用贪婪算法。 10 斐波那契数列和青蛙跳台阶 Those who cannot remember the past are condemned to repeat it.要不要这么哲理啊，哈哈哈 以斐波那契数为例，最容易想到的递归，其实一直在重复调用，造成了很大的时间（重复计算）和空间浪费（保存中间结果）解决办法： 自顶向下，相当于建立了一个备忘录，创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在Memo数组中，下次在调用fib（n）的时候就不会重新递归了。问题就是空间浪费，需要有个数组存放 自下向上，计算fib（6）的时候最后还是要计算出fib（1），fib（2），fib（3）…,那么何不先计算出fib（1），fib（2），fib（3）…,呢？这也就是动态规划的核心，先计算子问题，再由子问题计算父问题。实现了对空间的压缩。 逆向思维：这个我真的是没有青蛙跳楼梯，可以一次跳一个或两个，问跳n阶有几种方案f(n),那其实，他最后一步，要么是跳一个，就有f(n-1)种，要么是跳两个，就有f(n-2)种，f(n) = f(n-1)+f(n-2) 动态规划 123456class Solution: def fib(self, n: int) -&gt; int: a, b = 0, 1 for _ in range(n): a, b = b, a + b return a % 1000000007 青蛙跳台阶只需要把n改为n-1即可，因为斐波那契数列是从0开始，而青蛙从1开始 需要注意的是，python只要内存够不会出现大数溢出的问题，所以可以只在返回结果的时候取余，但是在java等其他语言中，每次计算时都要取余。 青蛙问题java版 1234567891011class Solution &#123; public int numWays(int n) &#123; int a = 1, b = 1, sum; for(int i = 0; i &lt; n; i++)&#123; sum = (a + b) % 1000000007; a = b; b = sum; &#125; return a; &#125;&#125; 算法操作__查找和排序如果面试时要求在排序数组（或者部分排序数组）中查找或统计，可以尝试二分法，排序算法中比较重要的是快排 11 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。示例 1：输入：numbers = [3,4,5,1,2]输出：1 比较容易想到二分啦，然后就是看后段（看前半段是判断不了的，比如num[m]&gt;num[i],如果数组没有旋转的话，其实找的数在左半段，但旋转过的话，就在右半段，判断不了）如果num[m]&lt; num[j],这个时候，也就是说后半段是有序的，那么肯定不在后半段中，也有可能恰好就是m，当m是旋转的那个元素时,所以令j=m如果num[m]&gt; num[j],这个时候，肯定就在后半段内，而且不会是m，因为这个元素是大的，肯定是在左半段，所以就令i=m+1比较复杂的就是相等的情况了，这个时候你是判断不了在那一部分的，书中写的是直接从头遍历（不是指原数组，而是当前的[i,j]），k神提到可以直接j=j-1,如果j不是旋转的起始元素，那就不影响，如果恰好是的话，就会有num[m]=num[j],而num[m]之前的数组是递增的（或者不变），那么可以判断num[i]~num[m]都等于num[j],而且由于j就是旋转的那个数字，所以其实接下来的数组就都是左半段了，那继续循环就能找到那个数字了。123456789class Solution: def minArray(self, numbers: [int]) -&gt; int: i, j = 0, len(numbers) - 1 while i &lt; j: m = (i + j) // 2 if numbers[m] &gt; numbers[j]: i = m + 1 elif numbers[m] &lt; numbers[j]: j = m else: j -= 1 return numbers[i] 算法操作__回溯法就有点感觉像是，一条路试一试，不行就再回来试一下另一条，所以多数会涉及置0的操作，也就是设置某个节点为已经访问过，可以用辅助数组存储是否访问过，也可以用一个集合表示，注意的是回溯时，需要把状态复原 12 矩阵中的路径 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 采用深度优先遍历，结束当前路径的条件包括，越界，不相等，由于已经将访问过的元素置为空字符，所以不会存在重复访问的问题，值得注意的是board[i][j] = word[k]，即在遍历后，要把状态复原。 1234567891011121314class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: def dfs(i, j, k): if not 0 &lt;= i &lt; len(board) or not 0 &lt;= j &lt; len(board[0]) or board[i][j] != word[k]: return False if k == len(word) - 1: return True board[i][j] = &#x27;&#x27; res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1) board[i][j] = word[k] return res for i in range(len(board)): for j in range(len(board[0])): if dfs(i, j, 0): return True return False 13 机器人的运动范围 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？示例 1：输入：m = 2, n = 3, k = 1输出：3 题解比较突出的一点就是，论证了只需要向下和向右走就可以遍历到所有的可达解，利用集合来保证不重复，然后就是当前位置各数位和的计算，当十位发生变化时，比如19—&gt;20,十位多了1，个位少了9，所以总体-8，对应(i + 1) % 10==0，不进位的话就直接+1就好，结束当前路径的条件包括越界和不满足要求，以及重复。回溯法的代码很相似，都是设置了一个结束条件，这道题由于不涉及修改数据，所以不用复原，防止重复是依靠集合。 深度优先12345678910class Solution: def movingCount(self, m: int, n: int, k: int) -&gt; int: def dfs(i, j, si, sj): if i &gt;= m or j &gt;= n or k &lt; si + sj or (i, j) in visited: return 0 visited.add((i,j)) return 1 + dfs(i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj) + dfs(i, j + 1, si, sj + 1 if (j + 1) % 10 else sj - 8) visited = set() return dfs(0, 0, 0, 0)广度优先就是依靠栈来实现，其实差不多，只是访问的顺序不一致。广度优先1234567891011class Solution: def movingCount(self, m: int, n: int, k: int) -&gt; int: queue, visited = [(0, 0, 0, 0)], set() while queue: i, j, si, sj = queue.pop(0) if i &gt;= m or j &gt;= n or k &lt; si + sj or (i, j) in visited: continue visited.add((i,j)) queue.append((i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj)) queue.append((i, j + 1, si, sj + 1 if (j + 1) % 10 else sj - 8)) return len(visited) 算法操作__动态规划与贪婪这个其实之前也提到过了，主要是贪婪法在使用的时候需要证明贪婪可以得到最优解。 其中快速取余数的操作，简单证明一下： a^2modc=((amodc)(amodc))modc=(amodc)^2modca^4modc=((a^2modc)*(a^2modc))modc=((amodc)^2modc*(amodc)^2modc)modc然后类似第一个式子，这里的化简结果就相当于把第一个式子的a替换为了(amodc)^2,所以同理我们把a^2modc替换成了((amodc)^2)^2modc=(amodc)^4modc大概是这么个证明过程，主要是奇数和偶数不一样，就是需要把求幂分好多次二分来求，需要二分的此书就是a不断除2，偶数情况下，就是不断的平方取余就好，奇数的话就要多乘一个x。 比如计算x^4modp=(x^2modp)^2modp 先执行x=x^2modp(a=4//2=2),计算括号里的 再执行x=(x^2modp)^2modp(a=2//2=1),计算得到结果 最后，rem=(1*x)modp(a=0) 123456789# 求 (x^a) % p —— 快速幂求余def remainder(x, a, p): rem = 1 while a &gt; 0: if a % 2: rem = (rem * x) % p x = x ** 2 % p a //= 2 return rem 回到题目本身 14 剪绳子 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 证明用到了基本不等式，求解之后发现剪成越多的长度为3的绳子越好，具体证明参考题解,这道题，也可以用动态规划，只是不是一个固定的值，需要去作比较，比如f(4)=f(1)+f(3)=f(2)+f(2),需要比较不同的组合(f(n)=f(a)+f(n-a),循环终止条件是a&lt;n//2) 1234567891011class Solution: def cuttingRope(self, n: int) -&gt; int: if n &lt;= 3: return n - 1 a, b, p, x, rem = n // 3 - 1, n % 3, 1000000007, 3 , 1 while a &gt; 0: if a % 2: rem = (rem * x) % p x = x ** 2 % p a //= 2 if b == 0: return (rem * 3) % p # = 3^(a+1) % p if b == 1: return (rem * 4) % p # = 3^a * 4 % p return (rem * 6) % p # = 3^(a+1) * 2 % p 算法操作__位运算15 二进制中1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。 比较容易陷入死循环（部分语言）的原因是，负数在右移时，是默认补全符号位，也就是会在左边填充1的，但是在控制台输入时，题目进行的是无符号的右移操作，即默认最左边的1不表示符号位，这个就有点迷惑其实，主要还是掌握一下python的变量特点就是会自动根据数值大小，扩充位数，只要内存够，所以包括以上剪绳子时出现的大数问题，都是可以储存下的，反正就是python很奇怪。12345678class Solution: def hammingWeight(self, n: int) -&gt; int: res = 0 while n: res += n &amp; 1 n &gt;&gt;= 1 return res主要是题解里另一种 n&(n-1)的方法 30 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。主要问题在于怎么找最小的数，这个也是用了一个辅助栈，这个辅助栈用于存放当前栈中最小的数，每次在添加的时候，比较添加的元素和辅助栈栈顶的元素，并添加两者中更小的数到辅助栈中，因为栈是先进先出的，所以，只要后面压入的数比当前辅助栈顶的数大，那么最小数是不会改变的。 时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。空间复杂度：O(n)，其中n为总操作数。最坏情况下，我们会连续插入 nn 个元素，此时两个栈占用的空间为 O(n)。题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MinStack: def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.stack = [] self.minstack = [] def push(self, x: int) -&gt; None: if self.minstack:#没有元素时为空 self.minstack.append(min(x,self.minstack[-1]))#和辅助栈自己比 else: self.minstack.append(x) self.stack.append(x) def pop(self) -&gt; None: if self.stack: self.stack.pop() self.minstack.pop() def top(self) -&gt; int: if self.stack: return self.stack[-1] else: return null def min(self) -&gt; int: if self.stack: return self.minstack[-1] else: return null# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.min() 补充知识：None和NULL的区别： None是一个对象，而NULL是一个类型。 Python中没有NULL，只有None，None有自己的特殊类型NoneType。 None不等于0、任何空字符串、False等。 在Python中，None、False、0、””(空字符串)、、()(空元组)、{}(空字典)都相当于False。所以，判断列表为空的时候可以直接用if list: None是Python中的一个关键字，None本身也是个一个数据类型，而这个数据类型就是None，它可0、空字符串以及false均不一样，这些都只是对象，而None也是一个类。 详细参考None if X is not None写法清晰明了，且不会出错，推荐使用；if not x使用前，必须确定X为None、False、””、0、[]、()、{}时对判断无影响。123456x = []y = None print &#x27;X is None测试结果&#x27;print x is None #Falseprint y is None #True Python的赋值操作，上面的一行必须写两个[]，不然会指向同一变量，同样对于 24 反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。做法就是双指针，注意引入那个临时变量，链表的题，画图画图画图，更改指向后，记得把原来的连接线打岔就好，还有就是不需要再额外加上非空的判断了，空的话直接就是返回None。时间复杂度O(N)，原地变换，空间复杂度O(1)，双指针真的很好用。 题解 123456789101112class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: cur, pre = head, None while cur: tmp = cur.next # 暂存后继节点 cur.next cur.next = pre # 修改 next 引用指向 pre = cur # pre 暂存 cur cur = tmp # cur 访问下一节点 return pre 35 复杂链表的复制请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。题目描述需要看一下题目的图的，比较难理解，就是说要构造一个一模一样的链表，但是存储的地方不一样，主要的问题是Random，在复制时，这个节点很可能还不存在，所以可以考虑先复制所有的节点，Random先初始化为None,然后就是一个指向问题，比较好理解的方法是复制加拆分，画图画图画图。尤其是在拆分的时候，在恢复原链表的时候，最后的指向None,因为复制后，原链表的最后一项是指向复制链表的最后一项的，退出循环后要单独加上一句，将其指向None。还有就是最后的while判断，不能是原链表非空，即while pre，因为假设链表为：3-&gt;3-&gt;7-&gt;7-&gt;null到第一个7的时候，如果是while pre,则第二个7没有下一个节点了，即cur.next.next会报错(cur.next=null，没有next),所以应该是while cur.next，即保证是倒数第二个节点，然后修改原链表中7的指向。正如上一句所说。还有就是在构建random指向的时候，注意判断是否为None,原因都是类似的，因为None没有next，基本都是这个错。 题解 1234567891011121314151617181920212223242526272829class Solution: def copyRandomList(self, head: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: if not head: return cur = head # 1. 复制各节点，并构建拼接链表 while cur: tmp = Node(cur.val) tmp.next = cur.next cur.next = tmp cur = tmp.next # 2. 构建各新节点的 random 指向 cur = head while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next # 3. 拆分两链表 cur = res = head.next pre = head while cur.next: pre.next = pre.next.next cur.next = cur.next.next pre = pre.next cur = cur.next pre.next = None # 单独处理原链表尾节点 return res # 返回新链表头节点 Day04-05 查找算法 这一部分重要的方法就是二分法，尤其适用于本来内部有序的数组，mid = (a+b)//2，表示向下取整，这个还是有好几个题可以看的 53 I.在排序数组中查找数字统计一个数字在排序数组中出现的次数。输入: nums = [5,7,7,8,8,10], target = 8输出: 2 有序数组基本都用二分法，时间复杂度O(logN) 12345678910class Solution: def search(self, nums: [int], target: int) -&gt; int: def helper(tar): i, j = 0, len(nums) - 1 while i &lt;= j: m = (i + j) // 2 if nums[m] &lt;= tar: i = m + 1 else: j = m - 1 return i return helper(target) - helper(target - 1) i = m+1 和j = m-1的目的是为了保证，如果target存在的话，始终在[i,j]这个区间内，若 nums[m] &lt; targe，则 target 在闭区间[m+1,j]中，因此执行 i = m + 1若 nums[m] &gt; target，则 target 在闭区间[i,m−1]中，因此执行 j = m - 1；若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；因此和nums[m] &lt; targe，保持一致，这样保证了右边界在[i,j]这个区间内，但是对于nums[m] &gt; target，的情况，执行j = m-1后，很可能右边界就不在[i,j]内了，这种情况的话右边界就是j+1,不过不用担心的是，循环结束前的最后一次循环一定是i=j,并且如果存在target的话，i和j(i=j=m)指向的都是最右边的target或者右边界,如果指向target,执行i=m+1,刚好指向右边界,如果指向右边界，执行j = m-1,i仍指向右边界。这个比较好理解，i小于等于target时总是往右移，而j只有大于target时才往左移，所以两者都是共同逼近最右边的target特殊情况,就是target比最左边的数还小时，j会不断左移，直到i和j都指向0，此时仍然比target大,j=-1,i=0,同理比最右边的数大时，i会不断右移，最终i=len(nums),最后一行也比较好理解，helper(target)指向比target大的第一个数，helper(target-1)指向比target-1大的第一个数，如果存在target,则刚好指向第一个target,如果不存在，他和helper(target)指向的都是同一个数。 题解","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"线性数据结构","slug":"线性数据结构","date":"2022-01-31T16:00:00.000Z","updated":"2023-01-01T05:32:45.909Z","comments":true,"path":"2022/02/01/线性数据结构/","link":"","permalink":"http://example.com/2022/02/01/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"链表&emsp;&emsp;特点是插入删除容易，但查找不容易，因此，在涉及链表查找的题目时，一般用哈希表来实现，哈希表通过哈希函数将一个输入插入到固定位置，因此哈希表有可能出现空间的浪费，因为插入时不是连续的，但是查找时方便，是用空间换时间的一种方法。发生哈希冲突时则是以链表存储的。 &emsp;&emsp;除此之外，由于链表并不需要初始化长度，因此采用动态内存分配，区别于数组，数组在内存中的空间是连续的，但是链表在内存中不连续。链表属于动态分配，需要申请内存空间(C++中用new)，但是需要手动释放(用delete) 12345int* p = new int;/*数据类型 *指针名称 = new 数据类型 或数据类型 *指针名称 = new 数据类型（初值）；*/delete p//delete指针名称//如果分配成功，会返回内存空间起始地址，不成功返回NULL 使用结构体指针访问变量中成员的两种格式：(*指针变量).成员名 或者 指针变量-&gt;成员名 用C++初始化12345678910111213struct ListNode &#123; int val; // 节点值 ListNode *next; // 后继节点引用 ListNode(int x) : val(x), next(NULL) &#123;&#125;//结构体的初始化函数，传入x则自动给val赋值x&#125;;// 实例化节点ListNode *n1 = new ListNode(4); // 节点 headListNode *n2 = new ListNode(5);ListNode *n3 = new ListNode(1);// 构建引用指向n1-&gt;next = n2;n2-&gt;next = n3;用Python初始化123456789101112class ListNode: def __init__(self, x): self.val = x # 节点值 self.next = None # 后继节点引用# 实例化节点n1 = ListNode(4) # 节点 headn2 = ListNode(5)n3 = ListNode(1)# 构建引用指向n1.next = n2n2.next = n3 链表实现(Python) 参考自：https://blog.csdn.net/Blood_Seeker/article/details/78992722 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class ListNode(object): #结点初始化函数, p 即模拟所存放的下一个结点的地址 #为了方便传参, 设置 p 的默认值为 0 def __init__(self, x = None): self.val = x self.next = Noneclass LinkList(object): def __init__(self): self.head = None #链表初始化函数, 方法类似于尾插 def initList(self, dataList): #创建头结点 self.head = ListNode(None) # 创建节点的时候传一个参数进去 # 创建头结点，里面不包含数据，头结点之后第一个才存放数据,head节点的数据默认None pTail = self.head # 指向头结点的指针 #逐个为 data 内的数据创建结点, 建立链表 for i in dataList: # 遍历列表 newNode = ListNode(i) # 生成新的节点 pTail.next = newNode # 新节点挂在尾结点上，即 上一个节点指针指向新的节点，由于新节点的next被初始化为None，所以pTail的next自然也是None pTail = newNode # 当前新节点成为新的尾结点 #链表判空 def isEmpty(self): return self.head.next is None #取链表长度 def getLength(self): if self.isEmpty(): exit(0) p = self.head.next len = 0 while p: len += 1 p = p.next return len #遍历链表 def traveList(self): if self.isEmpty(): exit(0) print (&#x27;link list traving result:&#x27;) p = self.head.next # 取得表头之后的第一个数据 while p: print (p.val, end= &quot; &quot;) p = p.next #链表插入数据函数 def insertElem(self, val, index): &quot;&quot;&quot; 在 第index个节点(p.next)之前插入&quot;&quot;&quot; p = self.head i = 1 while p and i &lt; index: p = p.next i = i + 1 if p is None or i &gt; index: print(&quot;ERROR, 无法插入节点&quot;) return False pNew = ListNode(val) # 生成新的节点 包含了 pNew.val = key pNew.next = p.next p.next = pNew def deleteElem(self, index): &quot;删除第index个节点（即删除 p.next节点）&quot; p = self.head i = 1 # 节点计数 while p.next and i &lt; index: p = p.next i = i + 1 if p.next is None or i &gt; index: print(&quot;ERROR, 该节点不存在&quot;) return False delVal = p.next.val print(&quot;deleted value:&quot;, delVal) p.next = p.next.nextif __name__ == &#x27;__main__&#x27;: #初始化链表与数据 # data = [1,2,3,4,5] dataList = [1, 2, 3, 4, 5] l = LinkList() l.initList(dataList) l.traveList() print(&#x27;\\n&#x27;) print(l.getLength()) #插入结点到索引值为3之后, 值为666 l.insertElem(666, 6) l.traveList() print(&#x27;\\n&#x27;) #删除索引值为4的结点 l.deleteElem(4) l.traveList() print(&#x27;\\n&#x27;) 一些链表相关题目L160 相交链表 &emsp;&emsp;这道题注意的是不仅仅是值相交，两个链表相交，则相交部分是完全一致的，因此可以用哈希表实现，也可以用双指针实现，两个指针分别从链表A(总长a)和链表B(总长b)的头出发，当到达结尾后，转向另一个链表，则如果两个链表有相交(相交部分为c)，此时都运动了a+b-c(a+(b-c)和b+(a-c)); L141 环形链表 &emsp;&emsp;利用双指针中的快慢指针，类比跑道上的两个速度不同的人，如果存在环形，则会相遇，但是注意的是两者的速度一定不同，而不能只是起点不同，起点不同不会相遇，会保持固定间隔。当然这种类似于查找是否有重复的，都可以用哈希表 解法1：哈希表，时间复杂度O(n)，空间复杂度O(n) 123456789class Solution(object): def hasCycle(self, head): s = set() # 定义一个set(集合，内部元素不重复)，然后不断遍历链表 while head:# 如果某个节点在set中，说明遍历到重复元素了，也就是有环 if head in s: # 不能把head.val这个值存在哈希表中，因为有可能只是值相同还不够，还需要指针也相同 return True s.add(head) # 如果节点不在哈希表中，说明之前没有相同节点，就存入表中 head = head.next return False 解法2：快慢双指针，时间复杂度O(n)，空间复杂度O(1) 123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next:#链表中是单元素且非循环或链表为空 return False slow = head fast = head.next while slow != fast: if not fast or not fast.next:#只用考虑更快的指针，因为如果链表有限，则快指针先达到结束条件，必须加上fast.next，因为后面有fast.next.next，如果fast.next为null，则null不会有next变量，会报错 return False slow = slow.next fast = fast.next.next return True 123456789101112131415161718class Solution &#123;public: bool hasCycle(ListNode* head) &#123; if (head == nullptr || head-&gt;next == nullptr) &#123; return false; &#125; ListNode* slow = head; ListNode* fast = head-&gt;next; while (slow != fast) &#123; if (fast == nullptr || fast-&gt;next == nullptr) &#123; return false; &#125; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return true; &#125;&#125;; L234 回文链表&emsp;&emsp;实现时，先利用快慢指针，找到链表的中间节点，可以参考后面的面试问题中有提到，同时在指针移动的过程中，进行反转链表，之后从中间位置往两个方向展开。&emsp;&emsp;需要注意的是，对于奇数，慢指针会停在最中间的元素，因此在展开前需要将其后移一位，偶数，则指在中间靠后的元素，因此不需操作。&emsp;&emsp;关于如何判断元素数是奇还是偶，可以对比跳出循环的条件：对于快指针，依次指向0，2，4，即fast指向元素的索引始终为偶数，所以如果有偶数个元素，最后一个元素索引为奇数，则倒数第二次循环后,fast指向倒数第二个元素，fast.next指向最后一个，再次进入循环，此时fast为null,fast.next会报错，但因为是and所以不会,and前是0，自动忽略后面语句（短路现象），如果改为fast.next and fast则会报错。如果有奇数个元素，则最后一次循环q指向最后一个元素,q.next=null;即奇数个元素，fast.next=null,偶数个元素，fast=null,所以if(fast)：在奇数时执行，而为了反转链表引入的pre和prepre则始终在慢指针前面一位，反转时先将pre后移，然后将prepre赋给pre.next，即pre-&gt;prepre,然后prepre后移，即循环结束时，两者指向同一元素。123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if (head is None) or (head.next is None): return True slow = head fast = head pre = head prepre = ListNode(None) while(fast and fast.next): pre = slow # pre 紧跟在slow 后面一步 slow = slow.next # 快慢指针用于找到中间节点 fast = fast.next.next pre.next = prepre # 用于反转前半部分链表 prepre = pre if (fast): # 如果跳出上一个while循环是 fast.next is None,那么就是奇数个节点，slow需要再走一步 slow = slow.next while(pre and slow): # 从中间对称的位置往两边扩展，比对两边的数是否相等 if (pre.val != slow.val): return False pre = pre.next slow = slow.next return True 链表面试问题&emsp;&emsp;无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。 双指针并不是固定的公式，而是一种思维方式~ &emsp;&emsp;先来看”倒数第k个元素的问题”。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。1234567891011121314class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode *p = head, *q = head; //初始化 while(k--) &#123; //将 p指针移动 k 次 p = p-&gt;next; &#125; while(p != nullptr) &#123;//同时移动，直到 p == nullptr p = p-&gt;next; q = q-&gt;next; &#125; return q; &#125;&#125;;&emsp;&emsp;获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 指向中间两个结点的靠前一个还是靠后一个，需要调整循环的条件，下述代码是n为偶数的情况，慢指针指向靠后元素。 1234567891011class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode *p = head, *q = head; while(q != nullptr &amp;&amp; q-&gt;next != nullptr) &#123; p = p-&gt;next; q = q-&gt;next-&gt;next; &#125; return p; &#125; &#125;; &emsp;&emsp;对于上述代码： 比如n=5(下标0~4),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;4，此时q-&gt;next = null结束循环，p指向2，恰好是中间节点。（0，1，2，3，4） 比如n=4(下标0~3),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;null(2.next为3，3.next为null)，此时q = null结束循环，p指向2，是中间节点靠后一个。（0，1，2，3） 将条件改为while(q != nullptr &amp;&amp; q-&gt;next-&gt;next != nullptr)，会指向靠前一个，因为此时不会进行第二轮循环。 &emsp;&emsp;如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。&emsp;&emsp;如何判断环的入口呢？&emsp;&emsp;由等式可知，相遇时d=x+ns(n为相遇时快指针多转了几圈)，则相遇后把两个指针速度变为一致，一个从起点出发，一个从相遇点出发，则因为d=x+ns，必然会在从相遇点出发的指针运动n圈+x后，在环的入口处相遇。(d为起点处出发指针路程，x+ns为从相遇点出发指针路程)，代码实现如下：123456789101112131415161718class Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: walker = head runner = head while(runner and runner.next): walker = walker.next runner = runner.next.next if walker == runner: break if (runner is None) or (runner.next is None): # 如果是因为走到头而退出循环，那就是没有环 return # return False 的话会报错Your returned value is not a ListNode type. # 如果是因为break而跳出循环，那就是有环 walker = head # 步行者回到起点 while(walker != runner): # 没相遇 walker = walker.next runner = runner.next return runner链表相关链接: 漫画算法：如何判断链表有环？ L141环形链表 一些刷题小总结判断输入是否为Noneif not A 和 if A is None 看起来都是在判断A是否为空，实际上这两者是不同的：（1）if not A 判断的是A是否为空，也就是说里面有东西没？（2） if A is None则判断的是A是否声明并定义了？123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next:#这里可以写成if head==None or head.next == None，但是其实是不一样的，因为如果head==None，则head.next会报错，因为Nonetype没有next的索引，即上述中的(2),不适用not则判断是否声明同时判断是否为空 return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"如何利用Hexo搭建自己的博客","slug":"Hexo","date":"2022-01-09T16:00:00.000Z","updated":"2022-05-22T04:13:38.123Z","comments":true,"path":"2022/01/10/Hexo/","link":"","permalink":"http://example.com/2022/01/10/Hexo/","excerpt":"","text":"安装Hexo&emsp;&emsp;安装的过程可以参考 Hexo官网。&emsp;&emsp;首先，需要保证安装好了node.js和git，这两个软件的安装也比较简单，直接官网安装就好。然后在命令行窗口中利用以下命令安装hexo，其中g代表对全局安装1npm install hexo-cli-g&emsp;&emsp;然后是新建一个文件夹，这个文件夹将自动生成一些默认的文件,之后的命令行窗口操作都是在该文件夹下进行12hexo init [文件夹名]cd [文件夹名]&emsp;&emsp;然后安装一下需要的依赖（可能就是默认工具包的意思？）1npm install&emsp;&emsp;然后执行1hexo s 部署操作1234hexo chexo s #生成本地预览hexo g #生成静态文章hexo d #上传，必须先执行hexo g 选择一个好看的主题&emsp;&emsp;在 Hexo官网提供了很多主题，选择一个好看的主题后，点击进入主题对应的github中，即可看到相关的命令，仍然在该文件夹下执行命令后即可安装，安装后会在theme文件夹下看到一个对应得主题文件夹，比如这里我选择安装了butterfly主题，就会生成一个对应的文件夹 Butterfly各种参数介绍及实际操作视频，强推这个宝藏UP啊主题操作教程 Markdown写作基础标题123# 一级标题## 二级标题...... 上述代码的执行效果如下： 字体效果1234567**加粗***斜体*~~删除~~==高亮==其他：加两个空格：&amp;emsp;&amp;emsp;（这个还挺麻烦的） 上述代码的执行效果如下：&emsp;&emsp;加粗 &emsp;&emsp;斜体&emsp;&emsp; 删除&emsp;&emsp;==高亮== 引用12&gt;引用内容&gt;&gt;增加&gt;数量可以设置多层引用 上述代码的执行效果如下： 引用内容 增加&gt;数量可以设置多层引用 分割线1*** 上述代码的执行效果如下： 图片和链接123![图片的名字](网上图片的链接或者本地图片的路径)[连接名称](链接地址)比如：[baidu](www.baidu.com) 搭建图床Gitee崩了啊可恶，还是Github香 Github图床搭建操作 公式 可以参考链接：https://blog.csdn.net/weixin_42546496/article/details/88115095","categories":[{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]}],"categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]}