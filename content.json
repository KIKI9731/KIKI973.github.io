{"meta":{"title":"KIKI's Blog","subtitle":"分享科研总结和生活琐碎","description":"一只努力减肥的KI","author":"KIKI","url":"http://example.com","root":"/"},"pages":[{"title":"link","date":"2022-01-09T11:44:53.000Z","updated":"2022-01-09T11:45:20.485Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"KIKI的标签页","date":"2022-01-09T11:39:03.000Z","updated":"2022-01-09T11:40:22.946Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"让我来康康这个KI都写了点什么东西","date":"2022-01-09T11:42:22.000Z","updated":"2022-01-11T07:51:17.294Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"C++学习笔记","slug":"C++","date":"2022-01-12T16:00:00.000Z","updated":"2022-01-14T08:55:49.742Z","comments":true,"path":"2022/01/13/C++/","link":"","permalink":"http://example.com/2022/01/13/C++/","excerpt":"","text":"算术运算前置++和后置++的区别：int n = 5,m = 10;int a,b,c,d;a = n++;//后置++b = m--;c = ++n;//前置++d = --m;cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;/*输出结果为5，10，7，8。首先对于后置++，可以看到对于a和b是先进行了赋值操作，再进行后置++。执行后a=15,b=10,n=6,m=9。对于前置++，首先进行前置++，再进行赋值操作*/ 后置++的优先级&gt;前置++的优先级&gt;乘和除的优先级&gt;…&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，！=&gt;赋值运算，优先级和上述性质无关。用优先性解释上述现象有矛盾，所以，可以按照这个记吧 强制类型转换：int (a)(int) a //两种方式均可 其优先级高于乘数法，和逻辑非，按位取反同级。因此 double(n)/2 是先将n转换为double再做除法 逻辑运算 双目运算：&amp;&amp; ||单目运算：! 逻辑！负号-&gt;乘除运算等&gt;&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，!=&gt;逻辑&amp;&amp;&gt;逻辑||。为了避免优先级的混乱，多使用圆括号 位运算 &amp;，|，^(异或)，&lt;&lt;左移,&gt;&gt;右移,~(按位取反) 按位取反的时候要考虑到数据的字节数，对于一个正数，前面所有的0都要变成1,左移一位相当于2，右移相当于除2。复合位运算(&amp;=，|=等)的结合顺序是*从右向左，除此之外还有(!,~,+,-,前置++/—)也是从右向左结合，比较特殊。 特殊符号 “=”赋值运算，其结合顺序是从右向左且其左侧(lvalue)不能是表达式，只能是变量，数组等 ?:,比如y=(x&gt;=1?1:0)即可表达一个分段函数:y=1(x&gt;=1),y=0(x&lt;1) 逗号表达式，依次计算每个表达式的值，整体等于最后一个逗号后式子的值，如y=(1,2,3+5),则y=8 算法优先级顺序 数据类型转换原则 整型变量和字符变量其在内存中存放的都是整数，整数，存放的是二进制格式，字符，存放的是ASCII码值(","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"信号处理期末考试","slug":"信号处理","date":"2022-01-11T16:00:00.000Z","updated":"2022-01-12T11:31:47.394Z","comments":true,"path":"2022/01/12/信号处理/","link":"","permalink":"http://example.com/2022/01/12/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/","excerpt":"","text":"考试类型及范围&emsp;&emsp;5道论述题：&emsp;&emsp;1.在面对一个具体问题，怎么选择某个具体的算法（PCA，深度学习，或者其他），每种方法有什么优缺点。&emsp;&emsp;2.从小波变换到二代小波到EMD，为什么会出现这些方法，重在理解每种方法的原理，每个方法主要用来解决哪些问题。（不需要过于关注细节和公式。） 平稳信号&emsp;&emsp;课本83页： 平稳随机信号的各阶统计量与时间无关，而某阶统计量随时间变化的信号称为非平稳信号或时变信号 &emsp;&emsp;课本112页： 为了克服傅里叶变换不能同时进行时、频分析的不足…傅里叶变换得到的频率分量是对信号历程平均化的计算结果 非平稳信号的处理方法短时傅里叶变换（课本112-114页）&emsp;&emsp;通过加窗$h(t)$,对窗内信号进行观察，窗的移动通过改变$h(t-\\tau)$中的$\\tau$将x(t)映射到时频二维平面$（\\tau,f）$。&emsp;&emsp;式（5.1.6）表明，其时间分辨率和频率分辨率是相互制约的，且由于其是窗的大小和形状都固定不变，因此一旦确定，在整个时频平面上的时频分辨率是保持不变的。而反映信号高频成分要用窄时窗，反映信号低频成分要用宽时窗，不能同时满足这些要求。 EMD为什么用EMD&emsp;&emsp;EMD（Empirical Mode Decomposition）作为时频域的处理方法，相对于同样是时频域方法的小波分析有什么好处呢？ &emsp;&emsp;EMD最显著的特点，就是其克服了基函数无自适应性的问题。啥意思呢？回忆小波分析部分的内容，我们会知道小波分析是需要选定某一个小波基的，小波基的选择对整个小波分析的结果影响很大，一旦确定了小波基，在整个分析过程中将无法更换，即使该小波基在全局可能是最佳的，但在某些局部可能并不是，所以小波分析的基函数缺乏适应性。&emsp;&emsp;用EMD有什么好处呢？对于一段未知信号，不需要做预先分析与研究，就可以直接开始分解。这个方法会自动按照一些固有模式按层次分好，而不需要人为设置和干预。","categories":[{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"}],"tags":[]},{"title":"强化学习（一）时序差分算法","slug":"强化学习（一）","date":"2022-01-10T16:00:00.000Z","updated":"2022-01-11T08:40:32.241Z","comments":true,"path":"2022/01/11/强化学习（一）/","link":"","permalink":"http://example.com/2022/01/11/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"这是强化学习","categories":[{"name":"强化学习","slug":"强化学习","permalink":"http://example.com/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"Markdown的入门级操作","slug":"markdown","date":"2022-01-10T16:00:00.000Z","updated":"2022-01-11T08:41:11.379Z","comments":true,"path":"2022/01/11/markdown/","link":"","permalink":"http://example.com/2022/01/11/markdown/","excerpt":"","text":"标题123# 一级标题## 二级标题...... 上述代码的执行效果如下： 字体效果1234567**加粗***斜体*~~删除~~==高亮==其他：加两个空格：&amp;emsp;&amp;emsp;（这个还挺麻烦的） 上述代码的执行效果如下：&emsp;&emsp;加粗 &emsp;&emsp;斜体&emsp;&emsp; 删除&emsp;&emsp;==高亮== 引用12&gt;引用内容&gt;&gt;增加&gt;数量可以设置多层引用 上述代码的执行效果如下： 引用内容 增加&gt;数量可以设置多层引用 分割线1*** 上述代码的执行效果如下： 图片和链接123![图片的名字](网上图片的链接或者本地图片的路径)[连接名称](链接地址)如这里：[baidu](www.baidu.com) baidu","categories":[{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]},{"title":"如何利用Hexo搭建自己的博客","slug":"代码","date":"2022-01-09T16:00:00.000Z","updated":"2022-01-11T08:41:09.517Z","comments":true,"path":"2022/01/10/代码/","link":"","permalink":"http://example.com/2022/01/10/%E4%BB%A3%E7%A0%81/","excerpt":"","text":"安装Hexo&emsp;&emsp;安装的过程可以参考 Hexo官网。&emsp;&emsp;首先，需要保证安装好了node.js和git，这两个软件的安装也比较简单，直接官网安装就好。然后在命令行窗口中利用以下命令安装hexo，其中g代表对全局安装 1npm install hexo-cli-g &emsp;&emsp;然后是新建一个文件夹，这个文件夹将自动生成一些默认的文件,之后的命令行窗口操作都是在该文件夹下进行 12hexo init [文件夹名]cd [文件夹名] &emsp;&emsp;然后安装一下需要的依赖（可能就是默认工具包的意思？） 1npm install &emsp;&emsp;然后执行 1hexo s 即可生成本地的预览 选择一个好看的主题&emsp;&emsp;在 Hexo官网提供了很多主题，选择一个好看的主题后，点击进入主题对应的github中，即可看到相关的命令，仍然在该文件夹下执行命令后即可安装，安装后会在theme文件夹下看到一个对应得主题文件夹，比如这里我选择安装了butterfly主题，就会生成一个对应的文件夹","categories":[{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]}],"categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"课程笔记","slug":"课程笔记","permalink":"http://example.com/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"},{"name":"强化学习","slug":"强化学习","permalink":"http://example.com/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"},{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]}