{"meta":{"title":"KIKI's Blog","subtitle":"分享科研总结和生活琐碎","description":"一只努力减脂的KI","author":"KIKI","url":"http://example.com","root":"/"},"pages":[{"title":"link","date":"2022-01-09T11:44:53.000Z","updated":"2022-01-09T11:45:20.485Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"KIKI的标签页","date":"2022-01-09T11:39:03.000Z","updated":"2022-01-09T11:40:22.946Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"让我来康康这个KI都写了点什么东西","date":"2022-01-09T11:42:22.000Z","updated":"2022-01-11T07:51:17.294Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"剑指Offer","slug":"剑指Offer","date":"2022-06-05T16:00:00.000Z","updated":"2022-06-08T03:31:27.165Z","comments":true,"path":"2022/06/06/剑指Offer/","link":"","permalink":"http://example.com/2022/06/06/%E5%89%91%E6%8C%87Offer/","excerpt":"","text":"Day01 栈与队列09 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 做法：辅助栈，每次需要删除的时候，从A栈里pop出所有元素到B栈中，这样A的栈底元素会变到B的栈顶，所以当需要删除栈顶元素时，总是从B开始，当B为空时，从A栈pop出所有元素，比较简单。 时间复杂度：appendTail()函数为 O(1) ；deleteHead() 函数在N次队首元素删除操作中总共需完成N个元素的倒序。空间复杂度O(N)： 最差情况下，栈 A 和 B 共保存N个元素。题解 12345678910111213class CQueue: def __init__(self): self.A, self.B = [], [] def appendTail(self, value: int) -&gt; None: self.A.append(value) def deleteHead(self) -&gt; int: if self.B: return self.B.pop() if not self.A: return -1 while self.A: self.B.append(self.A.pop()) return self.B.pop() 30 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。主要问题在于怎么找最小的数，这个也是用了一个辅助栈，这个辅助栈用于存放当前栈中最小的数，每次在添加的时候，比较添加的元素和辅助栈栈顶的元素，并添加两者中更小的数到辅助栈中，因为栈是先进先出的，所以，只要后面压入的数比当前辅助栈顶的数大，那么最小数是不会改变的。 时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。空间复杂度：O(n)，其中n为总操作数。最坏情况下，我们会连续插入 nn 个元素，此时两个栈占用的空间为 O(n)。题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MinStack: def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.stack = [] self.minstack = [] def push(self, x: int) -&gt; None: if self.minstack:#没有元素时为空 self.minstack.append(min(x,self.minstack[-1]))#和辅助栈自己比 else: self.minstack.append(x) self.stack.append(x) def pop(self) -&gt; None: if self.stack: self.stack.pop() self.minstack.pop() def top(self) -&gt; int: if self.stack: return self.stack[-1] else: return null def min(self) -&gt; int: if self.stack: return self.minstack[-1] else: return null# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.min() 补充知识：None和NULL的区别： None是一个对象，而NULL是一个类型。 Python中没有NULL，只有None，None有自己的特殊类型NoneType。 None不等于0、任何空字符串、False等。 在Python中，None、False、0、””(空字符串)、、()(空元组)、{}(空字典)都相当于False。所以，判断列表为空的时候可以直接用if list: None是Python中的一个关键字，None本身也是个一个数据类型，而这个数据类型就是None，它可0、空字符串以及false均不一样，这些都只是对象，而None也是一个类。 详细参考None if X is not None写法清晰明了，且不会出错，推荐使用；if not x使用前，必须确定X为None、False、””、0、[]、()、{}时对判断无影响。123456x = []y = None print &#x27;X is None测试结果&#x27;print x is None #Falseprint y is None #True Python的赋值操作，上面的一行必须写两个[]，不然会指向同一变量，同样对于 Day02 链表06 从尾到头打印链表输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。做法：辅助栈 时间复杂度 O(N)： 入栈和出栈共使用时间。空间复杂度 O(N)： 辅助栈 stack 和数组 res 共使用的额外空间。 比较简单，主要就是掌握最后一行，列表逆向输出时，是两个冒号，递归的方法好复杂，自己写不出来。1234567891011121314# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reversePrint(self, head: ListNode) -&gt; List[int]: a =[] while head: a.append(head.val) head = head.next return a[::-1] 24 反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。做法就是双指针，注意引入那个临时变量，链表的题，画图画图画图，更改指向后，记得把原来的连接线打岔就好，还有就是不需要再额外加上非空的判断了，空的话直接就是返回None。时间复杂度O(N)，原地变换，空间复杂度O(1)，双指针真的很好用。 题解 123456789101112class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: cur, pre = head, None while cur: tmp = cur.next # 暂存后继节点 cur.next cur.next = pre # 修改 next 引用指向 pre = cur # pre 暂存 cur cur = tmp # cur 访问下一节点 return pre 35 复杂链表的复制请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。题目描述需要看一下题目的图的，比较难理解，就是说要构造一个一模一样的链表，但是存储的地方不一样，主要的问题是Random，在复制时，这个节点很可能还不存在，所以可以考虑先复制所有的节点，Random先初始化为None,然后就是一个指向问题，比较好理解的方法是复制加拆分，画图画图画图。尤其是在拆分的时候，在恢复原链表的时候，最后的指向None,因为复制后，原链表的最后一项是指向复制链表的最后一项的，退出循环后要单独加上一句，将其指向None。还有就是最后的while判断，不能是原链表非空，即while pre，因为假设链表为：3-&gt;3-&gt;7-&gt;7-&gt;null到第一个7的时候，如果是while pre,则第二个7没有下一个节点了，即cur.next.next会报错(cur.next=null，没有next),所以应该是while cur.next，即保证是倒数第二个节点，然后修改原链表中7的指向。正如上一句所说。还有就是在构建random指向的时候，注意判断是否为None,原因都是类似的，因为None没有next，基本都是这个错。 题解 1234567891011121314151617181920212223242526272829class Solution: def copyRandomList(self, head: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: if not head: return cur = head # 1. 复制各节点，并构建拼接链表 while cur: tmp = Node(cur.val) tmp.next = cur.next cur.next = tmp cur = tmp.next # 2. 构建各新节点的 random 指向 cur = head while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next # 3. 拆分两链表 cur = res = head.next pre = head while cur.next: pre.next = pre.next.next cur.next = cur.next.next pre = pre.next cur = cur.next pre.next = None # 单独处理原链表尾节点 return res # 返回新链表头节点 03数组中重复的数字12345678910class Solution: def findRepeatNumber(self, nums: [int]) -&gt; int: i = 0 while i &lt; len(nums): if nums[i] == i: i += 1 continue if nums[nums[i]] == nums[i]: return nums[i] nums[nums[i]], nums[i] = nums[i], nums[nums[i]] return -1 注意最后一行交换两个数时的a,b = c,d赋值语句：Python操作的原理是先暂存元组 (c, d)，然后 “按左右顺序” 赋值给 a 和 b 。因此，若写为 nums[i], nums[nums[i]] = nums[nums[i]],nums[i]，则 nums[i] 会先被赋值nums[nums[i]]，之后赋值时 nums[nums[i]] ，元素索引会出现错误，因为这个时候nums[i]已经被改变1234567nums = [1,2,3,4,5]i = 2 #交换位置2和位置3（nums[2]=3）nums[i],nums[nums[i]]=nums[nums[i]],nums[i]print(nums)#[1,2,4,4,5]发生错误nums = [1,2,3,4,5]nums[nums[i]],nums[i]=nums[i],nums[nums[i]]print(nums)#[1,2,4,3,5]正确 Python删除元素方法","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"Pytorch图像分类篇","slug":"深度学习","date":"2022-05-21T16:00:00.000Z","updated":"2022-05-22T04:42:11.622Z","comments":true,"path":"2022/05/22/深度学习/","link":"","permalink":"http://example.com/2022/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"卷积神经网络基础激活函数&emsp;&emsp;常用的有如下两种，其中Sigmoid函数饱和时梯度非常小，接近于0，因此容易出现梯度消失现象。ReLu缺点在于反向传播过程中，如果有一个非常大的梯度经过时，反向传播更新后可能导致权重分布中心小于0，使得无法更新权重(此时ReLu后为0，不会再有梯度信息产生)，进入失活状态，且无法恢复。 优化器 SGD优化器： $w_{t+1} = w_t -\\alpha*g(w_t)$容易受样本噪声影响，可能陷入局部最优解。 SGD+Momentum优化器: v_t =\\eta *v_{t-1}+\\alpha*g(w_t),w_{t+1}=w_t-v_t，引入了动量，优化时会考虑上一步的优化方向。 Adagrad，RMSProp，Adam优化器：都属于自适应的优化器，比较接近，但各有不同，Adagrad的学习率下降可能会过快，在收敛前就收敛，RMS相对会慢一点，Adam则更复杂，包含了一阶动量和二阶动量，效果会更好一点。 ToTensor&emsp;&emsp;值得注意的是，在将一个图片或者数组变为Tensor时，会将维度位置发生变化，(H x W x C) 变为 (C x H x W)。123456789class ToTensor: &quot;&quot;&quot;Convert a ``PIL Image`` or ``numpy.ndarray`` to tensor. This transform does not support torchscript. Converts a PIL Image or numpy.ndarray (H x W x C) in the range [0, 255] to a torch.FloatTensor of shape (C x H x W) in the range [0.0, 1.0] if the PIL Image belongs to one of the modes (L, LA, P, I, F, RGB, YCbCr, RGBA, CMYK, 1) or if the numpy.ndarray has dtype = np.uint8 In the other cases, tensors are returned without scaling.&emsp;&emsp;所以如果将tensor再还原时，要交换回来。 损失函数&emsp;&emsp;从下述交叉熵函数的定义可知，其中已经包含了Softmax函数，因此不需要再额外添加。1234567class CrossEntropyLoss(_WeightedLoss): r&quot;&quot;&quot;This criterion combines :class:`~torch.nn.LogSoftmax` and :class:`~torch.nn.NLLLoss` in one single class. It is useful when training a classification problem with `C` classes. If provided, the optional argument :attr:`weight` should be a 1D `Tensor` assigning weight to each of the classes. This is particularly useful when you have an unbalanced training set.","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"非线性数据结构（树）","slug":"非线性数据结构(树)","date":"2022-02-04T16:00:00.000Z","updated":"2022-05-22T04:17:56.050Z","comments":true,"path":"2022/02/05/非线性数据结构(树)/","link":"","permalink":"http://example.com/2022/02/05/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%A0%91)/","excerpt":"","text":"相关知识&emsp;&emsp;如果数据是固定不动的，则查找数据称为静态查找（没有插入和删除操作，只有查找），如果数据会发生变化，则是动态查找。对于静态查找，可以是顺序查找，则时间复杂度为O(N)，或者二分查找，元素本身是有序排列的，时间复杂度为O(logN)，二分查找时，定义了pre,end,mid。每次查找后，end = mid - 1,或者pre = mid +1;不能直接等于mid，这样会出现死循环。根据二分查找的想法，构造了与之类似的数据结构————树，因此查找次数不会超过数的层数，也即是O(logN)。&emsp;&emsp;实现时，可以通过链表实现，但如果链表指向子树，对于大部分比较稀疏或者度数较大的树，会造成很大的浪费，因此可以将链表设置为2个指针，分别指向兄弟节点和子节点（下图左）。对于二叉树，则可以直接将两个指针分别指向其左右子节点（下图右）。 定义与实现&emsp;&emsp;树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。&emsp;&emsp;一棵有n个节点的树，一共有n-1条边，根节点没有，其中节点的子树个数称为结点的度，一个树的度是节点中最大的度数，二叉树的度数为2，叶结点的度数为0。假设定义$n_2$为度数为2的结点数，$n_0$为叶结点树，则$n_2+1=n_0$，因为$2n_2+n_1(每个结点下的边数)=n_0+n_1+n_2-1(节点数-1)$。&emsp;&emsp;二叉树第$i$层，最多有$2^{i-1}$个结点，层数为i的二叉树，最多有$2^i-1$个结点。&emsp;&emsp;完美二叉树（满二叉树），是指每层都是满的二叉树，仅最后一层不满的且缺少的结点连续，都在右侧时为完全二叉树，其结点的标号和完美二叉树一致。 1234567891011121314151617class TreeNode: def __init__(self, x): self.val = x # 节点值 self.left = None # 左子节点 self.right = None # 右子节点# 初始化节点 n1 = TreeNode(3) # 根节点 root n2 = TreeNode(4) n3 = TreeNode(5) n4 = TreeNode(1) n5 = TreeNode(2) # 构建引用指向 n1.left = n2 n1.right = n3 n2.left = n4 n2.right = n5 树的遍历&emsp;&emsp;根据遍历根节点的顺序，分为前序，中序和后续遍历三种。通常使用递归实现，三种遍历的路径其实是一致的，区别在于每个节点输出的时刻，前序在第一次遇到该节点时即输出，中序在第二次，后序在第三次。除此之外，还有层次遍历，即从上到下，从左到右。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class TreeNode: # 树的节点 def __init__(self,x): self.val = x self.left = None self.right = Noneclass OperationTree(): def __init__(self, data_list): # 把输入的列表初始化为可迭代对象 self.dataIter = iter(data_list) def createTree(self, root = None): # 必须补充一句 默认参数root = None 不然会参数数量不匹配 &quot;&quot;&quot; 新建一颗树 &quot;&quot;&quot; next_data = next(self.dataIter) # 步进获取下一个元素 if next_data == &#x27;#&#x27;: # &quot;#&quot; 号表示叶节点，在程序中用 None 代替 &quot;#&quot; 号 root = None else: # 是根节点，它还有孩子节点，所以继续创建Node root = TreeNode(next_data) # 实例化对象（类似于struct） root.left = self.createTree(root.left) root.right = self.createTree(root.right) return root def preorderTraversal(self, root: TreeNode) -&gt; List[int]: &quot;&quot;&quot; 前序遍历 递归&quot;&quot;&quot; ans = [] def helper(root): if not root: return ans.append(root.val) # 前序遍历，root -&gt; left -&gt; right helper(root.left) helper(root.right) helper(root) return ans def inorderTraversal(self, root: TreeNode) -&gt; List[int]: &quot;&quot;&quot; 中序遍历 递归&quot;&quot;&quot; ans = [] def helper(root): if not root: return helper(root.left) ans.append(root.val) # 中序遍历，left -&gt; root -&gt; right helper(root.right) helper(root) return ans def postorderTraversal(self, root: TreeNode) -&gt; List[int]: &quot;&quot;&quot; 后序遍历 递归&quot;&quot;&quot; ans = [] def helper(root): if not root: return helper(root.left) helper(root.right) ans.append(root.val) # 后序遍历，left -&gt; right -&gt; root helper(root) return ans def printTree(self): &quot;&quot;&quot; 综合打印&quot;&quot;&quot; print(&quot;递归 前序遍历：&quot;, end=&quot; &quot;) preOrder = self.preorderTraversal(root) print(preOrder, &#x27;\\n&#x27;) print(&quot;递归 中序遍历：&quot;, end=&quot; &quot;) inOrder = self.inorderTraversal(root) print(inOrder,&#x27;\\n&#x27;) print(&quot;递归 后序遍历：&quot;, end=&quot; &quot;) postOrder = self.postorderTraversal(root) print(postOrder, &#x27;\\n&#x27;)if __name__ == &#x27;__main__&#x27;: data = &#x27;abd#g###ce##fh###&#x27; #data = [1,2,&#x27;#&#x27;,&#x27;#&#x27;,3,&#x27;#&#x27;,&#x27;#&#x27;] newTree = OperationTree(data) root = newTree.createTree() newTree.printTree()&quot;&quot;&quot;递归 前序遍历： [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;d&#x27;, &#x27;g&#x27;, &#x27;c&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;h&#x27;] 递归 中序遍历： [&#x27;d&#x27;, &#x27;g&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;h&#x27;, &#x27;f&#x27;] 递归 后序遍历： [&#x27;g&#x27;, &#x27;d&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;h&#x27;, &#x27;f&#x27;, &#x27;c&#x27;, &#x27;a&#x27;] &quot;&quot;&quot; 二叉搜索树&emsp;&emsp;根据二分法的启示，建立一种二叉搜索树，其非空左子树的所有键值小于其根结点的键值，右子树相反，且左右子树都是二叉搜索树。应该实现插入，删除和查找这些基本操作。由于其内部顺序，其最小值为最左侧的结点，最大值为最右侧的结点。&emsp;&emsp;原因是，对于完全二叉树，如果有右结点，则一定有左结点，但是可以仅有左结点，没有右结点，所以，最小值一定是叶节点，因为如果不是，必有左结点，即必有更小的值，但最大值不一定，其可以是有左结点的一个结点。 相关题目L98 验证二叉搜索树&emsp;&emsp;很自然的想法就是利用递归，先对一个结点，判断其是否大于左结点，同时小于右结点，然后再判断其左右结点，在整个过程中，只要有一个地方不满足，则直接返回False,结束。但是在递归时，由于更改了原始的结点，所以其父结点的值无法保留，因此定义了一个新的函数，保存了父结点的值，并以范围的方式表示。 方法1：递归，时间复杂度O(n),空间复杂度O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n)； 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isValidBST(self, root): def helper(node, lower = float(&#x27;-inf&#x27;), upper = float(&#x27;inf&#x27;)): if not node: return True val = node.val if val &lt;= lower or val &gt;= upper: return False if not helper(node.right, val, upper): return False if not helper(node.left, lower, val): return False return True return helper(root) 方法2：中序遍历,时间复杂度O(n)，其中 n 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。空间复杂度O(n)，其中 n 为二叉树的节点个数。栈最多存储 n 个节点，因此需要额外的 O(n) 的空间。中序遍历后对于二叉搜索树应该是按从小到大排列的，因此每次需要pop的值应该都比之前pop的值大。 1234567891011121314class Solution: def isValidBST(self, root): stack, inorder = [], float(&#x27;-inf&#x27;) while stack or root: while root: stack.append(root) root = root.left root = stack.pop()#每次pop的结点为没有左结点的结点，因此是中序，即应该为当前树中的最小值，之后pop的都应该比它大 # 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if root.val &lt;= inorder: return False inorder = root.val root = root.right return True 剑指 Offer 33. 二叉搜索树的后序遍历序列&emsp;&emsp;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。&emsp;&emsp;假如是一个二叉搜索树，则根据左结点-右结点-根节点的后序遍历顺序，最后一个元素为根节点，且小于所有的右结点，因此从数组最左边开始遍历，一旦找到大于根结点的值（代码中用q表示），则从当前位置到根节点之前（postorder[q,j-1]），应该都大于根结点，同时其左右子树（postorder[i,q-1]，postorder[q,j-1]）再进行递归。 方法1：递归：时间复杂度$O(N^2)$ ,每次递归的时候减去一个根节点，因此递归占用$O(N)$ ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用$O(N)$。空间复杂度$O(N)$:最差情况下（即当树退化为链表），递归深度将达到N。 12345678910111213141516class Solution: def verifyPostorder(self, postorder: List[int]) -&gt; bool: def judge(i,j): if i&gt;=j: return True p = i while postorder[p]&lt;postorder[j]: p+=1 q = p while postorder[p]&gt;postorder[j]: p+=1 if p==j: return judge(i,q-1) and judge(q,j-1) else: return False return judge(0,len(postorder)-1) 方法2：辅助栈，时间复杂度降到O(N)&emsp;&emsp;在后序遍历时，在遍历完右结点后会访问根节点，所以如果是完全二叉树，必然会出现一个数值减小的过程，但是必须从后往前看，因为从前往后看，树的结构不清楚，会比较乱，那么从后往前看，每次数值增大都是从根节点到右结点的过程，设计一个栈进行该操作，当出现数值减小时，说明遇到了左结点，1","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"线性数据结构","slug":"线性数据结构","date":"2022-01-31T16:00:00.000Z","updated":"2022-05-22T04:20:15.111Z","comments":true,"path":"2022/02/01/线性数据结构/","link":"","permalink":"http://example.com/2022/02/01/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"链表&emsp;&emsp;特点是插入删除容易，但查找不容易，因此，在涉及链表查找的题目时，一般用哈希表来实现，哈希表通过哈希函数将一个输入插入到固定位置，因此哈希表有可能出现空间的浪费，因为插入时不是连续的，但是查找时方便，是用空间换时间的一种方法。发生哈希冲突时则是以链表存储的。 &emsp;&emsp;除此之外，由于链表并不需要初始化长度，因此采用动态内存分配，区别于数组，数组在内存中的空间是连续的，但是链表在内存中不连续。链表属于动态分配，需要申请内存空间(C++中用new)，但是需要手动释放(用delete) 12345int* p = new int;/*数据类型 *指针名称 = new 数据类型 或数据类型 *指针名称 = new 数据类型（初值）；*/delete p//delete指针名称//如果分配成功，会返回内存空间起始地址，不成功返回NULL 使用结构体指针访问变量中成员的两种格式：(*指针变量).成员名 或者 指针变量-&gt;成员名 用C++初始化12345678910111213struct ListNode &#123; int val; // 节点值 ListNode *next; // 后继节点引用 ListNode(int x) : val(x), next(NULL) &#123;&#125;//结构体的初始化函数，传入x则自动给val赋值x&#125;;// 实例化节点ListNode *n1 = new ListNode(4); // 节点 headListNode *n2 = new ListNode(5);ListNode *n3 = new ListNode(1);// 构建引用指向n1-&gt;next = n2;n2-&gt;next = n3;用Python初始化123456789101112class ListNode: def __init__(self, x): self.val = x # 节点值 self.next = None # 后继节点引用# 实例化节点n1 = ListNode(4) # 节点 headn2 = ListNode(5)n3 = ListNode(1)# 构建引用指向n1.next = n2n2.next = n3 链表实现(Python) 参考自：https://blog.csdn.net/Blood_Seeker/article/details/78992722 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class ListNode(object): #结点初始化函数, p 即模拟所存放的下一个结点的地址 #为了方便传参, 设置 p 的默认值为 0 def __init__(self, x = None): self.val = x self.next = Noneclass LinkList(object): def __init__(self): self.head = None #链表初始化函数, 方法类似于尾插 def initList(self, dataList): #创建头结点 self.head = ListNode(None) # 创建节点的时候传一个参数进去 # 创建头结点，里面不包含数据，头结点之后第一个才存放数据,head节点的数据默认None pTail = self.head # 指向头结点的指针 #逐个为 data 内的数据创建结点, 建立链表 for i in dataList: # 遍历列表 newNode = ListNode(i) # 生成新的节点 pTail.next = newNode # 新节点挂在尾结点上，即 上一个节点指针指向新的节点，由于新节点的next被初始化为None，所以pTail的next自然也是None pTail = newNode # 当前新节点成为新的尾结点 #链表判空 def isEmpty(self): return self.head.next is None #取链表长度 def getLength(self): if self.isEmpty(): exit(0) p = self.head.next len = 0 while p: len += 1 p = p.next return len #遍历链表 def traveList(self): if self.isEmpty(): exit(0) print (&#x27;link list traving result:&#x27;) p = self.head.next # 取得表头之后的第一个数据 while p: print (p.val, end= &quot; &quot;) p = p.next #链表插入数据函数 def insertElem(self, val, index): &quot;&quot;&quot; 在 第index个节点(p.next)之前插入&quot;&quot;&quot; p = self.head i = 1 while p and i &lt; index: p = p.next i = i + 1 if p is None or i &gt; index: print(&quot;ERROR, 无法插入节点&quot;) return False pNew = ListNode(val) # 生成新的节点 包含了 pNew.val = key pNew.next = p.next p.next = pNew def deleteElem(self, index): &quot;删除第index个节点（即删除 p.next节点）&quot; p = self.head i = 1 # 节点计数 while p.next and i &lt; index: p = p.next i = i + 1 if p.next is None or i &gt; index: print(&quot;ERROR, 该节点不存在&quot;) return False delVal = p.next.val print(&quot;deleted value:&quot;, delVal) p.next = p.next.nextif __name__ == &#x27;__main__&#x27;: #初始化链表与数据 # data = [1,2,3,4,5] dataList = [1, 2, 3, 4, 5] l = LinkList() l.initList(dataList) l.traveList() print(&#x27;\\n&#x27;) print(l.getLength()) #插入结点到索引值为3之后, 值为666 l.insertElem(666, 6) l.traveList() print(&#x27;\\n&#x27;) #删除索引值为4的结点 l.deleteElem(4) l.traveList() print(&#x27;\\n&#x27;) 一些链表相关题目L160 相交链表 &emsp;&emsp;这道题注意的是不仅仅是值相交，两个链表相交，则相交部分是完全一致的，因此可以用哈希表实现，也可以用双指针实现，两个指针分别从链表A(总长a)和链表B(总长b)的头出发，当到达结尾后，转向另一个链表，则如果两个链表有相交(相交部分为c)，此时都运动了a+b-c(a+(b-c)和b+(a-c)); L141 环形链表 &emsp;&emsp;利用双指针中的快慢指针，类比跑道上的两个速度不同的人，如果存在环形，则会相遇，但是注意的是两者的速度一定不同，而不能只是起点不同，起点不同不会相遇，会保持固定间隔。当然这种类似于查找是否有重复的，都可以用哈希表 解法1：哈希表，时间复杂度O(n)，空间复杂度O(n) 123456789class Solution(object): def hasCycle(self, head): s = set() # 定义一个set(集合，内部元素不重复)，然后不断遍历链表 while head:# 如果某个节点在set中，说明遍历到重复元素了，也就是有环 if head in s: # 不能把head.val这个值存在哈希表中，因为有可能只是值相同还不够，还需要指针也相同 return True s.add(head) # 如果节点不在哈希表中，说明之前没有相同节点，就存入表中 head = head.next return False 解法2：快慢双指针，时间复杂度O(n)，空间复杂度O(1) 123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next:#链表中是单元素且非循环或链表为空 return False slow = head fast = head.next while slow != fast: if not fast or not fast.next:#只用考虑更快的指针，因为如果链表有限，则快指针先达到结束条件，必须加上fast.next，因为后面有fast.next.next，如果fast.next为null，则null不会有next变量，会报错 return False slow = slow.next fast = fast.next.next return True 123456789101112131415161718class Solution &#123;public: bool hasCycle(ListNode* head) &#123; if (head == nullptr || head-&gt;next == nullptr) &#123; return false; &#125; ListNode* slow = head; ListNode* fast = head-&gt;next; while (slow != fast) &#123; if (fast == nullptr || fast-&gt;next == nullptr) &#123; return false; &#125; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return true; &#125;&#125;; L234 回文链表&emsp;&emsp;实现时，先利用快慢指针，找到链表的中间节点，可以参考后面的面试问题中有提到，同时在指针移动的过程中，进行反转链表，之后从中间位置往两个方向展开。&emsp;&emsp;需要注意的是，对于奇数，慢指针会停在最中间的元素，因此在展开前需要将其后移一位，偶数，则指在中间靠后的元素，因此不需操作。&emsp;&emsp;关于如何判断元素数是奇还是偶，可以对比跳出循环的条件：对于快指针，依次指向0，2，4，即fast指向元素的索引始终为偶数，所以如果有偶数个元素，最后一个元素索引为奇数，则倒数第二次循环后,fast指向倒数第二个元素，fast.next指向最后一个，再次进入循环，此时fast为null,fast.next会报错，但因为是and所以不会,and前是0，自动忽略后面语句（短路现象），如果改为fast.next and fast则会报错。如果有奇数个元素，则最后一次循环q指向最后一个元素,q.next=null;即奇数个元素，fast.next=null,偶数个元素，fast=null,所以if(fast)：在奇数时执行，而为了反转链表引入的pre和prepre则始终在慢指针前面一位，反转时先将pre后移，然后将prepre赋给pre.next，即pre-&gt;prepre,然后prepre后移，即循环结束时，两者指向同一元素。123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if (head is None) or (head.next is None): return True slow = head fast = head pre = head prepre = ListNode(None) while(fast and fast.next): pre = slow # pre 紧跟在slow 后面一步 slow = slow.next # 快慢指针用于找到中间节点 fast = fast.next.next pre.next = prepre # 用于反转前半部分链表 prepre = pre if (fast): # 如果跳出上一个while循环是 fast.next is None,那么就是奇数个节点，slow需要再走一步 slow = slow.next while(pre and slow): # 从中间对称的位置往两边扩展，比对两边的数是否相等 if (pre.val != slow.val): return False pre = pre.next slow = slow.next return True 链表面试问题&emsp;&emsp;无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。 双指针并不是固定的公式，而是一种思维方式~ &emsp;&emsp;先来看”倒数第k个元素的问题”。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。1234567891011121314class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode *p = head, *q = head; //初始化 while(k--) &#123; //将 p指针移动 k 次 p = p-&gt;next; &#125; while(p != nullptr) &#123;//同时移动，直到 p == nullptr p = p-&gt;next; q = q-&gt;next; &#125; return q; &#125;&#125;;&emsp;&emsp;获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 指向中间两个结点的靠前一个还是靠后一个，需要调整循环的条件，下述代码是n为偶数的情况，慢指针指向靠后元素。 1234567891011class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode *p = head, *q = head; while(q != nullptr &amp;&amp; q-&gt;next != nullptr) &#123; p = p-&gt;next; q = q-&gt;next-&gt;next; &#125; return p; &#125; &#125;; &emsp;&emsp;对于上述代码： 比如n=5(下标0~4),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;4，此时q-&gt;next = null结束循环，p指向2，恰好是中间节点。（0，1，2，3，4） 比如n=4(下标0~3),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;null(2.next为3，3.next为null)，此时q = null结束循环，p指向2，是中间节点靠后一个。（0，1，2，3） 将条件改为while(q != nullptr &amp;&amp; q-&gt;next-&gt;next != nullptr)，会指向靠前一个，因为此时不会进行第二轮循环。 &emsp;&emsp;如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。&emsp;&emsp;如何判断环的入口呢？&emsp;&emsp;由等式可知，相遇时d=x+ns(n为相遇时快指针多转了几圈)，则相遇后把两个指针速度变为一致，一个从起点出发，一个从相遇点出发，则因为d=x+ns，必然会在从相遇点出发的指针运动n圈+x后，在环的入口处相遇。(d为起点处出发指针路程，x+ns为从相遇点出发指针路程)，代码实现如下：123456789101112131415161718class Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: walker = head runner = head while(runner and runner.next): walker = walker.next runner = runner.next.next if walker == runner: break if (runner is None) or (runner.next is None): # 如果是因为走到头而退出循环，那就是没有环 return # return False 的话会报错Your returned value is not a ListNode type. # 如果是因为break而跳出循环，那就是有环 walker = head # 步行者回到起点 while(walker != runner): # 没相遇 walker = walker.next runner = runner.next return runner链表相关链接: 漫画算法：如何判断链表有环？ L141环形链表 一些刷题小总结判断输入是否为Noneif not A 和 if A is None 看起来都是在判断A是否为空，实际上这两者是不同的：（1）if not A 判断的是A是否为空，也就是说里面有东西没？（2） if A is None则判断的是A是否声明并定义了？123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next:#这里可以写成if head==None or head.next == None，但是其实是不一样的，因为如果head==None，则head.next会报错，因为Nonetype没有next的索引，即上述中的(2),不适用not则判断是否声明同时判断是否为空 return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"C++学习笔记","slug":"C++","date":"2022-01-12T16:00:00.000Z","updated":"2022-05-22T04:21:57.741Z","comments":true,"path":"2022/01/13/C++/","link":"","permalink":"http://example.com/2022/01/13/C++/","excerpt":"","text":"算术运算前置++和后置++的区别：1234567int n = 5,m = 10;int a,b,c,d;a = n++;//后置++b = m--;c = ++n;//前置++d = --m;cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;/*输出结果为5，10，7，8。首先对于后置++，可以看到对于a和b是先进行了赋值操作，再进行后置++。执行后a=15,b=10,n=6,m=9。对于前置++，首先进行前置++，再进行赋值操作*/ 后置++的优先级&gt;前置++的优先级&gt;乘和除的优先级&gt;…&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，！=&gt;赋值运算，优先级和上述性质无关。用优先性解释上述现象有矛盾，所以，可以按照这个记吧 强制类型转换：12int (a)(int) a //两种方式均可 其优先级高于乘数法，和逻辑非，按位取反同级。因此 double(n)/2 是先将n转换为double再做除法 逻辑运算 双目运算：&amp;&amp; ||单目运算：! 逻辑！负号-&gt;乘除运算等&gt;&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，!=&gt;逻辑&amp;&amp;&gt;逻辑||。为了避免优先级的混乱，多使用圆括号 位运算 &amp;，|，^(异或)，&lt;&lt;左移,&gt;&gt;右移,~(按位取反) 按位取反的时候要考虑到数据的字节数，对于一个正数，前面所有的0都要变成1,左移一位相当于2，右移相当于除2。复合位运算(&amp;=，|=等)的结合顺序是*从右向左，除此之外还有(!,~,+,-,前置++/—)也是从右向左结合，比较特殊。 特殊符号 “=”赋值运算，其结合顺序是从右向左且其左侧(lvalue)不能是表达式，只能是变量，数组等 ?:,比如y=(x&gt;=1?1:0)即可表达一个分段函数:y=1(x&gt;=1),y=0(x&lt;1) 逗号表达式，依次计算每个表达式的值，整体等于最后一个逗号后式子的值，如y=(1,2,3+5),则y=8 算法优先级顺序 数据类型转换原则 整型变量和字符变量其在内存中存放的都是整数，整数，存放的是二进制格式，字符，存放的是ASCII码值(","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"如何利用Hexo搭建自己的博客","slug":"Hexo","date":"2022-01-09T16:00:00.000Z","updated":"2022-05-22T04:13:38.123Z","comments":true,"path":"2022/01/10/Hexo/","link":"","permalink":"http://example.com/2022/01/10/Hexo/","excerpt":"","text":"安装Hexo&emsp;&emsp;安装的过程可以参考 Hexo官网。&emsp;&emsp;首先，需要保证安装好了node.js和git，这两个软件的安装也比较简单，直接官网安装就好。然后在命令行窗口中利用以下命令安装hexo，其中g代表对全局安装1npm install hexo-cli-g&emsp;&emsp;然后是新建一个文件夹，这个文件夹将自动生成一些默认的文件,之后的命令行窗口操作都是在该文件夹下进行12hexo init [文件夹名]cd [文件夹名]&emsp;&emsp;然后安装一下需要的依赖（可能就是默认工具包的意思？）1npm install&emsp;&emsp;然后执行1hexo s 部署操作1234hexo chexo s #生成本地预览hexo g #生成静态文章hexo d #上传，必须先执行hexo g 选择一个好看的主题&emsp;&emsp;在 Hexo官网提供了很多主题，选择一个好看的主题后，点击进入主题对应的github中，即可看到相关的命令，仍然在该文件夹下执行命令后即可安装，安装后会在theme文件夹下看到一个对应得主题文件夹，比如这里我选择安装了butterfly主题，就会生成一个对应的文件夹 Butterfly各种参数介绍及实际操作视频，强推这个宝藏UP啊主题操作教程 Markdown写作基础标题123# 一级标题## 二级标题...... 上述代码的执行效果如下： 字体效果1234567**加粗***斜体*~~删除~~==高亮==其他：加两个空格：&amp;emsp;&amp;emsp;（这个还挺麻烦的） 上述代码的执行效果如下：&emsp;&emsp;加粗 &emsp;&emsp;斜体&emsp;&emsp; 删除&emsp;&emsp;==高亮== 引用12&gt;引用内容&gt;&gt;增加&gt;数量可以设置多层引用 上述代码的执行效果如下： 引用内容 增加&gt;数量可以设置多层引用 分割线1*** 上述代码的执行效果如下： 图片和链接123![图片的名字](网上图片的链接或者本地图片的路径)[连接名称](链接地址)比如：[baidu](www.baidu.com) 搭建图床Gitee崩了啊可恶，还是Github香 Github图床搭建操作 公式 可以参考链接：https://blog.csdn.net/weixin_42546496/article/details/88115095","categories":[{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]}],"categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]}