{"meta":{"title":"KIKI's Blog","subtitle":"分享科研总结和生活琐碎","description":"一只努力减脂的KI","author":"KIKI","url":"http://example.com","root":"/"},"pages":[{"title":"link","date":"2022-01-09T11:44:53.000Z","updated":"2022-01-09T11:45:20.485Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"KIKI的标签页","date":"2022-01-09T11:39:03.000Z","updated":"2022-01-09T11:40:22.946Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"让我来康康这个KI都写了点什么东西","date":"2022-01-09T11:42:22.000Z","updated":"2022-01-11T07:51:17.294Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux项目2","slug":"牛客项目2","date":"2022-12-15T16:00:00.000Z","updated":"2022-12-28T09:27:27.450Z","comments":true,"path":"2022/12/16/牛客项目2/","link":"","permalink":"http://example.com/2022/12/16/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE2/","excerpt":"","text":"进程概述程序程序是包含一系列信息的文件，这些信息描述了如何在运行时创建一个进程： 二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释文件中的其他信息。（ELF可执行连接格式） 机器语言指令：对程序算法进行编码。 程序入口地址：标识程序开始执行时的起始指令位置。 数据：程序文件包含的变量初始值和程序使用的字面量值（比如字符串）。 符号表及重定位表：描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和运行时的符号解析（动态链接）。 共享库和动态链接信息：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态连接器的路径名。 其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。 进程进程是正在运行的程序的实例。是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。程序不占用系统CPU，内存等资源，进程需要占用 可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的各项系统资源。从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。 单道&amp;多道程序设计单道程序，即在计算机内存中只允许一个的程序运行。多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相互穿插运行（宏观上是同时进行的，但实际上每个时刻只能有一个程序在执行），两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。 对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 进程的状态进程状态反映执行过的变化。 这些随着和外界条件而转换进程状态反映执行过的变化。三态模型：就绪态，运行态，阻塞态。五态模型：新建态、就绪态，运行态，阻塞态，终止态。 阻塞态不能直接转换到就绪态，和其他进程抢夺资源再进入运行态 图中没有画出，但就绪态和阻塞态可以直接到达终止态，进入终止态之后就不能再执行了，会释放用户区的数据 查看进程信息命令： ps ajx/auxPID进程ID,PPID父进程ID，PGID组ID，SID会话ID 创建进程进程可以创建新进程，形成进程树打开的终端自身也是一个进程，父进程和子进程是交替运行的子进程会复制父进程的虚拟地址空间，实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。注意：fork之后父子进程共享文件，fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*pid_t fork(void);作用：创建一个子进程返回值：返回两次，一次在父进程，一次在子进程在父进程中，成功：返回子进程的ID，失败：返回-1，设置errno为EAGAIN（进程数达到上限）或ENOME（没有内存）在子进程中，成功：返回0*/#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main() &#123; int num = 10; // 创建子进程 pid_t pid = fork(); //子进程仅执行该行代码之后的代码 // 判断是父进程还是子进程 if(pid &gt; 0) &#123; // printf(&quot;pid : %d\\n&quot;, pid); // 如果大于0，返回的是创建的子进程的进程号，当前是父进程 printf(&quot;i am parent process, pid : %d, ppid : %d\\n&quot;, getpid(), getppid()); printf(&quot;parent num : %d\\n&quot;, num); num += 10; printf(&quot;parent num += 10 : %d\\n&quot;, num); &#125; else if(pid == 0) &#123; // 当前是子进程 printf(&quot;i am child process, pid : %d, ppid : %d\\n&quot;, getpid(),getppid()); printf(&quot;child num : %d\\n&quot;, num); num += 100; printf(&quot;child num += 100 : %d\\n&quot;, num); &#125; // for循环 for(int i = 0; i &lt; 3; i++) &#123; printf(&quot;i : %d , pid : %d\\n&quot;, i , getpid()); sleep(1); &#125; return 0;&#125; 父子进程之间的关系区别： 1.fork()函数的返回值不同 父进程中: &gt;0 返回的子进程的ID 子进程中: =0 2.pcb中的一些数据 当前的进程的id pid 当前的进程的父进程的id ppid 信号集 共同点： 某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作 - 用户区的数据 - 文件描述符表 父子进程对变量是不是共享的？ - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。 - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。 有名管道（FIFO）匿名管道由于没有名字，因此只能用于亲缘关系的进程间通信 内存映射将硬件中的物理位置映射到内存中，实现通信12#include&lt;sys/mman.h&gt;mmap,munmapvoid mmap(void addr, size_t length, int prot, int flags,int fd, off_t offset);功能：将一个文件或者设备的数据映射到内存中参数： void *addr: NULL, 由内核指定，指映射到内核中的地址length : 要映射的数据的长度，这个值不能为0。建议使用文件的长度。（获取文件的长度：stat lseek）prot : 对申请的内存映射区的操作权限 PROT_EXEC ：可执行的权限 PROT_READ ：读权限 PROT_WRITE ：写权限 PROT_NONE ：没有权限要操作映射内存，必须要有读的权限。PROT_READ（读）、PROT_READ|PROT_WRITE（读写） flags : MAP_SHARED : 映射区的数据会自动和磁盘文件进行同步，进程间通信，必须要设置这个选项 MAP_PRIVATE ：不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建 fd: 需要映射的那个文件的文件描述符，通过open得到，open的是一个磁盘文件注意：文件的大小不能为0，open指定的权限不能和prot参数有冲突。prot的权限必须小于open的权限，且必须有read权限prot: PROT_READ, open:只读/读写prot: PROT_READ | PROT_WRITE, open:读写 offset：偏移量，一般不用。必须指定的是4k的整数倍，0表示不偏移。 返回值： 返回创建的内存的首地址失败返回MAP_FAILED，(void *) -1 int munmap(void *addr, size_t length);功能：释放内存映射参数： addr : 要释放的内存的首地址length : 要释放的内存的大小，要和mmap函数中的length参数的值一样。 使用内存映射实现进程间通信： 有关系的进程（父子进程）还没有子进程的时候：通过唯一的父进程，先创建内存映射区有了内存映射区以后，创建子进程：父子进程共享创建的内存映射区 没有关系的进程间通信准备一个大小不是0的磁盘文件进程1 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针进程2 通过磁盘文件创建内存映射区，得到一个操作这块内存的指针，使用内存映射区通信 注意：内存映射区通信，是非阻塞。 设置定时器setitimer12include &lt;sys/time.h&gt;int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value); 功能： 设置定时器（闹钟）。可以替代alarm函数。精度微妙us，可以实现周期性定时参数：which : 定时器以什么时间计时 ITIMER_REAL: 真实时间，时间到达，发送 SIGALRM 常用 ITIMER_VIRTUAL: 用户时间，时间到达，发送 SIGVTALRM ITIMER_PROF: 以该进程在用户态和内核态下所消耗的时间来计算，时间到达，发送 SIGPROF new_value: 设置定时器的属性12345678struct itimerval &#123; // 定时器的结构体struct timeval it_interval; // 每个阶段的时间，间隔时间struct timeval it_value; // 延迟多长时间执行定时器&#125;;struct timeval &#123; // 时间的结构体 time_t tv_sec; // 秒数 suseconds_t tv_usec; // 微秒 &#125;;过10秒后，每个2秒定时一次old_value ：记录上一次的定时的时间参数，一般不使用，指定NULL 返回值： 成功 0失败 -1 并设置错误号 捕捉信号123#include &lt;signal.h&gt; typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); 功能：设置某个信号的捕捉行为，SIGKILL SIGSTOP不能被捕捉，不能被忽略。参数： signum: 要捕捉的信号,一般使用宏值handler: 捕捉到信号要如何处理 SIG_IGN ： 忽略信号 SIG_DFL ： 使用信号默认的行为 回调函数 : 这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号。 需要程序员实现，提前准备好的，函数的类型根据实际需求，看函数指针的定义 不是程序员调用，而是当信号产生，由内核调用 函数指针是实现回调的手段，函数实现之后，将函数名放到函数指针的位置就可以了。 返回值： 成功，返回上一次注册的信号处理函数的地址。（sighandler_t）类型第一次调用返回NULL失败，返回SIG_ERR，设置错误号 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;sys/time.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;signal.h&gt;void myalarm(int num) &#123; printf(&quot;捕捉到了信号的编号是：%d\\n&quot;, num); printf(&quot;xxxxxxx\\n&quot;);&#125;// 过3秒以后，每隔2秒钟定时一次int main() &#123; // 注册信号捕捉 // signal(SIGALRM, SIG_IGN); // signal(SIGALRM, SIG_DFL); // void (*sighandler_t)(int); 函数指针，int类型的参数表示捕捉到的信号的值。 signal(SIGALRM, myalarm); struct itimerval new_value; // 设置间隔的时间 new_value.it_interval.tv_sec = 2; new_value.it_interval.tv_usec = 0; // 设置延迟的时间,3秒之后开始第一次定时 new_value.it_value.tv_sec = 3; new_value.it_value.tv_usec = 0; int ret = setitimer(ITIMER_REAL, &amp;new_value, NULL); // 非阻塞的 printf(&quot;定时器开始了...\\n&quot;); if(ret == -1) &#123; perror(&quot;setitimer&quot;); exit(0); &#125; getchar(); return 0;&#125; 信号集和相关函数定义 用户通过键盘 Ctrl + C, 产生2号信号SIGINT (信号被创建) 信号产生但是没有被处理 （未决）在内核中将所有的没有被处理的信号存储在一个集合中 （未决信号集）SIGINT信号状态被存储在第二个标志位上这个标志位的值为0， 说明信号不是未决状态这个标志位的值为1， 说明信号处于未决状态 这个未决状态的信号，需要被处理，处理之前需要和另一个信号集（阻塞信号集），进行比较阻塞信号集默认不阻塞任何的信号，如果想要阻塞某些信号需要用户调用系统的API 在处理的时候和阻塞信号集中的标志位进行查询，看是不是对该信号设置阻塞了如果没有阻塞，这个信号就被处理如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号就被处理 函数以下信号集相关的函数都是对自定义的信号集进行操作。 int sigemptyset(sigset_t set);int sigfillset(sigset_t set); 功能：将信号集中的所有的标志位置为0(sigemptyset)将信号集中的所有的标志位置为1(sigfillset)参数：set, 传出参数，需要操作的信号集返回值：成功返回0， 失败返回-1 int sigaddset(sigset_t set, int signum);int sigdelset(sigset_t set, int signum); 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号参数：set：传出参数，需要操作的信号集signum：需要设置阻塞的那个信号(sigaddset)需要设置不阻塞的那个信号(sigdelset)返回值：成功返回0， 失败返回-1 int sigismember(const sigset_t *set, int signum); 功能：判断某个信号是否阻塞参数：set：需要操作的信号集signum：需要判断的那个信号返回值： 1 ： signum被阻塞 0 ： signum不阻塞 -1 ： 失败 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;signal.h&gt;#include &lt;stdio.h&gt;int main() &#123; // 创建一个信号集 sigset_t set; // 清空信号集的内容 sigemptyset(&amp;set); // 判断 SIGINT 是否在信号集 set 里 int ret = sigismember(&amp;set, SIGINT); if(ret == 0) &#123; printf(&quot;SIGINT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGINT 阻塞\\n&quot;); &#125; // 添加几个信号到信号集中 sigaddset(&amp;set, SIGINT); sigaddset(&amp;set, SIGQUIT); // 判断SIGINT是否在信号集中 ret = sigismember(&amp;set, SIGINT); if(ret == 0) &#123; printf(&quot;SIGINT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGINT 阻塞\\n&quot;); &#125; // 判断SIGQUIT是否在信号集中 ret = sigismember(&amp;set, SIGQUIT); if(ret == 0) &#123; printf(&quot;SIGQUIT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGQUIT 阻塞\\n&quot;); &#125; // 从信号集中删除一个信号 sigdelset(&amp;set, SIGQUIT); // 判断SIGQUIT是否在信号集中 ret = sigismember(&amp;set, SIGQUIT); if(ret == 0) &#123; printf(&quot;SIGQUIT 不阻塞\\n&quot;); &#125; else if(ret == 1) &#123; printf(&quot;SIGQUIT 阻塞\\n&quot;); &#125; return 0;&#125; int sigprocmask(int how, const sigset_t set, sigset_t oldset); 功能：将自定义信号集中的数据设置到内核中（设置阻塞，解除阻塞，替换）参数：how : 如何对内核阻塞信号集进行处理 SIG_BLOCK: 将用户设置的阻塞信号集添加到内核中，内核中原来的数据不变 假设内核中默认的阻塞信号集是mask， 这个操作相当于 mask = mask | set(set中需要设置阻塞的信号位设置为1) SIG_UNBLOCK: 根据用户设置的数据，对内核中的数据进行解除阻塞，相当于mask = mask &amp;= ~set(set中需要设置解除阻塞的信号位设置为1) SIG_SETMASK:覆盖内核中原来的值 set ：已经初始化好的用户自定义的信号集oldset : 保存设置之前的内核中的阻塞信号集的状态，可以是 NULL返回值：成功：0,失败：-1,设置错误号：EFAULT、EINVAL int sigpending(sigset_t *set); 功能：获取内核中的未决信号集参数：set,传出参数，保存的是内核中的未决信号集中的信息。 sigaction12#include &lt;signal.h&gt;int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact); 功能：检查或者改变信号的处理。信号捕捉参数： signum : 需要捕捉的信号的编号或者宏值（信号的名称）act ：捕捉到信号之后的处理动作oldact : 上一次对信号捕捉相关的设置，一般不使用，传递NULL 返回值：成功 0, 失败 -1 12345678910111213 struct sigaction &#123; // 函数指针，指向的函数就是信号捕捉到之后的处理函数 void (*sa_handler)(int); // 不常用 void (*sa_sigaction)(int, siginfo_t *, void *); // 临时阻塞信号集，在信号捕捉函数执行过程中，临时阻塞某些信号。 sigset_t sa_mask; // 使用哪一个信号处理对捕捉到的信号进行处理 // 这个值可以是0，表示使用sa_handler,也可以是SA_SIGINFO表示使用sa_sigaction int sa_flags; // 被废弃掉了 void (*sa_restorer)(void);&#125;; SIGCHLD信号SIGCHLD信号产生的3个条件： 子进程结束 子进程暂停了 子进程继续运行都会给父进程发送该信号，父进程默认忽略该信号。使用SIGCHLD信号解决僵尸进程的问题 共享内存允许两个或多个进程共享物理内存中同一块区域，只需内核介入，效率更高，和管道，内存映射比更快。因为管道和内存映射都需要用户和内核之间的切换和数据拷贝。 使用步骤： 调用shmget()创建一个新的共享内存段或取得一个现有的共享内存段的标识符。这个调用返回需要用到的共享内存标识符。 使用shmat()来附上共享内存段，使该段成为调用进程的虚拟内存的一部分。即，将上述共享内存段与进程绑定，可以通过进程的虚拟内存访问该共享内存段。 此刻在程序中可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由 shmat() 调用返回的 addr 值，它是一个指向进程的虚拟地址空间中该共享内存段的起点的指针。 调用 shmdt() 来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存了。这一步是可选的，并且在进程终止时会自动完成这一步。 调用 shmctl() 来删除共享内存段。只有当当前所有附加内存段的进程都与之分离之后内存段才会销毁。只有一个进程需要执行这一步。 操作函数shmgetshmget(key_t key, size_t size, int shmflg);功能：创建一个新的共享内存段，或者获取一个既有的共享内存段的标识。新创建的内存段中的数据都会被初始化为0参数： key : key_t类型是一个整形，通过这个找到或者创建一个共享内存。一般使用16进制表示，非0值size: 共享内存的大小shmflg: 属性 访问权限 附加属性：创建/判断共享内存是不是存在 创建：IPC_CREAT 判断共享内存是否存在：IPC_EXCL , 需要和IPC_CREAT一起使用(IPC_CREAT | IPC_EXCL | 0664）即先判断，不存在的时候创建 返回值：失败：-1 并设置错误号, 成功：&gt;0 返回共享内存的引用的ID，后面操作共享内存都是通过这个值。 shmatvoid shmat(int shmid, const void shmaddr, int shmflg);功能：和当前的进程进行关联参数： shmid : 共享内存的标识（ID）,由shmget返回值获取shmaddr: 申请的共享内存的起始地址，指定NULL，内核指定shmflg : 对共享内存的操作 读 ： SHM_RDONLY, 必须要有读权限 读写： 0，即默认有读写权限 返回值：成功：返回共享内存的首（起始）地址。 失败(void *) -1 shmdtint shmdt(const void *shmaddr); 功能：解除当前进程和共享内存的关联参数：shmaddr：共享内存的首地址返回值：成功 0， 失败 -1 shmctlint shmctl(int shmid, int cmd, struct shmid_ds *buf);功能：对共享内存进行操作。删除共享内存，共享内存要删除才会消失，创建共享内存的进行被销毁了对共享内存是没有任何影响。参数： shmid: 共享内存的IDcmd : 要做的操作 IPC_STAT : 获取共享内存的当前的状态 IPC_SET : 设置共享内存的状态 IPC_RMID: 标记共享内存被销毁 buf：需要设置或者获取的共享内存的属性信息 IPC_STAT : buf存储数据 IPC_SET : buf中需要初始化数据，设置到内核中 IPC_RMID : 没有用，NULL key_t ftokkey_t ftok(const char *pathname, int proj_id);功能：根据指定的路径名，和int值，生成一个共享内存的key参数： pathname:指定一个存在的路径:/home/nowcoder/Linux/a.txt/proj_id: int类型的值，但是这系统调用只会使用其中的1个字节范围 ： 0-255 一般指定一个字符 ‘a’ read.c12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.获取一个共享内存,第二个参数可以写0，表示是获取而不是创建一个 int shmid = shmget(100, 0, IPC_CREAT); printf(&quot;shmid : %d\\n&quot;, shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); // 3.读数据 printf(&quot;%s\\n&quot;, (char *)ptr); printf(&quot;按任意键继续\\n&quot;); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0;&#125;write.c123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;#include &lt;string.h&gt;int main() &#123; // 1.创建一个共享内存 int shmid = shmget(100, 4096, IPC_CREAT|0664); printf(&quot;shmid : %d\\n&quot;, shmid); // 2.和当前进程进行关联 void * ptr = shmat(shmid, NULL, 0); char * str = &quot;helloworld&quot;; // 3.写数据,+1是拷贝字符串结束符 memcpy(ptr, str, strlen(str) + 1); printf(&quot;按任意键继续\\n&quot;); getchar(); // 4.解除关联 shmdt(ptr); // 5.删除共享内存 shmctl(shmid, IPC_RMID, NULL); return 0;&#125; 相关问题问题1：操作系统如何知道一块共享内存被多少个进程关联？ 共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattchshm_nattach 记录了关联的进程个数 问题2：可不可以对共享内存进行多次删除 shmctl 可以的因为shmctl 标记删除共享内存，不是直接删除什么时候真正删除呢?当和共享内存关联的进程数为0的时候，就真正被删除当共享内存的key为0的时候，表示共享内存被标记删除了如果一个进程和共享内存取消关联，那么这个进程就不能继续操作这个共享内存。也不能进行关联。 共享内存和内存映射的区别 共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外） 共享内存效果更高 内存所有的进程操作的是同一块共享内存。内存映射，每个进程在自己的虚拟地址空间中有一个独立的内存。 数据安全进程突然退出:共享内存还存在,内存映射区消失运行进程的电脑死机，宕机了:数据存在在共享内存中，没有了,内存映射区的数据 ，由于磁盘文件中的数据还在，所以内存映射区的数据还存在。 生命周期内存映射区：进程退出，内存映射区销毁共享内存：进程退出，共享内存还在，标记删除（所有的关联的进程数为0），或者关机如果一个进程退出，会自动和共享内存进行取消关联。 守护进程","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"Linux项目","slug":"牛客项目","date":"2022-12-13T16:00:00.000Z","updated":"2022-12-15T08:00:00.908Z","comments":true,"path":"2022/12/14/牛客项目/","link":"","permalink":"http://example.com/2022/12/14/%E7%89%9B%E5%AE%A2%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"Linux命令cp file1 path 复制文件到指定路径，如果是目录，不能直接复制，要加上 -rmkdir生成文件夹rm删除，可以通过*实现条件删除mv 移动文件或重命名文件touch 创建一个文件ls -l 列出当前文件夹下文件信息，后可输入文件名，只列出某个文件信息 GCC工作流程 从源代码生成可执行程序的过程，需经历 4 个过程，分别是预处理、编译、汇编和链接。 预处理包括导入头文件，并对相应函数进行复制，宏定义等进行替换，去掉注释 编译生成汇编代码 汇编后生成机器可识别的代码，其本质为二进制文件，但由于尚未经过链接操作，所以无法直接运行。 连接就是将同一项目中各源文件生成的目标文件以及程序中用到的库文件整合为一个可执行文件。通过使用以下命令实现每个过程。但是可以跳过一些步骤，如可以直接通过-c，实现预处理，编译和汇编，直接从源代码生成目标代码。实际使用时并不关心这些流程，因此可以直接通过gcc或g++,从源代码生成可执行程序（用gcc编译C，g++编译C++程序）如果不通过-o指定输出文件名，默认生成a.out。指定宏，可以用于控制调试时输出，发布时不输出某些信息。库静态库在连接阶段被复制到程序中动态库在运行时由系统动态加载到内存中供程序调用。优势：代码保密（C++程序反编译之后，还原程度很低），方便部署和分发。静态库的制作 首先将源文件通过gcc -c 生成.o文件 将.o文件打包，使用ar工具Linux：libxxx.a前缀lib和后缀.a是固定的，Windows的后缀是lib,一定记得加.a和.o的后缀1ar rcs libxxx.a xxx.o xxx.o 注意静态库的名称是xxx，不需要包含lib3.编译用到静态库的代码，注意静态库需要有一个头文件.h（指明了静态库中的函数名称和参数类型）配合使用。假设现有如下文件结构 ├── include│ └── head.h├── lib│ └── libjisuan├── main.c└── src ├── add.c ├── add.o ├── div.c ├── div.o ├── libjisuan.a ├── mult.c ├── mult.o ├── sub.c └── sub.o 我们需要编译main.c使用如下指令，其中-I指明了头文件head.h位于./include目录下，-L指定了搜索库的路径为./src -l指定库的名称，是jisuan而不是libjisuan1gcc main.c -I ./include -L ./src -l jisuan然后执行即可，执行的时候不需要用gcc 动态库的制作Linux：libxxx.so前缀lib和后缀.so是固定的，Windows的后缀是dll12gcc -c -fpic/-fPIC a.c b.c //得到和位置无关的代码gcc - shared a.o b.o -o libcalc.so //得到动态库 Makefile自定义变量：变量名= 变量值，用$（变量名）获取变量值预定义变量：AR 归档维护程序的名称，默认值arCC C编译器的名称，默认值ccCXX：C++编辑器的名称$@:目标的完整名称$&lt;:第一个依赖文件$^:所有依赖文件 $(wildcard PATTERN…)如 $(wildcard .c ./sub/ .c)获取当前目录下的.c文件和sub目录下 的.c文件都返回，多个目录用空格隔开 $(patsubst &lt; pattern &gt;, &lt; replacement &gt;, &lt; &gt;) GDB测试通常，在为调试而编译时，我们会(）关掉编译器的优化选项（-o)，并打开调试选项(-g)。另外， ‘-wall`在尽量不影响程序行为的情况下选项打开所有warning，也可以发现许多问题，避免一些不必要的 BUG。输出时加上-g调试，在可执行文件中加入源代码信息 gcc -g -wall program.c -o program ‘-g’选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证gdb能找到源文件。 启动与退出gdb 可执行程序quit 给程序设置参数/获取设置参数set args 10 20show args 使用帮助help 查看文件set nu 显示代码行号 查看当前文件 list/简写l 显示代码，一次显示10行，如果有main函数，main函数在中间 list/l 行号/函数名 显示该行/该函数上下几行的代码 查看非当前文件 list/l 文件名：行号 list/l 文件名：函数名 查看并设置每次查看多少代码 查看 show list/listsize 设置set list/listsize 行数 设置断点 调试命令 n 不会进入函数体,s/step会进入函数体 文件IO从内存角度来看：输入：从文件中读入数据，输出：将内存中数据写入文件标准C库是可以跨平台使用的，库在封装的时候针对不同平台采用不用平台各自的API即标准C库通过调用LINUX的API实现调用 fopen返回FILE *fp 文件指针包含3个部分： 文件描述符（整形） 文件读写指针位置 I/O缓冲区（内存地址），提高执行效率，修改先保存到缓冲区，通过缓冲区（默认8192byte）写入磁盘，避免频繁写入磁盘，而LINUX本身的API没有缓冲区，效率低，但实时性高。 文件描述符表是一个数组，用于管理打开的多个文件大小默认是1024，每个进程都有一个文件描述符表，即一个进程最多可以同时打开1021个文件，其前3个位置是被占用的（标准输入，输出，错误），对应当前设备终端同一文件可以被打开多次，如果不释放，再打开，则同一个文件会占用不同的文件描述符LINUX会把所有东西都变成一个文件，包括设备等也会虚拟为一个文件， Linux系统IO函数open&amp;closeint open(const char pathname, int flags);int open(const char pathname, int flags,mode_t mode);参数： pathname：要打开的文件路径flags: 必选项（3选1）：O_RDONLY（只读），O_WRONLY（只写），O_RDWR（可读写）+可选项（可有可无）：如O_CREAT(文件不存在时创建)等，有可选项时用|（或）：O_RDONLY|O_CREATmode_t: 8进制数，表示用户对于新创建的文件的操作权限 比如：0775 （111 111 101）第一个0表示是8进制数，后面3位，相当于9个二进制数，对应三组（当前用户，用户所在组，其他组）的rwx权限,每位代表一种权限，r,w分别是读写，x表示可执行。计算时，需要与~umask取与：mode &amp; ~umask，umask表示当前用户自身的权限，0777表示最高权限，因为9位都是1，取反后进行与，作用是抹去当前用户的某些权限，可以认为设置umask 终端直接输入umask xxx即可。 Linux中会有一个全局变量errno,记录的是最近的错误号，perror（const char*s）函数打印错误信息，参数s是人为给定的，提示符而已，如perror(“open”)，显示:open:错误信息 返回值： 成功：返回实际读取到的字节数，&gt;0表示实际读取到的字节数，=0表示文件读取完了失败：返回-1，设置errno int close(int fd); read&amp;writessize_t read(int fd,void *buf,size_t count);参数： fd：文件描述符，open得到buf：缓冲区，存放读取到的数据的地方，数组的地址count: 指定的数组的大小 返回值： 成功：返回实际读取到的字节数，&gt;0表示实际读取到的字节数，=0表示文件读取完了失败：返回-1，设置errno ssize_t write(int fd,const void *buf,size_t count);参数： fd：文件描述符，open得到buf：要写入的数据count: 要写的数据的实际大小 返回值： 成功：写入字节数失败：返回-1，设置errno 1234567891011121314151617181920212223242526272829303132#include&lt;unistd.h&gt;#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;int main()&#123; //打开源文件 int srcfd = open(&quot;english.txt&quot;,O_RDONLY); if(srcfd==-1)&#123; perror(&quot;open&quot;);//这里的open只是人为设置的 return -1; &#125; //创建目标文件并打开 int desfd = open(&quot;cpy.txt&quot;,O_WRONLY|O_CREAT ,0664); if(srcfd==-1)&#123; perror(&quot;open&quot;); return -1; &#125; //读取源文件，存放在buf数组中 char buf[1024]=&#123;0&#125;; int len = 0; while((len = read(srcfd,buf,sizeof(buf)))&gt;0)&#123; //将buf中的内容写入目标文件，当len=0表示读取完了 write(desfd,buf,len); &#125; close(desfd); close(srcfd); return 0;&#125; lseekoff_t lseek(int fd,off_t offset,int whence)参数： fd：文件描述符，open得到offset: 偏移量whence: SEEK_SET（设置文件指针为offset）,SEEK_CUR（设置偏移量为从当前位置+offset）,SEEK_END（设置偏移量为文件的大小+offset） 返回值： off_t类型，即返回文件指针的位置 可以用来指定文件指针的位置，如： lseek(fd,0,SEEK_SET)指向文件头 lseek(fd,0,SEEK_CUR)获取当前文件指针位置 lseek(fd,0,SEEK_END)获取文件长度 lseek(fd,100,SEEK_END)拓展文件长度，增加了100字节 stat&amp;lstatint stat(const char pathname, struct stat statbf);int lstat(const char pathname, struct stat statbf); 作用：获取文件相关信息，Linux中有命令stat，也可以实现一样的功能更改指文件内容改变，改动指文件权限改变. lstat获取软连接的信息. 参数： pathname：文件路径statbf: 结构体变量，保存获取到的文件信息 返回值： 成功返回0，失败返回-1，设置错误值errno access&amp;chmod&amp;chownint access(const char *pathname,int mode);判断文件是否存在以及是否有某项权限，指当前进程对该文件的权限参数： pathname: 判断的文件路径 mode: R_OK: 判断是否有读权限 W_OK: 判断是否有写权限 X_OK: 判断是否有执行权限 F_OK: 判断文件是否存在 返回值： 成功返回0， 失败返回-1 int chmod(const char *pathname, mode_t mode);修改文件的权限参数： pathname: 需要修改的文件的路径 mode:需要修改的权限值，八进制的数 返回值： 成功返回0，失败返回-1 int truncate(const char *path, off_t length);缩减或者扩展文件的尺寸至指定的大小参数： path: 需要修改的文件的路径 length: 需要最终文件变成的大小 返回值： 成功返回0， 失败返回-1","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"时序预测(1)————Deep AR","slug":"时序预测(1)——Deep AR","date":"2022-07-07T16:00:00.000Z","updated":"2022-07-08T08:09:44.771Z","comments":true,"path":"2022/07/08/时序预测(1)——Deep AR/","link":"","permalink":"http://example.com/2022/07/08/%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B(1)%E2%80%94%E2%80%94Deep%20AR/","excerpt":"","text":"应用实例代码github相关博客 数据预处理对应preprocess-elect.py文件代码写的十分完备，包含了数据集的下载，如果已经下载好，只需将文件放在./data/elect/下即可。数据由txt文件存储，记录了2011 ~2014期间欧洲地区370个家庭的用电量，采样频率为 15分钟,但在训练时是以一个小时为单位取的，数据集如下图所示，其中部分用户在2011年并没有入住，所以用电量从0开始。12data_frame = pd.read_csv(csv_path, sep=&quot;;&quot;, index_col=0, parse_dates=True, decimal=&#x27;,&#x27;)data_frame = data_frame.resample(&#x27;1H&#x27;,label = &#x27;left&#x27;,closed = &#x27;right&#x27;).sum()[train_start:test_end]pd.read_csv:seq是分隔符，这里为‘;’,decimal是指小数点，是字符串类型，默认就是’.’，由于是欧洲国家，小数点不是’.’，而是’,’,因此需要用参数指定，index_col=0指第一列为索引，parse_dates指将该索引变为时间类型。dataframe.resample:用于重新采样的函数，label指用哪一边来标记数据，比如这里按‘1H’，即一个小时采样后，用最左边的标志，即2011-01-01 00：00：00，如果改为right则为2011-01-01 01：00：00，closed指闭区间的范围，除了‘M’、‘A’、‘Q’、‘BM’、‘BA’、‘BQ’和‘W’之外，所有频率偏移的默认值都是‘left’，它们的默认值都是‘right’。这里把H也改为right。也就是把01：00：00算在0~1这一个小时内，右边界是闭的，如果改为left,则01：00：00算在1~2小时这个区间内。 官方文档比较有意思的是，分钟不是M，M表示的是月，分钟是T。 12345data_frame.fillna(0, inplace=True)#填充缺失值covariates = gen_covariates(data_frame[train_start:test_end].index, num_covariates)#自定义函数得到协变量train_data = data_frame[train_start:train_end].values#.values,将dataframe转化为数组test_data = data_frame[test_start:test_end].valuesdata_start = (train_data!=0).argmax(axis=0) 协变量函数，返回值数组，形状：(32304,4),其中第一列全为0，因为没有指定，后面三列分别为日，小时，月，并且每列进行了归一化，用到了stats库，来自Scipy,SciPy 是一个开源的 Python 算法库和数学工具包。Scipy 是基于 Numpy 的科学计算库，用于数学、科学、工程学等领域，很多有一些高阶抽象和物理模型需要使用 Scipy。123456789def gen_covariates(times, num_covariates): covariates = np.zeros((times.shape[0], num_covariates)) for i, input_time in enumerate(times): covariates[i, 1] = input_time.weekday()#+1之后才是真实值，比如2011-01-01这天是星期6，但是函数返回值是5，不过这并不影响 covariates[i, 2] = input_time.hour covariates[i, 3] = input_time.month for i in range(1,num_covariates): covariates[:,i] = stats.zscore(covariates[:,i]) return covariates[:, :num_covariates]","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"随笔","slug":"随笔","date":"2022-06-29T16:00:00.000Z","updated":"2022-06-30T08:19:31.667Z","comments":true,"path":"2022/06/30/随笔/","link":"","permalink":"http://example.com/2022/06/30/%E9%9A%8F%E7%AC%94/","excerpt":"","text":"祝我自己健健康康/2019.9.8，转自QQ空间日志/我也不知道怎么说，也不能说是突然想写一篇日志，其实也想好久了，但是不知道怎么开头，也不知道自己到底要写什么，就连打开写日志这个窗口都感觉要比写说说要复杂很多，只是觉得可能自己有很多话要说，所以就想写一篇长长的东西，时间过得真么快啊，就已经20了，完全没想到当年从九岁变成十岁，如今从19变成20会过得这么快。 其实想写这些的原因就是因为暑假的时候做了人生中的第一次手术，为什么说是第一次，而不是第一个呢？因为一次就做了五个，可能我也没跟很多人说啦，但是就自己身体出现了一些问题，虽然都不是什么特别大的事情，但是就做手术本身也算是件大事，或多或少对自己的心态上会产生一些触动，也因为做了手术之后无所事事的一个暑假，我也有机会开始仔细去想自己的一些事情。 20岁于我而言是一个比较尴尬的年龄吧，很多事情也想不明白，没有到而立之年，但是也永远不可能像一个十岁的孩子一样去拒绝去想一些即将发生的事情，就好比我现在已经大三，但是我似乎对自己的未来没有什么特别明确的规划，当我遇到一件我自己不懂的事情，我还是去想我要不要去问一下别人，然后别人给我的答案，好像总感觉还是那么的模糊，我对许多事情还是得不到一个确切的说法。 就好比虽然已经学了两年的机械，但是我好像还是回答不了“你这个专业将来是做什么的”这个问题。我看到周围的同学都在忙，我不知道他们在忙什么，感觉全世界好像只有自己不知道该干什么，在过去的两年，我体验了自己想去体验的事情，但是总有一些事情就我不知道怎么去下手，我或许想做或不想做我自己也说不清楚，我不再像十几岁的时候那样，对一件事有很高的热情，好像现在所有的事情对我来说就都是那种。嗯，还行，可以吧，没有一个很确切的态度，也没有一个很明确的情绪。 前段时间我去看过一次心理医生，说是中度抑郁，可是我感觉我过的还行，只是好像到了一个也不算成熟，但是总觉得到了一个对什么都没有了好奇心的状态，这可能就是所谓的变老了吧表情我发现我开始很在意我的家人，会好奇自己前两年是怎么做到一个月可以不跟家里打一个电话的那种状态，也因为这种在意，我会在这个暑假里跟他们走的格外的近，我发现其实我弟现在十岁，也是从九岁到十岁这个十位数要发生改变的年龄，他好像还有很多事情是希望被我知道，但是我之前都没有关注到的，我会跟他聊很多，很多之前我可能不太感兴趣的东西，然后我才知道很多事情和我想的也不一样，他也有他自己的问题和烦恼，我就在好奇，十年前我自己是什么样子？我原以为小孩子都是那种没心没肺的，天天很快乐的样子，但是当我弟很严肃的跟我说起一些关于自己的事情的时候，我会发现好像也没我想象的那么简单，我也会跟我妈聊，我发现成年人的世界真的很复杂，好多从理论上来讲，不会发生争执的事情，倒引发了很大很大的问题，好多，我以为那不明摆的事情吗？但是人们就是不愿意那么做，我会在逛超市的时候，留意那些我不认识的人们的一举一动，他们的语言，他们的一些小动作，好像每个人都有自己的故事，我有时候可以什么都不干，一下午在那里胡思乱想，会开始在意自己的身体健康，甚至可以熟练的说出来十几种几年前可能完全没有听说过的病的名字，会开始不着边际的想一些可能十年20年甚至更久之后可能会发生的一些事情，对很多事变得很佛，很养生，反倒越想越迷茫。算了，就这样吧，明天就是新学期的第一天了，虽然自己其实已经搞了两个星期课设了。 嗯，可能也是因为这个原因，对新学期提不起来什么兴趣，总觉得要放假的一样，因为不知道未来要走向何方，所以也没什么动力和方向，只想简简单单，然后emmm祝家人身体健康愿我十年之后，能…… emmm算了，我不想给自己什么承诺 语音转文字的结果，就是没有逻辑也可以写很多东西 2022.6.30注：其实过了三年来看三年前，应该是大二暑假的这个日志的话，还是多少有些心酸吧，那个时候的心境还是会和现在有很大不同，不过突出的一点就是对于未来的迷茫感，我不是那种会计划很长久的人，本着走一步看一步的想法，应该也是因为如此，所以才会迷茫吧，王天磊跟我聊未来的时候，我会羡慕，他想的好远，想的好周全，可是有些事情，尤其是个人对生活的态度这种事，其实很难改变的，只能说，找点事来做吧，热爱可抵岁月漫长，找不到热爱，只能说，那就收集点面包吧。 迷茫，焦虑，后悔等一些仿佛是自己强加给自己的负面情绪/2022.6.30/ 一切从研究生开始的时候说起 幻想回不去的过去一年过去了，其实给人最大的感觉就是很迷茫，突然就没了目标一样，好在学校不宜久居，缺乏生活气息的环境帮我果断打消了读博的念头，当然还有一个原因是老师确实没有给出一个切实可行的研究计划，所以，眼下摆在面前的似乎只有毕业工作这条路。迷茫，是因为不知道自己要做什么才能毕业，好像每天都在学些东西，看些论文，但是说实话每天的有效学习时间并不长，印象里自己也不是那种坐不住的人，只是缺少一个明确的任务，所以从这点上来说，或许工作了会好一些吧，我常这样安慰自己。偶尔可能会有一两天，突然觉得未来可期，可能是找到了一段觉得还不错的视频，或者有了一点点想法，然后，努力几天后，就又没了下午，我属于那种情绪来的特别快，去的也特别快的人，当然负面情绪好像去的并不快，所以，三分钟热度算是很确切的一种说法，我常常会在周一定好计划，说自己这周开始要早睡，然后，在某天晚上没有早睡之后，就放弃，更多的时候，当我刻意想要早睡的时候，却总是睡不着，脑子里想的最多的，是假如我能回到过去，诸如：假如我能回到过去，我会毫不犹豫的转专业，学个计算机，或者至少不会来西交假如我能回到过去，我会好好学习语文，不那么看重考试成绩，而是考试的错误假如我能回到过去，我会控制饮食，不让自己变胖，以及不让自己近视等等。。。。。。生活中的很多问题，似乎只要带着现在的大脑回去再来一次，就不会犯错，可是，真的会是这样么，其实也无所谓了，每个人应该都会后悔自己做过的某个选择，即使重来一遍，也，好吧，我其实觉得重来一遍是有用的，可惜，回不去的过去告诉我，把握好现在，才能让未来的自己不后悔 无限放大的负面情绪和得失心之前一位好友邀请我做了人格测试，INFP，她很惊讶，她说，想不到我这么乐观外向的人居然是这个，其实，好像成年之后，人才开始慢慢形成更完善的性格，至少，之前初高中的生活过于单调，而人的性格是在不同的生活经历中培养起来的，所以，其实到了大学之后，或者说，到了自己照顾起自己的生活之后，许多情绪便只能自己消化，然后潜移默化的影响着自己的人格从一位朋友生病住院开始，我开启了漫长的与疑病症对抗的生活，虽然最后证明我确实有病，但是，怎么说，至少我感觉我心理层面的问题会更大一点，生病=花很多很多钱=万一挂了怎么办，以及害怕将来家人生病等一系列情绪，其实核心问题还是怕花钱，我感觉这个问题其实也影响到了我看待很多问题的方式，既然说到这里了，就捋一下关系： 因为怕花钱，所以身体有症状之后很担心，害怕是大病，害怕要花大钱，所以不停的去医院，有病就想赶紧治，稍微不舒服，就想看医生，包括一些小病，没有给自己身体适应的过程，结果是，负面情绪太高往往也不利于病情恢复，而且会很绝望 因为怕花钱，考驾照的时候，导致自己特别特别紧张，说实话，我开车倒是真的没那么怕，怕速度快或者怎么样，我就真的是算了一下，挂科之后要花小一千，我就难受，还有就是长期被指责动手能力不行，导致我不管是学车还是金工实习，都有一个很强的先入为主的想法，觉得自己不行，然后那些平日里动手能力很强的人，我会觉得他一定行，不过傲慢与偏见，也算是人之常情，只是，这种潜移默化对别人的评价，真的会刻在骨子里，影响很多很多时候自己的想法，所以，不要PUA别人 因为怕花钱，所以想赚钱，这个逻辑好像也没什么毛病，所以直接导致，研究生之后，成绩被判的很低之后，总是在担心能不能拿到奖学金，进而各种郁闷，以及对一些不合理规则，不公平竞争的埋怨，只是有时候也觉得，为这点钱不至于，不过好像，得失心太重了，接受不了这种落差，前几天看北大数学学院的小姐姐演讲，说总有人在你专业的领域和你喜欢的领域两方面都比你优秀，我们能做的只有优化自己，今天早上其实自己还在想排名这件事以及其派生物内卷给自己带来了多大的苦恼，其实能专注于自己，规划好自己的未来，比起在意别人的想法或许更重要一点。 写到这里其实心情已经好很多了，INFP嘛，哈哈，只是如果再拿一个“良”的话，应该还是会难受一阵子，不过没有那么快的转变嘛，只能说，要学会在经历挫折中，锻炼自己消化情绪的能力 体重其实好久没变了，就像没有起色的科研，和看不到光的未来一样，可是时间不管你的失落，他公平的近乎冷漠的走啊走啊走，村上喜欢跑步，说不必像其他运动一样那么富有竞争性，可以按照自己的节奏来，我其实也挺烦竞争的，只想安稳地按照自己的节奏来，可是当曾经比你胖的人已经比你瘦了，当你认为不如你的人却拿到比你更高的分数的时候，是不吃一顿晚饭然后不顾身体的去跑个6公里么，或者开始新一轮emo为了一分两分悲伤一晚上，然后幻想回到过去么高考结束的时候，我安慰自己一切都是最好的安排，回看过去，长沙和中南带给我的全是美好的回忆，至少现在看来，当然某些时刻还是会悲伤，不过都熬过来了，此时此刻，在抱怨西安，抱怨科研，抱怨各种琐碎的时候，或许回看现在，也会是美好的，考不过驾照的时候，悲伤，我安慰自己人的快乐都是自己给的，不快乐也是。所以，看淡一点吧，或者我应该劝自己，努力看淡一点吧，我爱猴叔对生活的热情，我也渴望做一个热爱生活的人，琐碎的烦恼既然躲不掉，就面对吧，emo的情绪，如果化解不掉，或许可以仔细分析一下情绪的前因后果，然后理清楚了，就有方法了，起码安慰起自己来也有理有据and有用？对，有用。前段时间复习中特，现在就特别喜欢分条罗列，类似于划重点，hhh，大道至简，党的智慧啊，总结一下： 既然过去回不去，那就抓住现在，渴望被打鸡血 不以物喜，不以己悲，完美概括了自己的得失心和想不开，呜呜呜，范仲淹懂我 学会自我调节，整理心情，分析情绪，乐观，热爱生活，就要接收生活的酸甜苦辣咸以上","categories":[{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]},{"title":"剑指Offer(1)——算法和数据结构基础","slug":"剑指Offer","date":"2022-06-05T16:00:00.000Z","updated":"2022-07-17T03:09:27.931Z","comments":true,"path":"2022/06/06/剑指Offer/","link":"","permalink":"http://example.com/2022/06/06/%E5%89%91%E6%8C%87Offer/","excerpt":"","text":"数据结构__数组和字符串03 数组中重复的数字 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例：输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 方法1：原地交换利用题目信息：即在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内。说明数组元素的索引和值是一对多的关系。每个元素最多被交换两次就被送到了对应的位置，所以时间复杂度是O(N)，原地交换，所以空间复杂度是O(1).12345678910class Solution: def findRepeatNumber(self, nums: [int]) -&gt; int: i = 0 while i &lt; len(nums): if nums[i] == i: i += 1 continue if nums[nums[i]] == nums[i]: return nums[i] nums[nums[i]], nums[i] = nums[i], nums[nums[i]] return -1注意最后一行交换两个数时的a,b = c,d赋值语句：Python操作的原理是先暂存元组 (c, d)，然后 “按左右顺序” 赋值给 a 和 b 。因此，若写为 nums[i], nums[nums[i]] = nums[nums[i]],nums[i]，则 nums[i] 会先被赋值nums[nums[i]]，之后赋值时 nums[nums[i]] ，元素索引会出现错误，因为这个时候nums[i]已经被改变1234567nums = [1,2,3,4,5]i = 2 #交换位置2和位置3（nums[2]=3）nums[i],nums[nums[i]]=nums[nums[i]],nums[i]print(nums)#[1,2,4,4,5]发生错误nums = [1,2,3,4,5]nums[nums[i]],nums[i]=nums[i],nums[nums[i]]print(nums)#[1,2,4,3,5]正确 方法2：哈希表没啥好说的，注意哈希表的添加是add就好，然后就是空间复杂度比方法一高。1234567class Solution: def findRepeatNumber(self, nums: [int]) -&gt; int: dic = set() for num in nums: if num in dic: return num dic.add(num) return -1 题目拓展书上给出了进一步的要求，数组长度n+1,包含的数字在1~n范围内，要求不改变原数组的情况下找出重复元素。思路1：新建一个辅助数组，长度也为n+1,然后从原数组往辅助数组拷贝，每次拷贝保证索引和值对应，由于数字是1开始，所以应该保证nums[i]=i+1，然后如果重复的话，直接返回，缺点是空间复杂度。思路2：避免额外空间，二分法，由于1~n共有n个数，而数组长度n+1，所以必然有重复，可以把范围分为1~m和m+1~n，然后分别统计两个范围的数的个数，二分缩小范围。时间复杂度O(nlogn),每次计数复杂度是O（n）,所以是拿时间换空间。这个改进不能拿原题跑了，因为原题长度是n,可取的数也有n个，计数不一定满足。12345678910111213141516171819202122class Solution: def findRepeatNumber(self, nums: List[int]) -&gt; int: def countrange(nums,a,b): count = 0 for i in nums: if a&lt;=i and i&lt;=b: count +=1 return count a = 0 b = len(nums) while b&gt;a: mid = (a+b)//2 res = countrange(nums,a,mid) print(a,mid) if res&gt;mid-a+1: b = mid else: a = mid+1 if b==a: return a 04 二维数组中的查找 在一个 n m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。*示例:现有矩阵 matrix 如下：[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]给定 target = 5，返回 true。给定 target = 20，返回 false。 常规想法可能是先找到在哪一行，然后再找哪一列，但这样其实比较浪费，没有很好的利用本来有序的信息，试想如果其小于某一列的最后一个元素，则必然小于该行下所有行最后一列的元素，这样一次就可以缩小一行或一列了。时间复杂度就降为O(M+N),当然从左下角开始也是一样的，K神的代码相比于从右上角开始j=len(matrix[0])-1，这样写直接省下了判断matrix[0]是否是None12345678class Solution: def findNumberIn2DArray(self, matrix: List[List[int]], target: int) -&gt; bool: i, j = len(matrix) - 1, 0 while i &gt;= 0 and j &lt; len(matrix[0]): if matrix[i][j] &gt; target: i -= 1 elif matrix[i][j] &lt; target: j += 1 else: return True return False 05 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成”%20”。示例：输入：s = “We are happy.”输出：”We%20are%20happy.” 在 Python 和 Java 等语言中，字符串都被设计成「不可变」的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。实现也比较容易。主要难点在于使用C++时，需要改变长度，因此采用倒序遍历，双指针的做法，具体可参考题解。1234567class Solution: def replaceSpace(self, s: str) -&gt; str: res = [] for c in s: if c == &#x27; &#x27;: res.append(&quot;%20&quot;) else: res.append(c) return &quot;&quot;.join(res)补充材料： Python字符串操作字符串用到的join函数 感觉Python字符串很好用的一个操作就是可以直接相加，并且按位索引，很像列表，比如旋转字符串的题可以直接s[n:]+s[:n]，如果不允许用切片的话，就是用列表写了，然后用join函数转换为字符串 还有一个哈希表的事，现在Python3.6之后的字典默认是有序的，也就不需要再定义OrderedDict 数据结构__链表06 从尾到头打印链表 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。示例 1：输入：head = [1,3,2]输出：[2,3,1] 两种方法的时间复杂度和空间复杂度都是O(N) 方法1：辅助栈比较容易就想到了，先进后出的做法。书中指到可以采用反转链表的方式，在面试时，需要与面试官沟通是否可以改变原始输入数据。1234567class Solution: def reversePrint(self, head: ListNode) -&gt; List[int]: stack = [] while head: stack.append(head.val) head = head.next return stack[::-1]方法2：递归12345678910111213141516class Solution:#大佬的简易版 def reversePrint(self, head: ListNode) -&gt; List[int]: return self.reversePrint(head.next) + [head.val] if head else []#自己写的 def reversePrint(self, head: ListNode) -&gt; List[int]: stack = [] def digui(head): if not head: return digui(head.next) stack.append(head.val) digui(head) return stack 数据结构__树07 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。示例：Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]Output: [3,9,20,null,null,15,7] 感觉切片的方法还是很直观且好理解的12345678910111213141516171819# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = None## 切片class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: if preorder: root = TreeNode(preorder[0]) index = inorder.index(preorder[0]) root.left = self.buildTree(preorder[1:index+1],inorder[:index]) root.right = self.buildTree(preorder[index+1:],inorder[index+1:]) return root else: return 大佬写的效率会更高一点，至少不用切片，递归函数三个参数recur(root,left,right)其中第一个参数表示在前序遍历中根节点的索引，后面的left和right对应在中序遍历时，该子树的范围，所以每次先寻找根节点的位置i，然后建立范围，很明显：左子树的根节点在前序遍历中，就在当前根节点下一个位置即root+1左子树本身在中序遍历中，就是left到i的左边，即left~i-1右子树的根节点在前序遍历中，就在左子树的下一个，而左子树的长度，由左子树的范围可知，为i-1-left+1,为i-left，而左子树的起点是root+1,所以右子树根节点就是i-left+root+1右子树本身在中序遍历中，就是i的右边到结尾，即i+1~right 1234567891011121314class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode: def recur(root, left, right): if left &gt; right: return # 递归终止 node = TreeNode(preorder[root]) # 建立根节点 i = dic[preorder[root]] # 划分根节点、左子树、右子树 node.left = recur(root + 1, left, i - 1) # 开启左子树递归 node.right = recur(i - left + root + 1, i + 1, right) # 开启右子树递归 return node # 回溯返回根节点 dic, preorder = &#123;&#125;, preorder for i in range(len(inorder)): dic[inorder[i]] = i return recur(0, 0, len(inorder) - 1) 08 二叉树的下一个节点(力扣题名中序后继)数据结构__栈与队列09 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 做法：辅助栈，每次需要删除的时候，从A栈里pop出所有元素到B栈中，这样A的栈底元素会变到B的栈顶，所以当需要删除栈顶元素时，总是从B开始，当B为空时，从A栈pop出所有元素，比较简单。 时间复杂度：appendTail()函数为 O(1) ；deleteHead() 函数在N次队首元素删除操作中总共需完成N个元素的倒序。空间复杂度O(N)： 最差情况下，栈 A 和 B 共保存N个元素。题解 Python删除元素方法 12345678910111213class CQueue: def __init__(self): self.A, self.B = [], [] def appendTail(self, value: int) -&gt; None: self.A.append(value) def deleteHead(self) -&gt; int: if self.B: return self.B.pop() if not self.A: return -1 while self.A: self.B.append(self.A.pop()) return self.B.pop() 算法操作__递归和循环通常递归代码比较简洁，但是性能不如基于循环的代码，每次调用都需要在内存栈中分配空间以保存参数，返回地址及临时变量，所以效率低。但是在树的遍历的时候，递归比较常用，在没有要求的情况下，尽可能的用递归。还有在比如斐波那契数列这种问题下，使用递归会造成大量的重复计算。递归：函数调用自身如果面试的时候告诉了动态规划的思路后，面试官提醒说在分解子问题的时候，是不是存在特殊的选择，如果采用这个特殊的选择将一定能得到最优解，这个可能在提示用贪婪算法。 10 斐波那契数列和青蛙跳台阶 Those who cannot remember the past are condemned to repeat it.要不要这么哲理啊，哈哈哈 以斐波那契数为例，最容易想到的递归，其实一直在重复调用，造成了很大的时间（重复计算）和空间浪费（保存中间结果）解决办法： 自顶向下，相当于建立了一个备忘录，创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在Memo数组中，下次在调用fib（n）的时候就不会重新递归了。问题就是空间浪费，需要有个数组存放 自下向上，计算fib（6）的时候最后还是要计算出fib（1），fib（2），fib（3）…,那么何不先计算出fib（1），fib（2），fib（3）…,呢？这也就是动态规划的核心，先计算子问题，再由子问题计算父问题。实现了对空间的压缩。 逆向思维：这个我真的是没有青蛙跳楼梯，可以一次跳一个或两个，问跳n阶有几种方案f(n),那其实，他最后一步，要么是跳一个，就有f(n-1)种，要么是跳两个，就有f(n-2)种，f(n) = f(n-1)+f(n-2) 动态规划 123456class Solution: def fib(self, n: int) -&gt; int: a, b = 0, 1 for _ in range(n): a, b = b, a + b return a % 1000000007 青蛙跳台阶只需要把n改为n-1即可，因为斐波那契数列是从0开始，而青蛙从1开始 需要注意的是，python只要内存够不会出现大数溢出的问题，所以可以只在返回结果的时候取余，但是在java等其他语言中，每次计算时都要取余。 青蛙问题java版 1234567891011class Solution &#123; public int numWays(int n) &#123; int a = 1, b = 1, sum; for(int i = 0; i &lt; n; i++)&#123; sum = (a + b) % 1000000007; a = b; b = sum; &#125; return a; &#125;&#125; 算法操作__查找和排序如果面试时要求在排序数组（或者部分排序数组）中查找或统计，可以尝试二分法，排序算法中比较重要的是快排 11 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为 1。注意，数组 [a[0], a[1], a[2], …, a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], …, a[n-2]] 。示例 1：输入：numbers = [3,4,5,1,2]输出：1 比较容易想到二分啦，然后就是看后段（看前半段是判断不了的，比如num[m]&gt;num[i],如果数组没有旋转的话，其实找的数在左半段，但旋转过的话，就在右半段，判断不了）如果num[m]&lt; num[j],这个时候，也就是说后半段是有序的，那么肯定不在后半段中，也有可能恰好就是m，当m是旋转的那个元素时,所以令j=m如果num[m]&gt; num[j],这个时候，肯定就在后半段内，而且不会是m，因为这个元素是大的，肯定是在左半段，所以就令i=m+1比较复杂的就是相等的情况了，这个时候你是判断不了在那一部分的，书中写的是直接从头遍历（不是指原数组，而是当前的[i,j]），k神提到可以直接j=j-1,如果j不是旋转的起始元素，那就不影响，如果恰好是的话，就会有num[m]=num[j],而num[m]之前的数组是递增的（或者不变），那么可以判断num[i]~num[m]都等于num[j],而且由于j就是旋转的那个数字，所以其实接下来的数组就都是左半段了，那继续循环就能找到那个数字了。123456789class Solution: def minArray(self, numbers: [int]) -&gt; int: i, j = 0, len(numbers) - 1 while i &lt; j: m = (i + j) // 2 if numbers[m] &gt; numbers[j]: i = m + 1 elif numbers[m] &lt; numbers[j]: j = m else: j -= 1 return numbers[i] 算法操作__回溯法就有点感觉像是，一条路试一试，不行就再回来试一下另一条，所以多数会涉及置0的操作，也就是设置某个节点为已经访问过，可以用辅助数组存储是否访问过，也可以用一个集合表示，注意的是回溯时，需要把状态复原 12 矩阵中的路径 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 采用深度优先遍历，结束当前路径的条件包括，越界，不相等，由于已经将访问过的元素置为空字符，所以不会存在重复访问的问题，值得注意的是board[i][j] = word[k]，即在遍历后，要把状态复原。 1234567891011121314class Solution: def exist(self, board: List[List[str]], word: str) -&gt; bool: def dfs(i, j, k): if not 0 &lt;= i &lt; len(board) or not 0 &lt;= j &lt; len(board[0]) or board[i][j] != word[k]: return False if k == len(word) - 1: return True board[i][j] = &#x27;&#x27; res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1) board[i][j] = word[k] return res for i in range(len(board)): for j in range(len(board[0])): if dfs(i, j, 0): return True return False 13 机器人的运动范围 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？示例 1：输入：m = 2, n = 3, k = 1输出：3 题解比较突出的一点就是，论证了只需要向下和向右走就可以遍历到所有的可达解，利用集合来保证不重复，然后就是当前位置各数位和的计算，当十位发生变化时，比如19—&gt;20,十位多了1，个位少了9，所以总体-8，对应(i + 1) % 10==0，不进位的话就直接+1就好，结束当前路径的条件包括越界和不满足要求，以及重复。回溯法的代码很相似，都是设置了一个结束条件，这道题由于不涉及修改数据，所以不用复原，防止重复是依靠集合。 深度优先12345678910class Solution: def movingCount(self, m: int, n: int, k: int) -&gt; int: def dfs(i, j, si, sj): if i &gt;= m or j &gt;= n or k &lt; si + sj or (i, j) in visited: return 0 visited.add((i,j)) return 1 + dfs(i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj) + dfs(i, j + 1, si, sj + 1 if (j + 1) % 10 else sj - 8) visited = set() return dfs(0, 0, 0, 0)广度优先就是依靠栈来实现，其实差不多，只是访问的顺序不一致。广度优先1234567891011class Solution: def movingCount(self, m: int, n: int, k: int) -&gt; int: queue, visited = [(0, 0, 0, 0)], set() while queue: i, j, si, sj = queue.pop(0) if i &gt;= m or j &gt;= n or k &lt; si + sj or (i, j) in visited: continue visited.add((i,j)) queue.append((i + 1, j, si + 1 if (i + 1) % 10 else si - 8, sj)) queue.append((i, j + 1, si, sj + 1 if (j + 1) % 10 else sj - 8)) return len(visited) 算法操作__动态规划与贪婪这个其实之前也提到过了，主要是贪婪法在使用的时候需要证明贪婪可以得到最优解。 其中快速取余数的操作，简单证明一下： a^2modc=((amodc)(amodc))modc=(amodc)^2modca^4modc=((a^2modc)*(a^2modc))modc=((amodc)^2modc*(amodc)^2modc)modc然后类似第一个式子，这里的化简结果就相当于把第一个式子的a替换为了(amodc)^2,所以同理我们把a^2modc替换成了((amodc)^2)^2modc=(amodc)^4modc大概是这么个证明过程，主要是奇数和偶数不一样，就是需要把求幂分好多次二分来求，需要二分的此书就是a不断除2，偶数情况下，就是不断的平方取余就好，奇数的话就要多乘一个x。 比如计算x^4modp=(x^2modp)^2modp 先执行x=x^2modp(a=4//2=2),计算括号里的 再执行x=(x^2modp)^2modp(a=2//2=1),计算得到结果 最后，rem=(1*x)modp(a=0) 123456789# 求 (x^a) % p —— 快速幂求余def remainder(x, a, p): rem = 1 while a &gt; 0: if a % 2: rem = (rem * x) % p x = x ** 2 % p a //= 2 return rem 回到题目本身 14 剪绳子 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。请问 k[0]k[1]…*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 证明用到了基本不等式，求解之后发现剪成越多的长度为3的绳子越好，具体证明参考题解,这道题，也可以用动态规划，只是不是一个固定的值，需要去作比较，比如f(4)=f(1)+f(3)=f(2)+f(2),需要比较不同的组合(f(n)=f(a)+f(n-a),循环终止条件是a&lt;n//2) 1234567891011class Solution: def cuttingRope(self, n: int) -&gt; int: if n &lt;= 3: return n - 1 a, b, p, x, rem = n // 3 - 1, n % 3, 1000000007, 3 , 1 while a &gt; 0: if a % 2: rem = (rem * x) % p x = x ** 2 % p a //= 2 if b == 0: return (rem * 3) % p # = 3^(a+1) % p if b == 1: return (rem * 4) % p # = 3^a * 4 % p return (rem * 6) % p # = 3^(a+1) * 2 % p 算法操作__位运算15 二进制中1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。 比较容易陷入死循环（部分语言）的原因是，负数在右移时，是默认补全符号位，也就是会在左边填充1的，但是在控制台输入时，题目进行的是无符号的右移操作，即默认最左边的1不表示符号位，这个就有点迷惑其实，主要还是掌握一下python的变量特点就是会自动根据数值大小，扩充位数，只要内存够，所以包括以上剪绳子时出现的大数问题，都是可以储存下的，反正就是python很奇怪。12345678class Solution: def hammingWeight(self, n: int) -&gt; int: res = 0 while n: res += n &amp; 1 n &gt;&gt;= 1 return res主要是题解里另一种 n&(n-1)的方法 30 包含min函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。主要问题在于怎么找最小的数，这个也是用了一个辅助栈，这个辅助栈用于存放当前栈中最小的数，每次在添加的时候，比较添加的元素和辅助栈栈顶的元素，并添加两者中更小的数到辅助栈中，因为栈是先进先出的，所以，只要后面压入的数比当前辅助栈顶的数大，那么最小数是不会改变的。 时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。空间复杂度：O(n)，其中n为总操作数。最坏情况下，我们会连续插入 nn 个元素，此时两个栈占用的空间为 O(n)。题解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class MinStack: def __init__(self): &quot;&quot;&quot; initialize your data structure here. &quot;&quot;&quot; self.stack = [] self.minstack = [] def push(self, x: int) -&gt; None: if self.minstack:#没有元素时为空 self.minstack.append(min(x,self.minstack[-1]))#和辅助栈自己比 else: self.minstack.append(x) self.stack.append(x) def pop(self) -&gt; None: if self.stack: self.stack.pop() self.minstack.pop() def top(self) -&gt; int: if self.stack: return self.stack[-1] else: return null def min(self) -&gt; int: if self.stack: return self.minstack[-1] else: return null# Your MinStack object will be instantiated and called as such:# obj = MinStack()# obj.push(x)# obj.pop()# param_3 = obj.top()# param_4 = obj.min() 补充知识：None和NULL的区别： None是一个对象，而NULL是一个类型。 Python中没有NULL，只有None，None有自己的特殊类型NoneType。 None不等于0、任何空字符串、False等。 在Python中，None、False、0、””(空字符串)、、()(空元组)、{}(空字典)都相当于False。所以，判断列表为空的时候可以直接用if list: None是Python中的一个关键字，None本身也是个一个数据类型，而这个数据类型就是None，它可0、空字符串以及false均不一样，这些都只是对象，而None也是一个类。 详细参考None if X is not None写法清晰明了，且不会出错，推荐使用；if not x使用前，必须确定X为None、False、””、0、[]、()、{}时对判断无影响。123456x = []y = None print &#x27;X is None测试结果&#x27;print x is None #Falseprint y is None #True Python的赋值操作，上面的一行必须写两个[]，不然会指向同一变量，同样对于 24 反转链表定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。做法就是双指针，注意引入那个临时变量，链表的题，画图画图画图，更改指向后，记得把原来的连接线打岔就好，还有就是不需要再额外加上非空的判断了，空的话直接就是返回None。时间复杂度O(N)，原地变换，空间复杂度O(1)，双指针真的很好用。 题解 123456789101112class Solution: def reverseList(self, head: ListNode) -&gt; ListNode: cur, pre = head, None while cur: tmp = cur.next # 暂存后继节点 cur.next cur.next = pre # 修改 next 引用指向 pre = cur # pre 暂存 cur cur = tmp # cur 访问下一节点 return pre 35 复杂链表的复制请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。题目描述需要看一下题目的图的，比较难理解，就是说要构造一个一模一样的链表，但是存储的地方不一样，主要的问题是Random，在复制时，这个节点很可能还不存在，所以可以考虑先复制所有的节点，Random先初始化为None,然后就是一个指向问题，比较好理解的方法是复制加拆分，画图画图画图。尤其是在拆分的时候，在恢复原链表的时候，最后的指向None,因为复制后，原链表的最后一项是指向复制链表的最后一项的，退出循环后要单独加上一句，将其指向None。还有就是最后的while判断，不能是原链表非空，即while pre，因为假设链表为：3-&gt;3-&gt;7-&gt;7-&gt;null到第一个7的时候，如果是while pre,则第二个7没有下一个节点了，即cur.next.next会报错(cur.next=null，没有next),所以应该是while cur.next，即保证是倒数第二个节点，然后修改原链表中7的指向。正如上一句所说。还有就是在构建random指向的时候，注意判断是否为None,原因都是类似的，因为None没有next，基本都是这个错。 题解 1234567891011121314151617181920212223242526272829class Solution: def copyRandomList(self, head: &#x27;Node&#x27;) -&gt; &#x27;Node&#x27;: if not head: return cur = head # 1. 复制各节点，并构建拼接链表 while cur: tmp = Node(cur.val) tmp.next = cur.next cur.next = tmp cur = tmp.next # 2. 构建各新节点的 random 指向 cur = head while cur: if cur.random: cur.next.random = cur.random.next cur = cur.next.next # 3. 拆分两链表 cur = res = head.next pre = head while cur.next: pre.next = pre.next.next cur.next = cur.next.next pre = pre.next cur = cur.next pre.next = None # 单独处理原链表尾节点 return res # 返回新链表头节点 Day04-05 查找算法 这一部分重要的方法就是二分法，尤其适用于本来内部有序的数组，mid = (a+b)//2，表示向下取整，这个还是有好几个题可以看的 53 I.在排序数组中查找数字统计一个数字在排序数组中出现的次数。输入: nums = [5,7,7,8,8,10], target = 8输出: 2 有序数组基本都用二分法，时间复杂度O(logN) 12345678910class Solution: def search(self, nums: [int], target: int) -&gt; int: def helper(tar): i, j = 0, len(nums) - 1 while i &lt;= j: m = (i + j) // 2 if nums[m] &lt;= tar: i = m + 1 else: j = m - 1 return i return helper(target) - helper(target - 1) i = m+1 和j = m-1的目的是为了保证，如果target存在的话，始终在[i,j]这个区间内，若 nums[m] &lt; targe，则 target 在闭区间[m+1,j]中，因此执行 i = m + 1若 nums[m] &gt; target，则 target 在闭区间[i,m−1]中，因此执行 j = m - 1；若 nums[m] = target，则右边界 right 在闭区间 [m+1, j]中；因此和nums[m] &lt; targe，保持一致，这样保证了右边界在[i,j]这个区间内，但是对于nums[m] &gt; target，的情况，执行j = m-1后，很可能右边界就不在[i,j]内了，这种情况的话右边界就是j+1,不过不用担心的是，循环结束前的最后一次循环一定是i=j,并且如果存在target的话，i和j(i=j=m)指向的都是最右边的target或者右边界,如果指向target,执行i=m+1,刚好指向右边界,如果指向右边界，执行j = m-1,i仍指向右边界。这个比较好理解，i小于等于target时总是往右移，而j只有大于target时才往左移，所以两者都是共同逼近最右边的target特殊情况,就是target比最左边的数还小时，j会不断左移，直到i和j都指向0，此时仍然比target大,j=-1,i=0,同理比最右边的数大时，i会不断右移，最终i=len(nums),最后一行也比较好理解，helper(target)指向比target大的第一个数，helper(target-1)指向比target-1大的第一个数，如果存在target,则刚好指向第一个target,如果不存在，他和helper(target)指向的都是同一个数。 题解","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"Pytorch笔记","slug":"深度学习","date":"2022-05-21T16:00:00.000Z","updated":"2022-07-08T06:59:41.248Z","comments":true,"path":"2022/05/22/深度学习/","link":"","permalink":"http://example.com/2022/05/22/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"深度学习零碎知识激活函数&emsp;&emsp;常用的有如下两种，其中Sigmoid函数饱和时梯度非常小，接近于0，因此容易出现梯度消失现象。ReLu缺点在于反向传播过程中，如果有一个非常大的梯度经过时，反向传播更新后可能导致权重分布中心小于0，使得无法更新权重(此时ReLu后为0，不会再有梯度信息产生)，进入失活状态，且无法恢复。 优化器 SGD优化器： $w_{t+1} = w_t -\\alpha*g(w_t)$容易受样本噪声影响，可能陷入局部最优解。 SGD+Momentum优化器: v_t =\\eta *v_{t-1}+\\alpha*g(w_t),w_{t+1}=w_t-v_t，引入了动量，优化时会考虑上一步的优化方向。 Adagrad，RMSProp，Adam优化器：都属于自适应的优化器，比较接近，但各有不同，Adagrad的学习率下降可能会过快，在收敛前就收敛，RMS相对会慢一点，Adam则更复杂，包含了一阶动量和二阶动量，效果会更好一点。 ToTensor&emsp;&emsp;值得注意的是，在将一个图片或者数组变为Tensor时，会将维度位置发生变化，(H x W x C) 变为 (C x H x W)。123456789class ToTensor: &quot;&quot;&quot;Convert a ``PIL Image`` or ``numpy.ndarray`` to tensor. This transform does not support torchscript. Converts a PIL Image or numpy.ndarray (H x W x C) in the range [0, 255] to a torch.FloatTensor of shape (C x H x W) in the range [0.0, 1.0] if the PIL Image belongs to one of the modes (L, LA, P, I, F, RGB, YCbCr, RGBA, CMYK, 1) or if the numpy.ndarray has dtype = np.uint8 In the other cases, tensors are returned without scaling.&emsp;&emsp;所以如果将tensor再还原时，要交换回来。 损失函数&emsp;&emsp;从下述交叉熵函数的定义可知，其中已经包含了Softmax函数，因此不需要再额外添加。1234567class CrossEntropyLoss(_WeightedLoss): r&quot;&quot;&quot;This criterion combines :class:`~torch.nn.LogSoftmax` and :class:`~torch.nn.NLLLoss` in one single class. It is useful when training a classification problem with `C` classes. If provided, the optional argument :attr:`weight` should be a 1D `Tensor` assigning weight to each of the classes. This is particularly useful when you have an unbalanced training set. OS相关操作os.getcwd() ,返回绝对路径os.path.join(a,b)，拼接路径os.path.abspath()，返回绝对路径，即磁盘中位置../表示返回上级目录，则../..表示上两级目录 123456789101112root = os.getcwd()root1 = os.path.join(root,&quot;../..&quot;)data_root = os.path.abspath(root1) #root：C:\\Users\\asus\\Desktop\\科研\\deep-learning-for-image-processing-master\\pytorch_classification\\Test2_alexnet#root1:C:\\Users\\asus\\Desktop\\科研\\deep-learning-for-image-processing-master\\pytorch_classification\\Test2_alexnet\\../..#data_root：C:\\Users\\asus\\Desktop\\科研\\deep-learning-for-image-processing-masterdata_root = os.path.abspath(os.path.join(os.getcwd(), &quot;../..&quot;)) # get data root pathimage_path = os.path.join(data_root, &quot;data_set&quot;, &quot;flower_data&quot;) # flower data set path os.getcwd(),返回当前工作目录#image_path：&#x27;C:\\\\Users\\\\asus\\\\Desktop\\\\科研\\\\deep-learning-for-image-processing-master\\\\data_set\\\\flower_data&#x27; Pytorch相关操作torch.nn.ReLUnn.ReLU(inplace=True)第一，inplace 默认为False；inplace为True，将会改变输入的数据 ，否则不会改变原输入，只会产生新的输出。设置为True时相当于原地操作，降低内存第二，inplace 取值不影响loss 的反向传播，计算时可直接予以忽略。 注意不能直接使用m = nn.ReLU(m)，因为这是个类，要先实例化12345678910m = torch.randn(1,5)f = nn.ReLU()f1 = nn.ReLU(inplace = True)n = f(m)print(m,n)#可以看到m并不发生变化#tensor([[ 0.1669, 1.5454, 0.6119, -1.2171, -0.4712]]) tensor([[0.1669, 1.5454, 0.6119, 0.0000, 0.0000]])n = f1(m)print(m,n)#inplace = True,m的值也发生变化#tensor([[0.1669, 1.5454, 0.6119, 0.0000, 0.0000]]) tensor([[0.1669, 1.5454, 0.6119, 0.0000, 0.0000]]) torch.nn.Conv2d()padding 这个参数可以是整形(上下左右一致)和tupletuple(a,b)表示在上下各补a行，左右各补b列如果要精确控制每一边，需要使用torch.nn.ZeroPad2d((1,1,2,0))，分别表示了左，右，上，下卷积计算后如果大小不是整数，会进行向下取整（把右边和下面的padding行/列舍去），具体可参考如下连接: 霹雳吧啦的卷积操作详解卷积和池化操作不为整数时的处理 结论：卷积向下取整，池化向上取整 torch.tensor.item()Returns the value of this tensor as a standard Python number. This only works for tensors with one element. This operation is not differentiable. torchvision.datasets.ImageFolder(root:str)可以直接根据文件所在路径生成数据集root/dog/xxx.pngroot/dog/xxy.pngroot/dog/[…]/xxz.png root/cat/123.pngroot/cat/nsdf3.pngroot/cat/[…]/asd932_.png 根据这种文件组成，生成数据集后，会包含class_to_idx一个属性值，是类别和编号的字典。 Tensorboard pytorch 导入相关库，并实例化 SummaryWriter 对象，指定存放地址1234from torch.utils.tensorboard import SummaryWritertb_writer = SummaryWriter(log_dir=&quot;runs/flower_experiment&quot;) 生产网络结构图,在生成模型图的时候，是会走一遍前向传播的过程的，示例是图片网络，init_img用于初始化输入，在add_graph时，传入model,input123456# 实例化模型 model = resnet34(num_classes=args.num_classes).to(device) # 将模型写入tensorboard init_img = torch.zeros((1, 3, 224, 224), device=device) tb_writer.add_graph(model, init_img) 生成训练过程中的参数,tag表示标签值，然后是y，x,设置在每一个epoch后传入，optimizer的param_groups是一个列表，但是只有一个元素，是字典类型，包含了’lr’和’weight_decay’等信息12345tags = [&quot;train_loss&quot;, &quot;accuracy&quot;, &quot;learning_rate&quot;]tb_writer.add_scalar(tags[0], mean_loss, epoch)tb_writer.add_scalar(tags[1], acc, epoch)tb_writer.add_scalar(tags[2], optimizer.param_groups[0][&quot;lr&quot;], epoch) 生成网络某层的具体权重123456tb_writer.add_histogram(tag=&quot;conv1&quot;, values=model.conv1.weight, global_step=epoch)tb_writer.add_histogram(tag=&quot;layer1/block0/conv1&quot;, values=model.layer1[0].conv1.weight, global_step=epoch) 启用Tensorboard1tensorboard --logdir=CMPASS LSTM LSTM官方文档LSTM原理解释 LSTM训练的参数个数：[（5+10）10+10]4官方代码详解： 12345678910111213141516171819202122import torchimport torch.nn as nn input = torch.randn(5, 3, 10)# 序列长度seq_len=5, batch_size=3, 数据向量维数=10，相当于每次运行时取3个含有5个字的句子（且句子中每个字的维度为10）rnn = nn.LSTM(10, 20, 2) # (input_size,hidden_size,num_layers)# 输入数据x的向量维数10, 设定lstm隐藏层的特征维度20, 此model用2个lstm层。如果是1，可以省略，默认为1) # 初始化的隐藏元和记忆元,通常它们的维度是一样的h_0 = torch.randn(2, 3, 20)c_0 = torch.randn(2, 3, 20) # 这里有2层lstm，output是最后一层lstm的每个词向量对应隐藏层的输出,其与层数无关，只与序列长度相关# hn,cn是所有层最后一个隐藏元和记忆元的输出output, (h_n, c_n)= rnn(input, (h_0, c_0))# 一般只用output,可以写成output,_=rnn(input, (h_0, c_0)) print(output.size(),h_n.size(),c_n.size())#[5,3,20]表示每个单词的输出h，序列长度为5#[2,3,20]表示最后一个时刻两层lstm的输出h,所以其实h_n的第二层，也就是h_n[1]是等于output的最后一个序列的输出output[4]的,维度都是[3,20]#[2,3,20]c_n其实表示的是最后一个时间步LSTMcell的状态，一般用不到 参数： batch_first:注意的是输入第一个维度5是序列长度，而不是batch_size,因为batch_first默认为false,可以更改这个参数而00BA2409.png第一个维度是batch_size bidirectional:是否为双向，默认也是false，注意如果改为双向的话，h_0和c_0应该改为(4,3,20),因为相当于左边需要一个h_0,右边也需要一个h_0,这个时候最后一行的输出为：torch.Size([5, 3, 40]) torch.Size([4, 3, 20]) torch.Size([4, 3, 20])，但这个时候h_n和output的关系并不是那么简单的相等，因为ouptput的最后一个是相互拼接的，由正向的最后一个序列（理解为句子中的最后一个单词）的输出和反向的第一个序列（句子正向的最后一个单词）的输出拼接而成。而h_n在反向时对应的是（句子正向的第一个单词）。 将LSTM改为单层，并设置双向，测试输出：12345# 都取batch_size=0,即第一个句子print(output[4][0])#可以看到output的最后一项的前20个数，对应正向计算的最后一个单词，和h_n的第一个维度相等print(output[0][0])#output第一项的后20个数，对应反向计算的第一个单词，和h_n的第二个维度相等print(h_n[0][0])print(h_n[1][0]) tensor([ 0.1486, 0.2394, 0.0672, 0.0645, 0.2413, 0.1021, 0.1093, -0.0268,0.0157, 0.2620, 0.0952, -0.0359, -0.0067, 0.2475, -0.2389, 0.0544,-0.0097, -0.0465, -0.0333, 0.0519, -0.1379, 0.2641, 0.0414, -0.3096,0.2469, -0.0276, -0.2040, -0.1074, 0.4427, -0.3472, -0.6091, 0.0125,-0.3494, -0.0487, 0.0893, 0.1615, -0.1351, -0.1330, 0.0262, 0.0840],grad_fn=) tensor([-0.0323, -0.0765, 0.0101, 0.6987, -0.3392, -0.3428, 0.0212, 0.2404,0.0286, -0.2180, 0.1832, 0.0844, 0.0097, 0.0379, -0.0442, -0.3454,0.4237, -0.0644, 0.2047, 0.3235, -0.1628, 0.1715, 0.1617, -0.0527,0.0454, -0.2222, -0.1592, -0.0439, 0.0854, -0.1595, -0.0295, 0.0063,0.1224, -0.2310, -0.0087, 0.5124, -0.0599, -0.0084, 0.0964, -0.1349],grad_fn=) tensor([ 0.1486, 0.2394, 0.0672, 0.0645, 0.2413, 0.1021, 0.1093, -0.0268,0.0157, 0.2620, 0.0952, -0.0359, -0.0067, 0.2475, -0.2389, 0.0544,-0.0097, -0.0465, -0.0333, 0.0519], grad_fn=) tensor([-0.1628, 0.1715, 0.1617, -0.0527, 0.0454, -0.2222, -0.1592, -0.0439,0.0854, -0.1595, -0.0295, 0.0063, 0.1224, -0.2310, -0.0087, 0.5124,-0.0599, -0.0084, 0.0964, -0.1349], grad_fn=) 详细可参考双向LSTM图解","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"非线性数据结构（树）","slug":"非线性数据结构(树)","date":"2022-02-04T16:00:00.000Z","updated":"2022-12-29T01:59:04.885Z","comments":true,"path":"2022/02/05/非线性数据结构(树)/","link":"","permalink":"http://example.com/2022/02/05/%E9%9D%9E%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E6%A0%91)/","excerpt":"","text":"相关知识&emsp;&emsp;如果数据是固定不动的，则查找数据称为静态查找（没有插入和删除操作，只有查找），如果数据会发生变化，则是动态查找。对于静态查找，可以是顺序查找，则时间复杂度为O(N)，或者二分查找，元素本身是有序排列的，时间复杂度为O(logN)，二分查找时，定义了pre,end,mid。每次查找后，end = mid - 1,或者pre = mid +1;不能直接等于mid，这样会出现死循环。根据二分查找的想法，构造了与之类似的数据结构————树，因此查找次数不会超过数的层数，也即是O(logN)。&emsp;&emsp;实现时，可以通过链表实现，但如果链表指向子树，对于大部分比较稀疏或者度数较大的树，会造成很大的浪费，因此可以将链表设置为2个指针，分别指向兄弟节点和子节点（下图左）。对于二叉树，则可以直接将两个指针分别指向其左右子节点（下图右）。 定义与实现&emsp;&emsp;树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。&emsp;&emsp;一棵有n个节点的树，一共有n-1条边，根节点没有，其中节点的子树个数称为结点的度，一个树的度是节点中最大的度数，二叉树的度数为2，叶结点的度数为0。假设定义$n_2$为度数为2的结点数，$n_0$为叶结点树，则$n_2+1=n_0$，因为$2n_2+n_1(每个结点下的边数)=n_0+n_1+n_2-1(节点数-1)$。&emsp;&emsp;二叉树第$i$层，最多有$2^{i-1}$个结点，层数为i的二叉树，最多有$2^i-1$个结点。&emsp;&emsp;完美二叉树（满二叉树），是指每层都是满的二叉树，仅最后一层不满的且缺少的结点连续，都在右侧时为完全二叉树，其结点的标号和完美二叉树一致。平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。 1234567891011121314151617class TreeNode: def __init__(self, x): self.val = x # 节点值 self.left = None # 左子节点 self.right = None # 右子节点# 初始化节点 n1 = TreeNode(3) # 根节点 root n2 = TreeNode(4) n3 = TreeNode(5) n4 = TreeNode(1) n5 = TreeNode(2) # 构建引用指向 n1.left = n2 n1.right = n3 n2.left = n4 n2.right = n5 123456struct TreeNode&#123;int val;TreeNode *left;TreeNode *right;TreeNode(int x): val(x),left(NULL),right(NULL) &#123;&#125;&#125; 树的遍历&emsp;&emsp;根据遍历根节点的顺序，分为前序，中序和后续遍历三种。通常使用递归实现，三种遍历的路径其实是一致的，区别在于每个节点输出的时刻，前序在第一次遇到该节点时即输出，中序在第二次，后序在第三次。除此之外，还有层次遍历，即从上到下，从左到右。 前中后序遍历迭代法-中序遍历，访问的顺序和处理的顺序不一样，先定义指针cur代表遍历访问的结点，当没有左结点的时候，开始处理，即if和else判断是继续向左遍历，还是开始处理，开始处理的时候，栈顶的元素就是要处理的元素。1234567891011121314151617181920212223242526272829303132333435363738//迭代法class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; stack&lt;TreeNode *&gt; st; TreeNode *cur = root; while(cur!=NULL || !st.empty())&#123; if(cur)&#123; st.push(cur); cur = cur-&gt;left; &#125; else&#123; cur = st.top(); st.pop(); result.push_back(cur-&gt;val); cur = cur-&gt;right; &#125; &#125; return result; &#125;&#125;;//递归法，比较简单，注意引用格式class Solution &#123;public: void zhongxu(TreeNode *root,vector&lt;int&gt; &amp;res)&#123; if(root==NULL) return; zhongxu(root-&gt;left,res); res.push_back(root-&gt;val); zhongxu(root-&gt;right,res); &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; result; zhongxu(root,result); return result; &#125;&#125;;后序遍历的迭代法，注意输出结果反转加入顺序中-&gt;右-&gt;左，（入栈顺序是左右），反转reverse(左右中)前序遍历，输出顺序中-&gt;左-&gt;右，（入栈顺序是右左）123456789101112131415161718192021222324252627282930313233343536373839//前序，先右后左class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); // 中 st.pop(); result.push_back(node-&gt;val); if (node-&gt;right) st.push(node-&gt;right); // 右（空节点不入栈） if (node-&gt;left) st.push(node-&gt;left); // 左（空节点不入栈） &#125; return result; &#125;&#125;;//后序，先左后右，输出反转class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; stack&lt;TreeNode*&gt; st; vector&lt;int&gt; result; if (root == NULL) return result; st.push(root); while (!st.empty()) &#123; TreeNode* node = st.top(); st.pop(); result.push_back(node-&gt;val); if (node-&gt;left) st.push(node-&gt;left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈） if (node-&gt;right) st.push(node-&gt;right); // 空节点不入栈 &#125; reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了 return result; &#125;&#125;; 二叉搜索树&emsp;&emsp;根据二分法的启示，建立一种二叉搜索树，其非空左子树的所有键值小于其根结点的键值，右子树相反，且左右子树都是二叉搜索树。应该实现插入，删除和查找这些基本操作。由于其内部顺序，其最小值为最左侧的结点，最大值为最右侧的结点。&emsp;&emsp;原因是，对于完全二叉树，如果有右结点，则一定有左结点，但是可以仅有左结点，没有右结点，所以，最小值一定是叶节点，因为如果不是，必有左结点，即必有更小的值，但最大值不一定，其可以是有左结点的一个结点。 L98 验证二叉搜索树&emsp;&emsp;很自然的想法就是利用递归，先对一个结点，判断其是否大于左结点，同时小于右结点，然后再判断其左右结点，在整个过程中，只要有一个地方不满足，则直接返回False,结束。但是在递归时，由于更改了原始的结点，所以其父结点的值无法保留，因此定义了一个新的函数，保存了父结点的值，并以范围的方式表示。 方法1：递归，时间复杂度O(n),空间复杂度O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n)； 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, x):# self.val = x# self.left = None# self.right = Noneclass Solution: def isValidBST(self, root): def helper(node, lower = float(&#x27;-inf&#x27;), upper = float(&#x27;inf&#x27;)): if not node: return True val = node.val if val &lt;= lower or val &gt;= upper: return False if not helper(node.right, val, upper): return False if not helper(node.left, lower, val): return False return True return helper(root) 方法2：中序遍历,时间复杂度O(n)，其中 n 为二叉树的节点个数。二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。空间复杂度O(n)，其中 n 为二叉树的节点个数。栈最多存储 n 个节点，因此需要额外的 O(n) 的空间。中序遍历后对于二叉搜索树应该是按从小到大排列的，因此每次需要pop的值应该都比之前pop的值大。 1234567891011121314class Solution: def isValidBST(self, root): stack, inorder = [], float(&#x27;-inf&#x27;) while stack or root: while root: stack.append(root) root = root.left root = stack.pop()#每次pop的结点为没有左结点的结点，因此是中序，即应该为当前树中的最小值，之后pop的都应该比它大 # 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树 if root.val &lt;= inorder: return False inorder = root.val root = root.right return True 剑指 Offer 33. 二叉搜索树的后序遍历序列&emsp;&emsp;输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。&emsp;&emsp;假如是一个二叉搜索树，则根据左结点-右结点-根节点的后序遍历顺序，最后一个元素为根节点，且小于所有的右结点，因此从数组最左边开始遍历，一旦找到大于根结点的值（代码中用q表示），则从当前位置到根节点之前（postorder[q,j-1]），应该都大于根结点，同时其左右子树（postorder[i,q-1]，postorder[q,j-1]）再进行递归。 方法1：递归：时间复杂度$O(N^2)$ ,每次递归的时候减去一个根节点，因此递归占用$O(N)$ ；最差情况下（即当树退化为链表），每轮递归都需遍历树所有节点，占用$O(N)$。空间复杂度$O(N)$:最差情况下（即当树退化为链表），递归深度将达到N。 12345678910111213141516class Solution: def verifyPostorder(self, postorder: List[int]) -&gt; bool: def judge(i,j): if i&gt;=j: return True p = i while postorder[p]&lt;postorder[j]: p+=1 q = p while postorder[p]&gt;postorder[j]: p+=1 if p==j: return judge(i,q-1) and judge(q,j-1) else: return False return judge(0,len(postorder)-1) 方法2：辅助栈，时间复杂度降到O(N)&emsp;&emsp;在后序遍历时，在遍历完右结点后会访问根节点，所以如果是完全二叉树，必然会出现一个数值减小的过程，但是必须从后往前看，因为从前往后看，树的结构不清楚，会比较乱，那么从后往前看，每次数值增大都是从根节点到右结点的过程，设计一个栈进行该操作，当出现数值减小时，说明遇到了左结点，12345678910111213141516171819202122232425262728```## 层序遍历for循环是精髓，保证了每次是处理一层，类似的变种有[很多题](https://www.programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html)，都大差不差，注意往队列中添加元素前，判断是否为空。```cppclass Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) &#123; int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) &#123; TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); &#125; result.push_back(vec); &#125; return result; &#125;&#125;;","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"线性数据结构","slug":"线性数据结构","date":"2022-01-31T16:00:00.000Z","updated":"2022-05-22T04:20:15.111Z","comments":true,"path":"2022/02/01/线性数据结构/","link":"","permalink":"http://example.com/2022/02/01/%E7%BA%BF%E6%80%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","excerpt":"","text":"链表&emsp;&emsp;特点是插入删除容易，但查找不容易，因此，在涉及链表查找的题目时，一般用哈希表来实现，哈希表通过哈希函数将一个输入插入到固定位置，因此哈希表有可能出现空间的浪费，因为插入时不是连续的，但是查找时方便，是用空间换时间的一种方法。发生哈希冲突时则是以链表存储的。 &emsp;&emsp;除此之外，由于链表并不需要初始化长度，因此采用动态内存分配，区别于数组，数组在内存中的空间是连续的，但是链表在内存中不连续。链表属于动态分配，需要申请内存空间(C++中用new)，但是需要手动释放(用delete) 12345int* p = new int;/*数据类型 *指针名称 = new 数据类型 或数据类型 *指针名称 = new 数据类型（初值）；*/delete p//delete指针名称//如果分配成功，会返回内存空间起始地址，不成功返回NULL 使用结构体指针访问变量中成员的两种格式：(*指针变量).成员名 或者 指针变量-&gt;成员名 用C++初始化12345678910111213struct ListNode &#123; int val; // 节点值 ListNode *next; // 后继节点引用 ListNode(int x) : val(x), next(NULL) &#123;&#125;//结构体的初始化函数，传入x则自动给val赋值x&#125;;// 实例化节点ListNode *n1 = new ListNode(4); // 节点 headListNode *n2 = new ListNode(5);ListNode *n3 = new ListNode(1);// 构建引用指向n1-&gt;next = n2;n2-&gt;next = n3;用Python初始化123456789101112class ListNode: def __init__(self, x): self.val = x # 节点值 self.next = None # 后继节点引用# 实例化节点n1 = ListNode(4) # 节点 headn2 = ListNode(5)n3 = ListNode(1)# 构建引用指向n1.next = n2n2.next = n3 链表实现(Python) 参考自：https://blog.csdn.net/Blood_Seeker/article/details/78992722 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105class ListNode(object): #结点初始化函数, p 即模拟所存放的下一个结点的地址 #为了方便传参, 设置 p 的默认值为 0 def __init__(self, x = None): self.val = x self.next = Noneclass LinkList(object): def __init__(self): self.head = None #链表初始化函数, 方法类似于尾插 def initList(self, dataList): #创建头结点 self.head = ListNode(None) # 创建节点的时候传一个参数进去 # 创建头结点，里面不包含数据，头结点之后第一个才存放数据,head节点的数据默认None pTail = self.head # 指向头结点的指针 #逐个为 data 内的数据创建结点, 建立链表 for i in dataList: # 遍历列表 newNode = ListNode(i) # 生成新的节点 pTail.next = newNode # 新节点挂在尾结点上，即 上一个节点指针指向新的节点，由于新节点的next被初始化为None，所以pTail的next自然也是None pTail = newNode # 当前新节点成为新的尾结点 #链表判空 def isEmpty(self): return self.head.next is None #取链表长度 def getLength(self): if self.isEmpty(): exit(0) p = self.head.next len = 0 while p: len += 1 p = p.next return len #遍历链表 def traveList(self): if self.isEmpty(): exit(0) print (&#x27;link list traving result:&#x27;) p = self.head.next # 取得表头之后的第一个数据 while p: print (p.val, end= &quot; &quot;) p = p.next #链表插入数据函数 def insertElem(self, val, index): &quot;&quot;&quot; 在 第index个节点(p.next)之前插入&quot;&quot;&quot; p = self.head i = 1 while p and i &lt; index: p = p.next i = i + 1 if p is None or i &gt; index: print(&quot;ERROR, 无法插入节点&quot;) return False pNew = ListNode(val) # 生成新的节点 包含了 pNew.val = key pNew.next = p.next p.next = pNew def deleteElem(self, index): &quot;删除第index个节点（即删除 p.next节点）&quot; p = self.head i = 1 # 节点计数 while p.next and i &lt; index: p = p.next i = i + 1 if p.next is None or i &gt; index: print(&quot;ERROR, 该节点不存在&quot;) return False delVal = p.next.val print(&quot;deleted value:&quot;, delVal) p.next = p.next.nextif __name__ == &#x27;__main__&#x27;: #初始化链表与数据 # data = [1,2,3,4,5] dataList = [1, 2, 3, 4, 5] l = LinkList() l.initList(dataList) l.traveList() print(&#x27;\\n&#x27;) print(l.getLength()) #插入结点到索引值为3之后, 值为666 l.insertElem(666, 6) l.traveList() print(&#x27;\\n&#x27;) #删除索引值为4的结点 l.deleteElem(4) l.traveList() print(&#x27;\\n&#x27;) 一些链表相关题目L160 相交链表 &emsp;&emsp;这道题注意的是不仅仅是值相交，两个链表相交，则相交部分是完全一致的，因此可以用哈希表实现，也可以用双指针实现，两个指针分别从链表A(总长a)和链表B(总长b)的头出发，当到达结尾后，转向另一个链表，则如果两个链表有相交(相交部分为c)，此时都运动了a+b-c(a+(b-c)和b+(a-c)); L141 环形链表 &emsp;&emsp;利用双指针中的快慢指针，类比跑道上的两个速度不同的人，如果存在环形，则会相遇，但是注意的是两者的速度一定不同，而不能只是起点不同，起点不同不会相遇，会保持固定间隔。当然这种类似于查找是否有重复的，都可以用哈希表 解法1：哈希表，时间复杂度O(n)，空间复杂度O(n) 123456789class Solution(object): def hasCycle(self, head): s = set() # 定义一个set(集合，内部元素不重复)，然后不断遍历链表 while head:# 如果某个节点在set中，说明遍历到重复元素了，也就是有环 if head in s: # 不能把head.val这个值存在哈希表中，因为有可能只是值相同还不够，还需要指针也相同 return True s.add(head) # 如果节点不在哈希表中，说明之前没有相同节点，就存入表中 head = head.next return False 解法2：快慢双指针，时间复杂度O(n)，空间复杂度O(1) 123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next:#链表中是单元素且非循环或链表为空 return False slow = head fast = head.next while slow != fast: if not fast or not fast.next:#只用考虑更快的指针，因为如果链表有限，则快指针先达到结束条件，必须加上fast.next，因为后面有fast.next.next，如果fast.next为null，则null不会有next变量，会报错 return False slow = slow.next fast = fast.next.next return True 123456789101112131415161718class Solution &#123;public: bool hasCycle(ListNode* head) &#123; if (head == nullptr || head-&gt;next == nullptr) &#123; return false; &#125; ListNode* slow = head; ListNode* fast = head-&gt;next; while (slow != fast) &#123; if (fast == nullptr || fast-&gt;next == nullptr) &#123; return false; &#125; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return true; &#125;&#125;; L234 回文链表&emsp;&emsp;实现时，先利用快慢指针，找到链表的中间节点，可以参考后面的面试问题中有提到，同时在指针移动的过程中，进行反转链表，之后从中间位置往两个方向展开。&emsp;&emsp;需要注意的是，对于奇数，慢指针会停在最中间的元素，因此在展开前需要将其后移一位，偶数，则指在中间靠后的元素，因此不需操作。&emsp;&emsp;关于如何判断元素数是奇还是偶，可以对比跳出循环的条件：对于快指针，依次指向0，2，4，即fast指向元素的索引始终为偶数，所以如果有偶数个元素，最后一个元素索引为奇数，则倒数第二次循环后,fast指向倒数第二个元素，fast.next指向最后一个，再次进入循环，此时fast为null,fast.next会报错，但因为是and所以不会,and前是0，自动忽略后面语句（短路现象），如果改为fast.next and fast则会报错。如果有奇数个元素，则最后一次循环q指向最后一个元素,q.next=null;即奇数个元素，fast.next=null,偶数个元素，fast=null,所以if(fast)：在奇数时执行，而为了反转链表引入的pre和prepre则始终在慢指针前面一位，反转时先将pre后移，然后将prepre赋给pre.next，即pre-&gt;prepre,然后prepre后移，即循环结束时，两者指向同一元素。123456789101112131415161718192021222324252627282930313233# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if (head is None) or (head.next is None): return True slow = head fast = head pre = head prepre = ListNode(None) while(fast and fast.next): pre = slow # pre 紧跟在slow 后面一步 slow = slow.next # 快慢指针用于找到中间节点 fast = fast.next.next pre.next = prepre # 用于反转前半部分链表 prepre = pre if (fast): # 如果跳出上一个while循环是 fast.next is None,那么就是奇数个节点，slow需要再走一步 slow = slow.next while(pre and slow): # 从中间对称的位置往两边扩展，比对两边的数是否相等 if (pre.val != slow.val): return False pre = pre.next slow = slow.next return True 链表面试问题&emsp;&emsp;无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。 双指针并不是固定的公式，而是一种思维方式~ &emsp;&emsp;先来看”倒数第k个元素的问题”。设有两个指针 p 和 q，初始时均指向头结点。首先，先让 p 沿着 next 移动 k 次。此时，p 指向第 k+1个结点，q 指向头节点，两个指针的距离为 k 。然后，同时移动 p 和 q，直到 p 指向空，此时 q 即指向倒数第 k 个结点。1234567891011121314class Solution &#123;public: ListNode* getKthFromEnd(ListNode* head, int k) &#123; ListNode *p = head, *q = head; //初始化 while(k--) &#123; //将 p指针移动 k 次 p = p-&gt;next; &#125; while(p != nullptr) &#123;//同时移动，直到 p == nullptr p = p-&gt;next; q = q-&gt;next; &#125; return q; &#125;&#125;;&emsp;&emsp;获取中间元素的问题。设有两个指针 fast 和 slow，初始时指向头节点。每次移动时，fast向后走两次，slow向后走一次，直到 fast 无法向后走两次。这使得在每轮移动之后。fast 和 slow 的距离就会增加一。设链表有 n 个元素，那么最多移动 n/2 轮。当 n 为奇数时，slow 恰好指向中间结点，当 n 为 偶数时，slow 指向中间两个结点的靠前一个还是靠后一个，需要调整循环的条件，下述代码是n为偶数的情况，慢指针指向靠后元素。 1234567891011class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode *p = head, *q = head; while(q != nullptr &amp;&amp; q-&gt;next != nullptr) &#123; p = p-&gt;next; q = q-&gt;next-&gt;next; &#125; return p; &#125; &#125;; &emsp;&emsp;对于上述代码： 比如n=5(下标0~4),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;4，此时q-&gt;next = null结束循环，p指向2，恰好是中间节点。（0，1，2，3，4） 比如n=4(下标0~3),第一轮过后，p-&gt;1，q-&gt;2，第二轮过后，p-&gt;2,q-&gt;null(2.next为3，3.next为null)，此时q = null结束循环，p指向2，是中间节点靠后一个。（0，1，2，3） 将条件改为while(q != nullptr &amp;&amp; q-&gt;next-&gt;next != nullptr)，会指向靠前一个，因为此时不会进行第二轮循环。 &emsp;&emsp;如果存在环，如何判断环的长度呢？方法是，快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。&emsp;&emsp;如何判断环的入口呢？&emsp;&emsp;由等式可知，相遇时d=x+ns(n为相遇时快指针多转了几圈)，则相遇后把两个指针速度变为一致，一个从起点出发，一个从相遇点出发，则因为d=x+ns，必然会在从相遇点出发的指针运动n圈+x后，在环的入口处相遇。(d为起点处出发指针路程，x+ns为从相遇点出发指针路程)，代码实现如下：123456789101112131415161718class Solution: def detectCycle(self, head: ListNode) -&gt; ListNode: walker = head runner = head while(runner and runner.next): walker = walker.next runner = runner.next.next if walker == runner: break if (runner is None) or (runner.next is None): # 如果是因为走到头而退出循环，那就是没有环 return # return False 的话会报错Your returned value is not a ListNode type. # 如果是因为break而跳出循环，那就是有环 walker = head # 步行者回到起点 while(walker != runner): # 没相遇 walker = walker.next runner = runner.next return runner链表相关链接: 漫画算法：如何判断链表有环？ L141环形链表 一些刷题小总结判断输入是否为Noneif not A 和 if A is None 看起来都是在判断A是否为空，实际上这两者是不同的：（1）if not A 判断的是A是否为空，也就是说里面有东西没？（2） if A is None则判断的是A是否声明并定义了？123456789101112131415class Solution: def hasCycle(self, head: ListNode) -&gt; bool: if not head or not head.next:#这里可以写成if head==None or head.next == None，但是其实是不一样的，因为如果head==None，则head.next会报错，因为Nonetype没有next的索引，即上述中的(2),不适用not则判断是否声明同时判断是否为空 return False slow = head fast = head.next while slow != fast: if not fast or not fast.next: return False slow = slow.next fast = fast.next.next return True","categories":[{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]},{"title":"C++学习笔记","slug":"C++","date":"2022-01-12T16:00:00.000Z","updated":"2022-05-22T04:21:57.741Z","comments":true,"path":"2022/01/13/C++/","link":"","permalink":"http://example.com/2022/01/13/C++/","excerpt":"","text":"算术运算前置++和后置++的区别：1234567int n = 5,m = 10;int a,b,c,d;a = n++;//后置++b = m--;c = ++n;//前置++d = --m;cout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;d&lt;&lt;endl;/*输出结果为5，10，7，8。首先对于后置++，可以看到对于a和b是先进行了赋值操作，再进行后置++。执行后a=15,b=10,n=6,m=9。对于前置++，首先进行前置++，再进行赋值操作*/ 后置++的优先级&gt;前置++的优先级&gt;乘和除的优先级&gt;…&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，！=&gt;赋值运算，优先级和上述性质无关。用优先性解释上述现象有矛盾，所以，可以按照这个记吧 强制类型转换：12int (a)(int) a //两种方式均可 其优先级高于乘数法，和逻辑非，按位取反同级。因此 double(n)/2 是先将n转换为double再做除法 逻辑运算 双目运算：&amp;&amp; ||单目运算：! 逻辑！负号-&gt;乘除运算等&gt;&gt;关系运算&gt;，&lt;，&gt;=,&lt;=&gt;关系运算==，!=&gt;逻辑&amp;&amp;&gt;逻辑||。为了避免优先级的混乱，多使用圆括号 位运算 &amp;，|，^(异或)，&lt;&lt;左移,&gt;&gt;右移,~(按位取反) 按位取反的时候要考虑到数据的字节数，对于一个正数，前面所有的0都要变成1,左移一位相当于2，右移相当于除2。复合位运算(&amp;=，|=等)的结合顺序是*从右向左，除此之外还有(!,~,+,-,前置++/—)也是从右向左结合，比较特殊。 特殊符号 “=”赋值运算，其结合顺序是从右向左且其左侧(lvalue)不能是表达式，只能是变量，数组等 ?:,比如y=(x&gt;=1?1:0)即可表达一个分段函数:y=1(x&gt;=1),y=0(x&lt;1) 逗号表达式，依次计算每个表达式的值，整体等于最后一个逗号后式子的值，如y=(1,2,3+5),则y=8 算法优先级顺序 数据类型转换原则 整型变量和字符变量其在内存中存放的都是整数，整数，存放的是二进制格式，字符，存放的是ASCII码值(","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[]},{"title":"深度学习回顾性记录","slug":"不想发布的/强化学习（一）","date":"2022-01-10T16:00:00.000Z","updated":"2022-06-10T01:28:55.128Z","comments":true,"path":"2022/01/11/不想发布的/强化学习（一）/","link":"","permalink":"http://example.com/2022/01/11/%E4%B8%8D%E6%83%B3%E5%8F%91%E5%B8%83%E7%9A%84/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}],"tags":[]},{"title":"如何利用Hexo搭建自己的博客","slug":"Hexo","date":"2022-01-09T16:00:00.000Z","updated":"2022-05-22T04:13:38.123Z","comments":true,"path":"2022/01/10/Hexo/","link":"","permalink":"http://example.com/2022/01/10/Hexo/","excerpt":"","text":"安装Hexo&emsp;&emsp;安装的过程可以参考 Hexo官网。&emsp;&emsp;首先，需要保证安装好了node.js和git，这两个软件的安装也比较简单，直接官网安装就好。然后在命令行窗口中利用以下命令安装hexo，其中g代表对全局安装1npm install hexo-cli-g&emsp;&emsp;然后是新建一个文件夹，这个文件夹将自动生成一些默认的文件,之后的命令行窗口操作都是在该文件夹下进行12hexo init [文件夹名]cd [文件夹名]&emsp;&emsp;然后安装一下需要的依赖（可能就是默认工具包的意思？）1npm install&emsp;&emsp;然后执行1hexo s 部署操作1234hexo chexo s #生成本地预览hexo g #生成静态文章hexo d #上传，必须先执行hexo g 选择一个好看的主题&emsp;&emsp;在 Hexo官网提供了很多主题，选择一个好看的主题后，点击进入主题对应的github中，即可看到相关的命令，仍然在该文件夹下执行命令后即可安装，安装后会在theme文件夹下看到一个对应得主题文件夹，比如这里我选择安装了butterfly主题，就会生成一个对应的文件夹 Butterfly各种参数介绍及实际操作视频，强推这个宝藏UP啊主题操作教程 Markdown写作基础标题123# 一级标题## 二级标题...... 上述代码的执行效果如下： 字体效果1234567**加粗***斜体*~~删除~~==高亮==其他：加两个空格：&amp;emsp;&amp;emsp;（这个还挺麻烦的） 上述代码的执行效果如下：&emsp;&emsp;加粗 &emsp;&emsp;斜体&emsp;&emsp; 删除&emsp;&emsp;==高亮== 引用12&gt;引用内容&gt;&gt;增加&gt;数量可以设置多层引用 上述代码的执行效果如下： 引用内容 增加&gt;数量可以设置多层引用 分割线1*** 上述代码的执行效果如下： 图片和链接123![图片的名字](网上图片的链接或者本地图片的路径)[连接名称](链接地址)比如：[baidu](www.baidu.com) 搭建图床Gitee崩了啊可恶，还是Github香 Github图床搭建操作 公式 可以参考链接：https://blog.csdn.net/weixin_42546496/article/details/88115095","categories":[{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"}],"tags":[]}],"categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"博客和写作","slug":"博客和写作","permalink":"http://example.com/categories/%E5%8D%9A%E5%AE%A2%E5%92%8C%E5%86%99%E4%BD%9C/"},{"name":"算法和数据结构","slug":"算法和数据结构","permalink":"http://example.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[]}